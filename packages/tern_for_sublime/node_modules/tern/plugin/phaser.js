
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("./modules"))
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "./modules"], mod)
  mod(tern, tern)
})(function(infer, tern) {
  "use strict";
    
  tern.registerPlugin("phaser", function(server, options) {
    server.addDefs(defs);
  });
  
  var defs = {
  "WebGLGraphics": {
    "!doc": "A set of functions used by the webGL renderer to draw the primitive graphics data",
    "!type": "fn()",
    "prototype": {}
  },
  "CanvasTinter": {
    "!doc": "Utility methods for Sprite/Texture tinting.",
    "!type": "fn()",
    "prototype": {}
  },
  "WebGLGraphicsData": {
    "!doc": "",
    "!type": "fn()",
    "prototype": {}
  },
  "CanvasPool": {
    "!doc": "The CanvasPool is a global static object that allows Pixi and Phaser to pool canvas DOM elements.",
    "!type": "fn()",
    "prototype": {}
  },
  "Phaser": {
    "Easing": {
      "!doc": "A collection of easing methods defining ease-in and ease-out curves.",
      "Exponential": {
        "!doc": "Exponential easing.",
        "!type": "fn()",
        "prototype": {
          "In": {
            "!doc": "Exponential ease-in.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "InOut": {
            "!doc": "Exponential ease-in/out.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "Out": {
            "!doc": "Exponential ease-out.",
            "!type": "fn(k: +Number) -> +Number"
          }
        }
      },
      "Cubic": {
        "!doc": "Cubic easing.",
        "!type": "fn()",
        "prototype": {
          "In": {
            "!doc": "Cubic ease-in.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "InOut": {
            "!doc": "Cubic ease-in/out.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "Out": {
            "!doc": "Cubic ease-out.",
            "!type": "fn(k: +Number) -> +Number"
          }
        }
      },
      "prototype": {},
      "Linear": {
        "!doc": "Linear easing.",
        "!type": "fn()",
        "prototype": {"None": {
          "!doc": "Linear Easing (no variation).",
          "!type": "fn(k: +Number) -> +Number"
        }}
      },
      "Circular": {
        "!doc": "Circular easing.",
        "!type": "fn()",
        "prototype": {
          "In": {
            "!doc": "Circular ease-in.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "InOut": {
            "!doc": "Circular ease-in/out.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "Out": {
            "!doc": "Circular ease-out.",
            "!type": "fn(k: +Number) -> +Number"
          }
        }
      },
      "Elastic": {
        "!doc": "Elastic easing.",
        "!type": "fn()",
        "prototype": {
          "In": {
            "!doc": "Elastic ease-in.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "InOut": {
            "!doc": "Elastic ease-in/out.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "Out": {
            "!doc": "Elastic ease-out.",
            "!type": "fn(k: +Number) -> +Number"
          }
        }
      },
      "Quartic": {
        "!doc": "Quartic easing.",
        "!type": "fn()",
        "prototype": {
          "In": {
            "!doc": "Quartic ease-in.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "InOut": {
            "!doc": "Quartic ease-in/out.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "Out": {
            "!doc": "Quartic ease-out.",
            "!type": "fn(k: +Number) -> +Number"
          }
        }
      },
      "Back": {
        "!doc": "Back easing.",
        "!type": "fn()",
        "prototype": {
          "In": {
            "!doc": "Back ease-in.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "InOut": {
            "!doc": "Back ease-in/out.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "Out": {
            "!doc": "Back ease-out.",
            "!type": "fn(k: +Number) -> +Number"
          }
        }
      },
      "Sinusoidal": {
        "!doc": "Sinusoidal easing.",
        "!type": "fn()",
        "prototype": {
          "In": {
            "!doc": "Sinusoidal ease-in.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "InOut": {
            "!doc": "Sinusoidal ease-in/out.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "Out": {
            "!doc": "Sinusoidal ease-out.",
            "!type": "fn(k: +Number) -> +Number"
          }
        }
      },
      "Bounce": {
        "!doc": "Bounce easing.",
        "!type": "fn()",
        "prototype": {
          "In": {
            "!doc": "Bounce ease-in.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "InOut": {
            "!doc": "Bounce ease-in/out.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "Out": {
            "!doc": "Bounce ease-out.",
            "!type": "fn(k: +Number) -> +Number"
          }
        }
      },
      "!type": "fn()",
      "Quintic": {
        "!doc": "Quintic easing.",
        "!type": "fn()",
        "prototype": {
          "In": {
            "!doc": "Quintic ease-in.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "InOut": {
            "!doc": "Quintic ease-in/out.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "Out": {
            "!doc": "Quintic ease-out.",
            "!type": "fn(k: +Number) -> +Number"
          }
        }
      },
      "Quadratic": {
        "!doc": "Quadratic easing.",
        "!type": "fn()",
        "prototype": {
          "In": {
            "!doc": "Ease-in.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "InOut": {
            "!doc": "Ease-in/out.",
            "!type": "fn(k: +Number) -> +Number"
          },
          "Out": {
            "!doc": "Ease-out.",
            "!type": "fn(k: +Number) -> +Number"
          }
        }
      }
    },
    "SignalBinding": {
      "!doc": "Object that represents a binding between a Signal and a listener function.\nThis is an internal constructor and shouldn't be created directly.\nInspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.",
      "!type": "fn(signal: +Phaser.Signal, listener: +Function, isOnce: +Boolean, listenerContext: +Object, priority: +Number, args: +Object)",
      "prototype": {
        "getSignal": {
          "!doc": "",
          "!type": "fn() -> +Phaser.Signal"
        },
        "isBound": {
          "!doc": "",
          "!type": "fn() -> +Boolean"
        },
        "context": {
          "!doc": "Context on which listener will be executed (object that should represent the `this` variable inside listener function).",
          "!type": "+Object"
        },
        "callCount": {
          "!doc": "The number of times the handler function has been called.",
          "!type": "+Number"
        },
        "detach": {
          "!doc": "Detach binding from signal.\nalias to: @see mySignal.remove(myBinding.getListener());",
          "!type": "fn() -> +Function"
        },
        "active": {
          "!doc": "If binding is active and should be executed.",
          "!type": "+Boolean"
        },
        "toString": {
          "!doc": "",
          "!type": "fn() -> +String"
        },
        "params": {
          "!doc": "Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute` (curried parameters).",
          "!type": "+Array"
        },
        "execute": {
          "!doc": "Call listener passing arbitrary parameters.\nIf binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.",
          "!type": "fn(paramsArr: +Array._any_) -> +Object"
        },
        "isOnce": {
          "!doc": "",
          "!type": "fn() -> +Boolean"
        },
        "getListener": {
          "!doc": "",
          "!type": "fn() -> +Function"
        }
      }
    },
    "QuadTree": {
      "!doc": "A QuadTree implementation. The original code was a conversion of the Java code posted to GameDevTuts.\nHowever I've tweaked it massively to add node indexing, removed lots of temp. var creation and significantly increased performance as a result.\nOriginal version at https://github.com/timohausmann/quadtree-js/",
      "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, maxObjects: +Number, maxLevels: +Number, level: +Number)",
      "prototype": {
        "getIndex": {
          "!doc": "Determine which node the object belongs to.",
          "!type": "fn(rect: +Phaser.Rectangle) -> +Number"
        },
        "maxLevels": {
          "!doc": "The maximum number of levels to break down to.",
          "!type": "+Number"
        },
        "level": {
          "!doc": "The current level.",
          "!type": "+Number"
        },
        "objects": {
          "!doc": "Array of quadtree children.",
          "!type": "+Array"
        },
        "clear": {
          "!doc": "Clear the quadtree.",
          "!type": "fn()"
        },
        "insert": {
          "!doc": "Insert the object into the node. If the node exceeds the capacity, it will split and add all objects to their corresponding subnodes.",
          "!type": "fn(body: +Phaser.Physics.Arcade.Body)"
        },
        "populate": {
          "!doc": "Populates this quadtree with the children of the given Group. In order to be added the child must exist and have a body property.",
          "!type": "fn(group: +Phaser.Group)"
        },
        "split": {
          "!doc": "Split the node into 4 subnodes",
          "!type": "fn()"
        },
        "nodes": {
          "!doc": "Array of associated child nodes.",
          "!type": "+Array"
        },
        "populateHandler": {
          "!doc": "Handler for the populate method.",
          "!type": "fn(sprite: +Phaser.Sprite)"
        },
        "bounds": {
          "!doc": "Object that contains the quadtree bounds.",
          "!type": "+Object"
        },
        "reset": {
          "!doc": "Resets the QuadTree.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, maxObjects: +Number, maxLevels: +Number, level: +Number)"
        },
        "retrieve": {
          "!doc": "Return all objects that could collide with the given Sprite or Rectangle.",
          "!type": "fn(source: +Phaser.Sprite) -> +Array"
        },
        "maxObjects": {
          "!doc": "The maximum number of objects per node.",
          "!type": "+Number"
        }
      }
    },
    "TilemapParser": {
      "INSERT_NULL": "+Boolean",
      "getEmptyData": {
        "!doc": "Returns an empty map data object.",
        "!type": "fn() -> +Object"
      },
      "parseJSON": {
        "!doc": "Parses a Tiled JSON file into valid map data.",
        "!type": "fn(json: +Object) -> +Object"
      },
      "!doc": "Phaser.TilemapParser parses data objects from Phaser.Loader that need more preparation before they can be inserted into a Tilemap.",
      "parse": {
        "!doc": "Parse tilemap data from the cache and creates a Tilemap object.",
        "!type": "fn(game: +Phaser.Game, key: +String, tileWidth: +Number, tileHeight: +Number, width: +Number, height: +Number) -> +Object"
      },
      "!type": "fn()",
      "prototype": {},
      "parseCSV": {
        "!doc": "Parses a CSV file into valid map data.",
        "!type": "fn(key: +String, data: +String, tileWidth: +Number, tileHeight: +Number) -> +Object"
      }
    },
    "Creature": {
      "init": {
        "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
        "!type": "fn()"
      },
      "install": {
        "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
        "!type": "fn()"
      },
      "!doc": "Creature is a custom Game Object used in conjunction with the Creature Runtime libraries by Kestrel Moon Studios.\n\nIt allows you to display animated Game Objects that were created with the [Creature Automated Animation Tool](http://www.kestrelmoon.com/creature/).\n\nNote 1: You can only use Phaser.Creature objects in WebGL enabled games. They do not work in Canvas mode games.\n\nNote 2: You must use a build of Phaser that includes the CreatureMeshBone.js runtime and gl-matrix.js, or have them\nloaded before your Phaser game boots.\n\nSee the Phaser custom build process for more details.\n\nBy default the Creature runtimes are NOT included in any pre-configured version of Phaser.\n\nSo you'll need to do `grunt custom` to create a build that includes them.",
      "!type": "fn(game: +Phaser.Game, x: +Number, y: +Number, key: +String, mesh: +String, animation: +String)",
      "prototype": {
        "play": {
          "!doc": "Plays the currently set animation.",
          "!type": "fn(loop: +Boolean)"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "lifespan": {
          "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
          "!type": "+Number"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "inCamera": {
          "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
          "!type": "+Boolean"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "loop": {
          "!doc": "Should the _current_ animation loop or not?",
          "!type": "+Boolean"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "revive": {
          "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
          "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
        },
        "fixedToCamera": {
          "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
          "!type": "+Boolean"
        },
        "renderOrderID": {
          "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
          "!type": "+Number"
        },
        "bringToTop": {
          "!doc": "Brings this Game Object to the top of its parents display list.\nVisually this means it will render over the top of any old child in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "events": {
          "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
          "!type": "+Phaser.Events"
        },
        "moveUp": {
          "!doc": "Moves this Game Object up one place in its parents display list.\nThis call has no effect if the Game Object is already at the top of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousRotation": {
          "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
          "!type": "+Number"
        },
        "isPlaying": {
          "!doc": "Is the _current_ animation playing?",
          "!type": "+Boolean"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "postUpdate": {
          "!doc": "Internal method called by the World postUpdate cycle.",
          "!type": "fn()"
        },
        "cameraOffset": {
          "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
          "!type": "+Phaser.Point"
        },
        "destroy": {
          "!doc": "Destroys the Game Object. This removes it from its parent group, destroys the input, event and animation handlers if present\nand nulls its reference to `game`, freeing it up for garbage collection.\n\nIf this Game Object has the Events component it will also dispatch the `onDestroy` event.\n\nYou can optionally also destroy the BaseTexture this Game Object is using. Be careful if you've\nmore than one Game Object sharing the same BaseTexture.",
          "!type": "fn(destroyChildren: +Boolean, destroyTexture: +Boolean)"
        },
        "moveDown": {
          "!doc": "Moves this Game Object down one place in its parents display list.\nThis call has no effect if the Game Object is already at the bottom of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "setAnimation": {
          "!doc": "Sets the Animation this Creature object will play, as defined in the mesh data.",
          "!type": "fn(key: +String)"
        },
        "animation": {
          "!doc": "The CreatureAnimation instance.",
          "!type": "+CreatureAnimation"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "stop": {
          "!doc": "Stops the currently playing animation.",
          "!type": "fn()"
        },
        "name": {
          "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
          "!type": "+String"
        },
        "reset": {
          "!doc": "Resets the Game Object.\n\nThis moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`, \n`visible` and `renderable` to true.\n\nIf this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.\n\nIf this Game Object has a Physics Body it will reset the Body.",
          "!type": "fn(x: +Number, y: +Number, health: +Number) -> +PIXI.DisplayObject"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "preUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn()"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "components": {
          "!doc": "The components this Game Object has installed.",
          "!type": "+Object"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
          "!type": "+Boolean"
        },
        "vertices": {
          "!doc": "The vertices data.",
          "!type": "+PIXI.Float32Array"
        },
        "timeDelta": {
          "!doc": "How quickly the animation advances.",
          "!type": "+Number"
        },
        "update": {
          "!doc": "Override this method in your own custom objects to handle any update requirements.\nIt is called immediately after `preUpdate` and before `postUpdate`.\nRemember if this Game Object has any children you should call update on those too.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "colors": {
          "!doc": "The vertices colors",
          "!type": "+PIXI.Uint16Array"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "creatureBoundsMin": {
          "!doc": "The minimum bounds point.",
          "!type": "+Phaser.Point"
        },
        "world": {
          "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
          "!type": "+Phaser.Point"
        },
        "animations": {
          "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
          "!type": "+Phaser.AnimationManager"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        },
        "key": {
          "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
          "!type": "+String"
        },
        "debug": {
          "!doc": "A debug flag designed for use with `Game.enableStep`.",
          "!type": "+Boolean"
        },
        "manager": {
          "!doc": "The CreatureManager instance for this object.",
          "!type": "+CreatureManager"
        },
        "texture": {
          "!doc": "The texture the animation is using.",
          "!type": "+PIXI.Texture"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends this Game Object to the bottom of its parents display list.\nVisually this means it will render below all other children in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "destroyPhase": {
          "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
          "!type": "+Boolean"
        },
        "kill": {
          "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousPosition": {
          "!doc": "The position the Game Object was located in the previous frame.",
          "!type": "+Phaser.Point"
        },
        "indices": {
          "!doc": "",
          "!type": "+PIXI.Uint16Array"
        },
        "pendingDestroy": {
          "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
          "!type": "+Boolean"
        },
        "uvs": {
          "!doc": "The UV data.",
          "!type": "+PIXI.Float32Array"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "autoCull": {
          "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "exists": {
          "!doc": "Controls if this Game Object is processed by the core game loop.\nIf this Game Object has a physics body it also controls if its physics body is updated or not.\nWhen `exists` is set to `false` it will remove its physics body from the physics world if it has one.\nIt also toggles the `visible` property to false as well.\n\nSetting `exists` to true will add its physics body back in to the physics world, if it has one.\nIt will also set the `visible` property to `true`.",
          "!type": "+Boolean"
        },
        "z": {
          "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
          "!type": "+Number"
        },
        "creatureBoundsMax": {
          "!doc": "The maximum bounds point.",
          "!type": "+Phaser.Point"
        },
        "fresh": {
          "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
          "!type": "+Boolean"
        }
      }
    },
    "POLYGON": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Rectangle": {
      "inflatePoint": {
        "!doc": "Increases the size of the Rectangle object. This method is similar to the Rectangle.inflate() method except it takes a Point object as a parameter.",
        "!type": "fn(a: +Phaser.Rectangle, point: +Phaser.Point) -> +Phaser.Rectangle"
      },
      "!doc": "Creates a new Rectangle object with the top-left corner specified by the x and y parameters and with the specified width and height parameters.\nIf you call this function without parameters, a Rectangle with x, y, width, and height properties set to 0 is created.",
      "sameDimensions": {
        "!doc": "Determines if the two objects (either Rectangles or Rectangle-like) have the same width and height values under strict equality.",
        "!type": "fn(a: +Rectangle_like, b: +Rectangle_like) -> +Boolean"
      },
      "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number)",
      "containsPoint": {
        "!doc": "Determines whether the specified point is contained within the rectangular region defined by this Rectangle object. This method is similar to the Rectangle.contains() method, except that it takes a Point object as a parameter.",
        "!type": "fn(a: +Phaser.Rectangle, point: +Phaser.Point) -> +Boolean"
      },
      "prototype": {
        "ceilAll": {
          "!doc": "Runs Math.ceil() on the x, y, width and height values of this Rectangle.",
          "!type": "fn()"
        },
        "centerY": {
          "!doc": "The y coordinate of the center of the Rectangle.",
          "!type": "+Number"
        },
        "intersects": {
          "!doc": "Determines whether this Rectangle and another given Rectangle intersect with each other.\nThis method checks the x, y, width, and height properties of the two Rectangles.",
          "!type": "fn(b: +Phaser.Rectangle) -> +Boolean"
        },
        "centerX": {
          "!doc": "The x coordinate of the center of the Rectangle.",
          "!type": "+Number"
        },
        "bottomRight": {
          "!doc": "Gets or sets the location of the Rectangles bottom right corner as a Point object.",
          "!type": "+Phaser.Point"
        },
        "offsetPoint": {
          "!doc": "Adjusts the location of the Rectangle object using a Point object as a parameter. This method is similar to the Rectangle.offset() method, except that it takes a Point object as a parameter.",
          "!type": "fn(point: +Phaser.Point) -> +Phaser.Rectangle"
        },
        "scale": {
          "!doc": "Scales the width and height of this Rectangle by the given amounts.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Rectangle"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "aabb": {
          "!doc": "Calculates the Axis Aligned Bounding Box (or aabb) from an array of points.",
          "!type": "fn(points: +Array._Phaser.Point_, out: +Phaser.Rectangle) -> +Phaser.Rectangle"
        },
        "empty": {
          "!doc": "Gets or sets the Rectangles empty state.",
          "!type": "+Boolean"
        },
        "copyTo": {
          "!doc": "Copies the x, y, width and height properties from this Rectangle to any given object.",
          "!type": "fn(source: +Object) -> +Object"
        },
        "random": {
          "!doc": "Returns a uniformly distributed random point from anywhere within this Rectangle.",
          "!type": "fn(out: +Phaser.Point) -> +Phaser.Point"
        },
        "top": {
          "!doc": "The y coordinate of the top of the Rectangle.",
          "!type": "+Number"
        },
        "intersection": {
          "!doc": "If the Rectangle object specified in the toIntersect parameter intersects with this Rectangle object, returns the area of intersection as a Rectangle object. If the Rectangles do not intersect, this method returns an empty Rectangle object with its properties set to 0.",
          "!type": "fn(b: +Phaser.Rectangle, out: +Phaser.Rectangle) -> +Phaser.Rectangle"
        },
        "halfWidth": {
          "!doc": "Half of the width of the Rectangle.",
          "!type": "+Number"
        },
        "floor": {
          "!doc": "Runs Math.floor() on both the x and y values of this Rectangle.",
          "!type": "fn()"
        },
        "height": {
          "!doc": "The height of the Rectangle. This value should never be set to a negative.",
          "!type": "+Number"
        },
        "bottomLeft": {
          "!doc": "Gets or sets the location of the Rectangles bottom left corner as a Point object.",
          "!type": "+Phaser.Point"
        },
        "offset": {
          "!doc": "Adjusts the location of the Rectangle object, as determined by its top-left corner, by the specified amounts.",
          "!type": "fn(dx: +Number, dy: +Number) -> +Phaser.Rectangle"
        },
        "centerOn": {
          "!doc": "Centers this Rectangle so that the center coordinates match the given x and y values.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Rectangle"
        },
        "floorAll": {
          "!doc": "Runs Math.floor() on the x, y, width and height values of this Rectangle.",
          "!type": "fn()"
        },
        "halfHeight": {
          "!doc": "Half of the height of the Rectangle.",
          "!type": "+Number"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.",
          "!type": "+Number"
        },
        "topRight": {
          "!doc": "The location of the Rectangles top left corner as a Point object.",
          "!type": "+Phaser.Point"
        },
        "ceil": {
          "!doc": "Runs Math.ceil() on both the x and y values of this Rectangle.",
          "!type": "fn()"
        },
        "union": {
          "!doc": "Adds two Rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two Rectangles.",
          "!type": "fn(b: +Phaser.Rectangle, out: +Phaser.Rectangle) -> +Phaser.Rectangle"
        },
        "right": {
          "!doc": "The sum of the x and width properties.",
          "!type": "+Number"
        },
        "copyFrom": {
          "!doc": "Copies the x, y, width and height properties from any given object to this Rectangle.",
          "!type": "fn(source: +Object) -> +Phaser.Rectangle"
        },
        "volume": {
          "!doc": "The volume of the Rectangle derived from width * height.",
          "!type": "+Number"
        },
        "contains": {
          "!doc": "Determines whether the specified coordinates are contained within the region defined by this Rectangle object.",
          "!type": "fn(x: +Number, y: +Number) -> +Boolean"
        },
        "size": {
          "!doc": "The size of the Rectangle object, expressed as a Point object with the values of the width and height properties.",
          "!type": "fn(output: +Phaser.Point) -> +Phaser.Point"
        },
        "inflate": {
          "!doc": "Increases the size of the Rectangle object by the specified amounts. The center point of the Rectangle object stays the same, and its size increases to the left and right by the dx value, and to the top and the bottom by the dy value.",
          "!type": "fn(dx: +Number, dy: +Number) -> +Phaser.Rectangle"
        },
        "left": {
          "!doc": "The x coordinate of the left of the Rectangle.",
          "!type": "+Number"
        },
        "equals": {
          "!doc": "Determines whether the two Rectangles are equal.\nThis method compares the x, y, width and height properties of each Rectangle.",
          "!type": "fn(b: +Phaser.Rectangle) -> +Boolean"
        },
        "perimeter": {
          "!doc": "The perimeter size of the Rectangle. This is the sum of all 4 sides.",
          "!type": "+Number"
        },
        "topLeft": {
          "!doc": "The location of the Rectangles top left corner as a Point object.",
          "!type": "+Phaser.Point"
        },
        "clone": {
          "!doc": "Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.",
          "!type": "fn(output: +Phaser.Rectangle) -> +Phaser.Rectangle"
        },
        "x": {
          "!doc": "The x coordinate of the top-left corner of the Rectangle.",
          "!type": "+Number"
        },
        "width": {
          "!doc": "The width of the Rectangle. This value should never be set to a negative.",
          "!type": "+Number"
        },
        "setTo": {
          "!doc": "Sets the members of Rectangle to the specified values.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number) -> +Phaser.Rectangle"
        },
        "resize": {
          "!doc": "Resize the Rectangle by providing a new width and height.\nThe x and y positions remain unchanged.",
          "!type": "fn(width: +Number, height: +Number) -> +Phaser.Rectangle"
        },
        "y": {
          "!doc": "The y coordinate of the top-left corner of the Rectangle.",
          "!type": "+Number"
        },
        "toString": {
          "!doc": "Returns a string representation of this object.",
          "!type": "fn() -> +String"
        },
        "randomX": {
          "!doc": "A random value between the left and right values (inclusive) of the Rectangle.",
          "!type": "+Number"
        },
        "containsRect": {
          "!doc": "Determines whether the first Rectangle object is fully contained within the second Rectangle object.\nA Rectangle object is said to contain another if the second Rectangle object falls entirely within the boundaries of the first.",
          "!type": "fn(b: +Phaser.Rectangle) -> +Boolean"
        },
        "intersectsRaw": {
          "!doc": "Determines whether the coordinates given intersects (overlaps) with this Rectangle.",
          "!type": "fn(left: +Number, right: +Number, top: +Number, bottom: +Number, tolerance: +Number) -> +Boolean"
        },
        "randomY": {
          "!doc": "A random value between the top and bottom values (inclusive) of the Rectangle.",
          "!type": "+Number"
        }
      },
      "containsRaw": {
        "!doc": "Determines whether the specified coordinates are contained within the region defined by the given raw values.",
        "!type": "fn(rx: +Number, ry: +Number, rw: +Number, rh: +Number, x: +Number, y: +Number) -> +Boolean"
      }
    },
    "TEXT": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Image": {
      "init": {
        "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
        "!type": "fn()"
      },
      "install": {
        "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
        "!type": "fn()"
      },
      "!doc": "An Image is a light-weight object you can use to display anything that doesn't need physics or animation.\nIt can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.",
      "!type": "fn(game: +Phaser.Game, x: +Number, y: +Number, key: +String, frame: +String)",
      "prototype": {
        "play": {
          "!doc": "Plays an Animation.\n\nThe animation should have previously been created via `animations.add`.\n\nIf the animation is already playing calling this again won't do anything.\nIf you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.",
          "!type": "fn(name: +String, frameRate: +Number, loop: +Boolean, killOnComplete: +Boolean) -> +Phaser.Animation"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "lifespan": {
          "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
          "!type": "+Number"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "inCamera": {
          "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
          "!type": "+Boolean"
        },
        "offsetX": {
          "!doc": "The amount the Game Object is visually offset from its x coordinate.\nThis is the same as `width * anchor.x`.\nIt will only be > 0 if anchor.x is not equal to zero.",
          "!type": "+Number"
        },
        "resizeFrame": {
          "!doc": "Resizes the Frame dimensions that the Game Object uses for rendering.\n\nYou shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData\nit can be useful to adjust the dimensions directly in this way.",
          "!type": "fn(parent: +Object, width: +Number, height: +Number)"
        },
        "tintedTexture": {
          "!doc": "A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)",
          "!type": "+Phaser.Canvas"
        },
        "offsetY": {
          "!doc": "The amount the Game Object is visually offset from its y coordinate.\nThis is the same as `height * anchor.y`.\nIt will only be > 0 if anchor.y is not equal to zero.",
          "!type": "+Number"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "revive": {
          "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
          "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
        },
        "fixedToCamera": {
          "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
          "!type": "+Boolean"
        },
        "renderOrderID": {
          "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
          "!type": "+Number"
        },
        "bringToTop": {
          "!doc": "Brings this Game Object to the top of its parents display list.\nVisually this means it will render over the top of any old child in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "events": {
          "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
          "!type": "+Phaser.Events"
        },
        "moveUp": {
          "!doc": "Moves this Game Object up one place in its parents display list.\nThis call has no effect if the Game Object is already at the top of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousRotation": {
          "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
          "!type": "+Number"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "postUpdate": {
          "!doc": "Internal method called by the World postUpdate cycle.",
          "!type": "fn()"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.\nThis is the same as `y + height - offsetY`.",
          "!type": "+Number"
        },
        "cameraOffset": {
          "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
          "!type": "+Phaser.Point"
        },
        "smoothed": {
          "!doc": "Enable or disable texture smoothing for this Game Object.\n\nIt only takes effect if the Game Object is using an image based texture.\n\nSmoothing is enabled by default.",
          "!type": "+Boolean"
        },
        "destroy": {
          "!doc": "Destroys the Game Object. This removes it from its parent group, destroys the input, event and animation handlers if present\nand nulls its reference to `game`, freeing it up for garbage collection.\n\nIf this Game Object has the Events component it will also dispatch the `onDestroy` event.\n\nYou can optionally also destroy the BaseTexture this Game Object is using. Be careful if you've\nmore than one Game Object sharing the same BaseTexture.",
          "!type": "fn(destroyChildren: +Boolean, destroyTexture: +Boolean)"
        },
        "moveDown": {
          "!doc": "Moves this Game Object down one place in its parents display list.\nThis call has no effect if the Game Object is already at the bottom of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "updateCrop": {
          "!doc": "If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,\nor the rectangle it references, then you need to update the crop frame by calling this method.",
          "!type": "fn()"
        },
        "input": {
          "!doc": "The Input Handler for this Game Object.\n\nBy default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.\n\nAfter you have done this, this property will be a reference to the Phaser InputHandler.",
          "!type": "+Phaser.InputHandler"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "overlap": {
          "!doc": "Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object, \nwhich can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.\n\nThis check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.\n\nTherefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.\nIt should be fine for low-volume testing where physics isn't required.",
          "!type": "fn(displayObject: +Phaser.Sprite) -> +Boolean"
        },
        "left": {
          "!doc": "The left coordinate of the Game Object.\nThis is the same as `x - offsetX`.",
          "!type": "+Number"
        },
        "loadTexture": {
          "!doc": "Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.\n\nIf your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.\n\nYou should only use `loadTexture` if you want to replace the base texture entirely.\n\nCalling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.\n\nYou can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite. \nDoing this then sets the key to be the `frame` argument (the frame is set to zero). \n\nThis allows you to create sprites using `load.image` during development, and then change them \nto use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS' \nand swapping it to be the key of the atlas data.\n\nNote: You cannot use a RenderTexture as a texture for a TileSprite.",
          "!type": "fn(key: +String, frame: +String, stopAnimation: +Boolean)"
        },
        "name": {
          "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
          "!type": "+String"
        },
        "reset": {
          "!doc": "Resets the Game Object.\n\nThis moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`, \n`visible` and `renderable` to true.\n\nIf this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.\n\nIf this Game Object has a Physics Body it will reset the Body.",
          "!type": "fn(x: +Number, y: +Number, health: +Number) -> +PIXI.DisplayObject"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "preUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn()"
        },
        "crop": {
          "!doc": "Crop allows you to crop the texture being used to display this Game Object.\nSetting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.\n\nCropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,\nor by modifying `cropRect` property directly and then calling `updateCrop`.\n\nThe rectangle object given to this method can be either a `Phaser.Rectangle` or any other object \nso long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.\n\nA reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`, \nin which case the values are duplicated to a local object.",
          "!type": "fn(rect: +Phaser.Rectangle, copy: +Boolean)"
        },
        "frame": {
          "!doc": "Gets or sets the current frame index of the texture being used to render this Game Object.\n\nTo change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,\nfor example: `player.frame = 4`.\n\nIf the frame index given doesn't exist it will revert to the first frame found in the texture.\n\nIf you are using a texture atlas then you should use the `frameName` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+Number"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "shader": {
          "!doc": "The shader that will be used to render the texture to the stage. Set to null to remove a current shader.",
          "!type": "+PIXI.AbstractFilter"
        },
        "cropRect": {
          "!doc": "The Rectangle used to crop the texture this Game Object uses.\nSet this property via `crop`. \nIf you modify this property directly you must call `updateCrop` in order to have the change take effect.",
          "!type": "+Phaser.Rectangle"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "components": {
          "!doc": "The components this Game Object has installed.",
          "!type": "+Object"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
          "!type": "+Boolean"
        },
        "update": {
          "!doc": "Override this method in your own custom objects to handle any update requirements.\nIt is called immediately after `preUpdate` and before `postUpdate`.\nRemember if this Game Object has any children you should call update on those too.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "tint": {
          "!doc": "The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.",
          "!type": "+Number"
        },
        "inputEnabled": {
          "!doc": "By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created\nfor this Game Object and it will then start to process click / touch events and more.\n\nYou can then access the Input Handler via `this.input`.\n\nNote that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.\n\nIf you set this property to false it will stop the Input Handler from processing any more input events.",
          "!type": "+Boolean"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "world": {
          "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
          "!type": "+Phaser.Point"
        },
        "top": {
          "!doc": "The y coordinate of the Game Object.\nThis is the same as `y - offsetY`.",
          "!type": "+Number"
        },
        "setFrame": {
          "!doc": "Sets the texture frame the Game Object uses for rendering.\n\nThis is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.",
          "!type": "fn(frame: +Phaser.Frame)"
        },
        "animations": {
          "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
          "!type": "+Phaser.AnimationManager"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        },
        "key": {
          "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
          "!type": "+String"
        },
        "debug": {
          "!doc": "A debug flag designed for use with `Game.enableStep`.",
          "!type": "+Boolean"
        },
        "frameName": {
          "!doc": "Gets or sets the current frame name of the texture being used to render this Game Object.\n\nTo change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use, \nfor example: `player.frameName = \"idle\"`.\n\nIf the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.\n\nIf you are using a sprite sheet then you should use the `frame` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+String"
        },
        "texture": {
          "!doc": "The texture that the sprite is using",
          "!type": "+Texture"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends this Game Object to the bottom of its parents display list.\nVisually this means it will render below all other children in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "destroyPhase": {
          "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
          "!type": "+Boolean"
        },
        "right": {
          "!doc": "The right coordinate of the Game Object.\nThis is the same as `x + width - offsetX`.",
          "!type": "+Number"
        },
        "kill": {
          "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "resetFrame": {
          "!doc": "Resets the texture frame dimensions that the Game Object uses for rendering.",
          "!type": "fn()"
        },
        "previousPosition": {
          "!doc": "The position the Game Object was located in the previous frame.",
          "!type": "+Phaser.Point"
        },
        "pendingDestroy": {
          "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
          "!type": "+Boolean"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.\n\nWarning: You cannot have a blend mode and a filter active on the same Sprite. Doing so will render the sprite invisible.",
          "!type": "+Number"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "anchor": {
          "!doc": "The anchor sets the origin point of the texture.\nThe default is 0,0 this means the texture's origin is the top left\nSetting than anchor to 0.5,0.5 means the textures origin is centered\nSetting the anchor to 1,1 would mean the textures origin points will be the bottom right corner",
          "!type": "+Phaser.Point"
        },
        "autoCull": {
          "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "exists": {
          "!doc": "Controls if this Game Object is processed by the core game loop.\nIf this Game Object has a physics body it also controls if its physics body is updated or not.\nWhen `exists` is set to `false` it will remove its physics body from the physics world if it has one.\nIt also toggles the `visible` property to false as well.\n\nSetting `exists` to true will add its physics body back in to the physics world, if it has one.\nIt will also set the `visible` property to `true`.",
          "!type": "+Boolean"
        },
        "z": {
          "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
          "!type": "+Number"
        },
        "fresh": {
          "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
          "!type": "+Boolean"
        }
      }
    },
    "Math": {
      "!doc": "A collection of useful mathematical functions.\n\nThese are normally accessed through `game.math`.",
      "PI2": "+Object",
      "!type": "fn()",
      "prototype": {
        "smoothstep": {
          "!doc": "Smoothstep function as detailed at http://en.wikipedia.org/wiki/Smoothstep",
          "!type": "fn(x: +float, min: +float, max: +float) -> +float"
        },
        "sinCosGenerator": {
          "!doc": "Generate a sine and cosine table simultaneously and extremely quickly.\nThe parameters allow you to specify the length, amplitude and frequency of the wave.\nThis generator is fast enough to be used in real-time.\nCode based on research by Franky of scene.at",
          "!type": "fn(length: +Number, sinAmplitude: +Number, cosAmplitude: +Number, frequency: +Number) -> +Object"
        },
        "sign": {
          "!doc": "A value representing the sign of the value: -1 for negative, +1 for positive, 0 if value is 0.\n\nThis works differently from `Math.sign` for values of NaN and -0, etc.",
          "!type": "fn(x: +Number) -> +Number"
        },
        "radToDeg": {
          "!doc": "Convert radians to degrees.",
          "!type": "fn(radians: +Number) -> +Number"
        },
        "snapToCeil": {
          "!doc": "Snap a value to nearest grid slice, using ceil.\n\nExample: if you have an interval gap of 5 and a position of 12... you will snap to 15.\nAs will 14 will snap to 15... but 16 will snap to 20.",
          "!type": "fn(input: +Number, gap: +Number, start: +Number) -> +Number"
        },
        "angleBetween": {
          "!doc": "Find the angle of a segment from (x1, y1) -> (x2, y2).",
          "!type": "fn(x1: +Number, y1: +Number, x2: +Number, y2: +Number) -> +Number"
        },
        "angleBetweenPointsY": {
          "!doc": "Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).",
          "!type": "fn(point1: +Phaser.Point, point2: +Phaser.Point) -> +Number"
        },
        "wrapAngle": {
          "!doc": "Keeps an angle value between -180 and +180; or -PI and PI if radians.",
          "!type": "fn(angle: +Number, radians: +Boolean) -> +Number"
        },
        "reverseAngle": {
          "!doc": "Reverses an angle.",
          "!type": "fn(angleRad: +Number) -> +Number"
        },
        "maxAdd": {
          "!doc": "Adds the given amount to the value, but never lets the value go over the specified maximum.",
          "!type": "fn(value: +Number, amount: +Number, max: +Number) -> +Number"
        },
        "snapToFloor": {
          "!doc": "Snap a value to nearest grid slice, using floor.\n\nExample: if you have an interval gap of 5 and a position of 12... you will snap to 10.\nAs will 14 snap to 10... but 16 will snap to 15.",
          "!type": "fn(input: +Number, gap: +Number, start: +Number) -> +Number"
        },
        "snapTo": {
          "!doc": "Snap a value to nearest grid slice, using rounding.\n\nExample: if you have an interval gap of 5 and a position of 12... you will snap to 10 whereas 14 will snap to 15.",
          "!type": "fn(input: +Number, gap: +Number, start: +Number) -> +Number"
        },
        "wrapValue": {
          "!doc": "Adds value to amount and ensures that the result always stays between 0 and max, by wrapping the value around.\n\nValues _must_ be positive integers, and are passed through Math.abs. See {@link Phaser.Math#wrap} for an alternative.",
          "!type": "fn(value: +Number, amount: +Number, max: +Number) -> +Number"
        },
        "clamp": {
          "!doc": "Force a value within the boundaries by clamping it to the range `min`, `max`.",
          "!type": "fn(v: +float, min: +float, max: +float) -> +Number"
        },
        "clampBottom": {
          "!doc": "Clamp `x` to the range `[a, Infinity)`.\nRoughly the same as `Math.max(x, a)`, except for NaN handling.",
          "!type": "fn(x: +Number, a: +Number) -> +Number"
        },
        "bernstein": {
          "!doc": "",
          "!type": "fn(n: +Number, i: +Number) -> +Number"
        },
        "fuzzyLessThan": {
          "!doc": "`a` is fuzzyLessThan `b` if it is less than b + epsilon.",
          "!type": "fn(a: +Number, b: +Number, epsilon: +Number) -> +Boolean"
        },
        "maxProperty": {
          "!doc": "Variation of Math.max that can be passed a property and either an array of objects or the objects as parameters.\nIt will find the largest matching property value from the given objects.",
          "!type": "fn() -> +Number"
        },
        "smootherstep": {
          "!doc": "Smootherstep function as detailed at http://en.wikipedia.org/wiki/Smoothstep",
          "!type": "fn(x: +float, min: +float, max: +float) -> +float"
        },
        "catmullRomInterpolation": {
          "!doc": "A Catmull Rom Interpolation Method, mostly used by Phaser.Tween.",
          "!type": "fn(v: +Array, k: +Number) -> +Number"
        },
        "normalizeAngle": {
          "!doc": "Normalizes an angle to the [0,2pi) range.",
          "!type": "fn(angleRad: +Number) -> +Number"
        },
        "difference": {
          "!doc": "The (absolute) difference between two values.",
          "!type": "fn(a: +Number, b: +Number) -> +Number"
        },
        "fuzzyFloor": {
          "!doc": "Applies a fuzzy floor to the given value.",
          "!type": "fn(val: +Number, epsilon: +Number) -> +Number"
        },
        "roundTo": {
          "!doc": "Round to some place comparative to a `base`, default is 10 for decimal place.\nThe `place` is represented by the power applied to `base` to get that place.\n\n    e.g. 2000/7 ~= 285.714285714285714285714 ~= (bin)100011101.1011011011011011\n\n    roundTo(2000/7,3) === 0\n    roundTo(2000/7,2) == 300\n    roundTo(2000/7,1) == 290\n    roundTo(2000/7,0) == 286\n    roundTo(2000/7,-1) == 285.7\n    roundTo(2000/7,-2) == 285.71\n    roundTo(2000/7,-3) == 285.714\n    roundTo(2000/7,-4) == 285.7143\n    roundTo(2000/7,-5) == 285.71429\n\n    roundTo(2000/7,3,2)  == 288       -- 100100000\n    roundTo(2000/7,2,2)  == 284       -- 100011100\n    roundTo(2000/7,1,2)  == 286       -- 100011110\n    roundTo(2000/7,0,2)  == 286       -- 100011110\n    roundTo(2000/7,-1,2) == 285.5     -- 100011101.1\n    roundTo(2000/7,-2,2) == 285.75    -- 100011101.11\n    roundTo(2000/7,-3,2) == 285.75    -- 100011101.11\n    roundTo(2000/7,-4,2) == 285.6875  -- 100011101.1011\n    roundTo(2000/7,-5,2) == 285.71875 -- 100011101.10111\n\nNote what occurs when we round to the 3rd space (8ths place), 100100000, this is to be assumed\nbecause we are rounding 100011.1011011011011011 which rounds up.",
          "!type": "fn(value: +Number, place: +Number, base: +Number) -> +Number"
        },
        "average": {
          "!doc": "Averages all values passed to the function and returns the result.",
          "!type": "fn() -> +Number"
        },
        "roundAwayFromZero": {
          "!doc": "Round to the next whole number _away_ from zero.",
          "!type": "fn(value: +Number) -> +Number"
        },
        "distance": {
          "!doc": "Returns the euclidian distance between the two given set of coordinates.",
          "!type": "fn(x1: +Number, y1: +Number, x2: +Number, y2: +Number) -> +Number"
        },
        "angleBetweenPoints": {
          "!doc": "Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).",
          "!type": "fn(point1: +Phaser.Point, point2: +Phaser.Point) -> +Number"
        },
        "isEven": {
          "!doc": "Returns true if the number given is even.",
          "!type": "fn(n: +Number) -> +Boolean"
        },
        "fuzzyEqual": {
          "!doc": "Two number are fuzzyEqual if their difference is less than epsilon.",
          "!type": "fn(a: +Number, b: +Number, epsilon: +Number) -> +Boolean"
        },
        "factorial": {
          "!doc": "",
          "!type": "fn(value: +Number) -> +Number"
        },
        "minProperty": {
          "!doc": "Variation of Math.min that can be passed a property and either an array of objects or the objects as parameters.\nIt will find the lowest matching property value from the given objects.",
          "!type": "fn() -> +Number"
        },
        "distanceSq": {
          "!doc": "Returns the euclidean distance squared between the two given set of\ncoordinates (cuts out a square root operation before returning).",
          "!type": "fn(x1: +Number, y1: +Number, x2: +Number, y2: +Number) -> +Number"
        },
        "percent": {
          "!doc": "Work out what percentage value `a` is of value `b` using the given base.",
          "!type": "fn(a: +Number, b: +Number, base: +Number) -> +Number"
        },
        "angleBetweenY": {
          "!doc": "Find the angle of a segment from (x1, y1) -> (x2, y2).\nNote that the difference between this method and Math.angleBetween is that this assumes the y coordinate travels\ndown the screen.",
          "!type": "fn(x1: +Number, y1: +Number, x2: +Number, y2: +Number) -> +Number"
        },
        "ceilTo": {
          "!doc": "",
          "!type": "fn(value: +Number, place: +Number, base: +Number) -> +Number"
        },
        "min": {
          "!doc": "Variation of Math.min that can be passed either an array of numbers or the numbers as parameters.\n\nPrefer the standard `Math.min` function when appropriate.",
          "!type": "fn() -> +Number"
        },
        "degToRad": {
          "!doc": "Convert degrees to radians.",
          "!type": "fn(degrees: +Number) -> +Number"
        },
        "isOdd": {
          "!doc": "Returns true if the number given is odd.",
          "!type": "fn(n: +Number) -> +Boolean"
        },
        "catmullRom": {
          "!doc": "Calculates a catmum rom value.",
          "!type": "fn(p0: +Number, p1: +Number, p2: +Number, p3: +Number, t: +Number) -> +Number"
        },
        "fuzzyGreaterThan": {
          "!doc": "`a` is fuzzyGreaterThan `b` if it is more than b - epsilon.",
          "!type": "fn(a: +Number, b: +Number, epsilon: +Number) -> +Boolean"
        },
        "bezierInterpolation": {
          "!doc": "A Bezier Interpolation Method, mostly used by Phaser.Tween.",
          "!type": "fn(v: +Array, k: +Number) -> +Number"
        },
        "linearInterpolation": {
          "!doc": "A Linear Interpolation Method, mostly used by Phaser.Tween.",
          "!type": "fn(v: +Array, k: +Number) -> +Number"
        },
        "linear": {
          "!doc": "Calculates a linear (interpolation) value over t.",
          "!type": "fn(p0: +Number, p1: +Number, t: +Number) -> +Number"
        },
        "shear": {
          "!doc": "",
          "!type": "fn(n: +Number) -> +Number"
        },
        "max": {
          "!doc": "Variation of Math.max that can be passed either an array of numbers or the numbers as parameters.\n\nPrefer the standard `Math.max` function when appropriate.",
          "!type": "fn() -> +Number"
        },
        "within": {
          "!doc": "Checks if two values are within the given tolerance of each other.",
          "!type": "fn(a: +Number, b: +Number, tolerance: +Number) -> +Boolean"
        },
        "distancePow": {
          "!doc": "Returns the distance between the two given set of coordinates at the power given.",
          "!type": "fn(x1: +Number, y1: +Number, x2: +Number, y2: +Number, pow: +Number) -> +Number"
        },
        "floorTo": {
          "!doc": "",
          "!type": "fn(value: +Number, place: +Number, base: +Number) -> +Number"
        },
        "fuzzyCeil": {
          "!doc": "Applies a fuzzy ceil to the given value.",
          "!type": "fn(val: +Number, epsilon: +Number) -> +Number"
        },
        "minSub": {
          "!doc": "Subtracts the given amount from the value, but never lets the value go below the specified minimum.",
          "!type": "fn(value: +Number, amount: +Number, min: +Number) -> +Number"
        },
        "mapLinear": {
          "!doc": "Linear mapping from range <a1, a2> to range <b1, b2>",
          "!type": "fn(x: +Number, a1: +Number, a2: +Number, b1: +Number, b2: +Number) -> +Number"
        },
        "wrap": {
          "!doc": "Ensures that the value always stays between min and max, by wrapping the value around.\n\nIf `max` is not larger than `min` the result is 0.",
          "!type": "fn(value: +Number, min: +Number, max: +Number) -> +Number"
        }
      }
    },
    "Tileset": {
      "!doc": "A Tile set is a combination of an image containing the tiles and collision data per tile.\n\nTilesets are normally created automatically when Tiled data is loaded.",
      "!type": "fn(name: +String, firstgid: +Number, width: +Number, height: +Number, margin: +Number, spacing: +Number, properties: +Object)",
      "prototype": {
        "image": {
          "!doc": "The cached image that contains the individual tiles. Use {@link Phaser.Tileset.setImage setImage} to set.",
          "!type": "+Object"
        },
        "columns": {
          "!doc": "The number of tile columns in the tileset.",
          "!type": "+Number"
        },
        "tileSpacing": {
          "!doc": "The spacing between each tile in the sheet (in pixels).\nUse `setSpacing` to change.",
          "!type": "+Number"
        },
        "draw": {
          "!doc": "Draws a tile from this Tileset at the given coordinates on the context.",
          "!type": "fn(context: +CanvasRenderingContext2D, x: +Number, y: +Number, index: +Number)"
        },
        "firstgid": {
          "!doc": "The Tiled firstgid value.\nThis is the starting index of the first tile index this Tileset contains.",
          "!type": "+Number"
        },
        "tileWidth": {
          "!doc": "The width of each tile (in pixels).",
          "!type": "+Number"
        },
        "rows": {
          "!doc": "The number of tile rows in the the tileset.",
          "!type": "+Number"
        },
        "tileMarge": {
          "!doc": "The margin around the tiles in the sheet (in pixels).\nUse `setSpacing` to change.",
          "!type": "+Number"
        },
        "setSpacing": {
          "!doc": "Sets tile spacing and margins.",
          "!type": "fn(margin: +Number, spacing: +Number)"
        },
        "total": {
          "!doc": "The total number of tiles in the tileset.",
          "!type": "+Number"
        },
        "name": {
          "!doc": "The name of the Tileset.",
          "!type": "+String"
        },
        "containsTileIndex": {
          "!doc": "Returns true if and only if this tileset contains the given tile index.",
          "!type": "fn() -> +Boolean"
        },
        "properties": {
          "!doc": "Tileset-specific properties that are typically defined in the Tiled editor.",
          "!type": "+Object"
        },
        "setImage": {
          "!doc": "Set the image associated with this Tileset and update the tile data.",
          "!type": "fn(image: +Image)"
        },
        "tileHeight": {
          "!doc": "The height of each tile (in pixels).",
          "!type": "+Number"
        }
      }
    },
    "SoundManager": {
      "!doc": "The Sound Manager is responsible for playing back audio via either the Legacy HTML Audio tag or via Web Audio if the browser supports it.\nNote: On Firefox 25+ on Linux if you have media.gstreamer disabled in about:config then it cannot play back mp3 or m4a files.\nThe audio file type and the encoding of those files are extremely important. Not all browsers can play all audio formats.\nThere is a good guide to what's supported here: http://hpr.dogphilosophy.net/test/\n\nIf you are reloading a Phaser Game on a page that never properly refreshes (such as in an AngularJS project) then you will quickly run out\nof AudioContext nodes. If this is the case create a global var called PhaserGlobal on the window object before creating the game. The active\nAudioContext will then be saved to window.PhaserGlobal.audioContext when the Phaser game is destroyed, and re-used when it starts again.\n\nMobile warning: There are some mobile devices (certain iPad 2 and iPad Mini revisions) that cannot play 48000 Hz audio.\nWhen they try to play the audio becomes extremely distorted and buzzes, eventually crashing the sound system.\nThe solution is to use a lower encoding rate such as 44100 Hz. Sometimes the audio context will\nbe created with a sampleRate of 48000. If this happens and audio distorts you should re-create the context.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "play": {
          "!doc": "Adds a new Sound into the SoundManager and starts it playing.",
          "!type": "fn(key: +String, volume: +Number, loop: +Boolean) -> +Phaser.Sound"
        },
        "game": {
          "!doc": "Local reference to game.",
          "!type": "+Phaser.Game"
        },
        "onMute": {
          "!doc": "This signal is dispatched when the SoundManager is globally muted, either directly via game code or as a result of the game pausing.",
          "!type": "+Phaser.Signal"
        },
        "update": {
          "!doc": "Updates every sound in the game, checks for audio unlock on mobile and monitors the decoding watch list.",
          "!type": "fn()"
        },
        "decode": {
          "!doc": "Decode a sound by its asset key.",
          "!type": "fn(key: +String, sound: +Phaser.Sound)"
        },
        "removeByKey": {
          "!doc": "Removes all Sounds from the SoundManager that have an asset key matching the given value.\nThe removed Sounds are destroyed before removal.",
          "!type": "fn(key: +String) -> +Number"
        },
        "remove": {
          "!doc": "Removes a Sound from the SoundManager. The removed Sound is destroyed before removal.",
          "!type": "fn(sound: +Phaser.Sound) -> +Boolean"
        },
        "stopAll": {
          "!doc": "Stops all the sounds in the game.",
          "!type": "fn()"
        },
        "usingAudioTag": {
          "!doc": "True the SoundManager and device are both using the Audio tag instead of Web Audio.",
          "!type": "+Boolean"
        },
        "addSprite": {
          "!doc": "Adds a new AudioSprite into the SoundManager.",
          "!type": "fn(key: +String) -> +Phaser.AudioSprite"
        },
        "context": {
          "!doc": "The AudioContext being used for playback.",
          "!type": "+AudioContext"
        },
        "setDecodedCallback": {
          "!doc": "This method allows you to give the SoundManager a list of Sound files, or keys, and a callback.\nOnce all of the Sound files have finished decoding the callback will be invoked.\nThe amount of time spent decoding depends on the codec used and file size.\nIf all of the files given have already decoded the callback is triggered immediately.",
          "!type": "fn(files: +String, callback: +Function, callbackContext: +Object)"
        },
        "boot": {
          "!doc": "Initialises the sound manager.",
          "!type": "fn()"
        },
        "muteOnPause": {
          "!doc": "Set to true to have all sound muted when the Phaser game pauses (such as on loss of focus),\nor set to false to keep audio playing, regardless of the game pause state. You may need to\ndo this should you wish to control audio muting via external DOM buttons or similar.",
          "!type": "+Boolean"
        },
        "onSoundDecode": {
          "!doc": "The event dispatched when a sound decodes (typically only for mp3 files)",
          "!type": "+Phaser.Signal"
        },
        "onUnMute": {
          "!doc": "This signal is dispatched when the SoundManager is globally un-muted, either directly via game code or as a result of the game resuming from a pause.",
          "!type": "+Phaser.Signal"
        },
        "add": {
          "!doc": "Adds a new Sound into the SoundManager.",
          "!type": "fn(key: +String, volume: +Number, loop: +Boolean, connect: +Boolean) -> +Phaser.Sound"
        },
        "pauseAll": {
          "!doc": "Pauses all the sounds in the game.",
          "!type": "fn()"
        },
        "unlock": {
          "!doc": "Enables the audio, usually after the first touch.",
          "!type": "fn() -> +Boolean"
        },
        "setTouchLock": {
          "!doc": "Sets the Input Manager touch callback to be SoundManager.unlock.\nRequired for iOS audio device unlocking. Mostly just used internally.",
          "!type": "fn()"
        },
        "resumeAll": {
          "!doc": "Resumes every sound in the game.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Stops all the sounds in the game, then destroys them and finally clears up any callbacks.",
          "!type": "fn()"
        },
        "mute": {
          "!doc": "Gets or sets the muted state of the SoundManager. This effects all sounds in the game.",
          "!type": "+Boolean"
        },
        "onVolumeChange": {
          "!doc": "This signal is dispatched whenever the global volume changes. The new volume is passed as the only parameter to your callback.",
          "!type": "+Phaser.Signal"
        },
        "volume": {
          "!doc": "Gets or sets the global volume of the SoundManager, a value between 0 and 1. The value given is clamped to the range 0 to 1.",
          "!type": "+Number"
        },
        "usingWebAudio": {
          "!doc": "True the SoundManager and device are both using Web Audio.",
          "!type": "+Boolean"
        },
        "channels": {
          "!doc": "The number of audio channels to use in playback.",
          "!type": "+Number"
        },
        "connectToMaster": {
          "!doc": "Used in conjunction with Sound.externalNode this allows you to stop a Sound node being connected to the SoundManager master gain node.",
          "!type": "+Boolean"
        },
        "noAudio": {
          "!doc": "True if audio been disabled via the PhaserGlobal (useful if you need to use a 3rd party audio library) or the device doesn't support any audio.",
          "!type": "+Boolean"
        },
        "touchLocked": {
          "!doc": "true if the audio system is currently locked awaiting a touch event.",
          "!type": "+Boolean"
        }
      }
    },
    "Particle": {
      "init": {
        "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
        "!type": "fn()"
      },
      "install": {
        "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
        "!type": "fn()"
      },
      "!doc": "Create a new `Particle` object. Particles are extended Sprites that are emitted by a particle emitter such as Phaser.Particles.Arcade.Emitter.",
      "!type": "fn(game: +Phaser.Game, x: +Number, y: +Number, key: +String, frame: +String)",
      "prototype": {
        "play": {
          "!doc": "Plays an Animation.\n\nThe animation should have previously been created via `animations.add`.\n\nIf the animation is already playing calling this again won't do anything.\nIf you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.",
          "!type": "fn(name: +String, frameRate: +Number, loop: +Boolean, killOnComplete: +Boolean) -> +Phaser.Animation"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "lifespan": {
          "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
          "!type": "+Number"
        },
        "outOfBoundsKill": {
          "!doc": "If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.",
          "!type": "+Boolean"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "resizeFrame": {
          "!doc": "Resizes the Frame dimensions that the Game Object uses for rendering.\n\nYou shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData\nit can be useful to adjust the dimensions directly in this way.",
          "!type": "fn(parent: +Object, width: +Number, height: +Number)"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "setScaleData": {
          "!doc": "Called by the Emitter if autoScale has been enabled. Passes over the scale ease data and resets the scale counter.",
          "!type": "fn()"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "maxHealth": {
          "!doc": "The Game Objects maximum health value. This works in combination with the `heal` method to ensure\nthe health value never exceeds the maximum.",
          "!type": "+Number"
        },
        "revive": {
          "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
          "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
        },
        "scaleData": {
          "!doc": "A reference to the scaleData array owned by the Emitter that emitted this Particle.",
          "!type": "+Array"
        },
        "bringToTop": {
          "!doc": "Brings this Game Object to the top of its parents display list.\nVisually this means it will render over the top of any old child in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "events": {
          "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
          "!type": "+Phaser.Events"
        },
        "moveUp": {
          "!doc": "Moves this Game Object up one place in its parents display list.\nThis call has no effect if the Game Object is already at the top of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "postUpdate": {
          "!doc": "Internal method called by the World postUpdate cycle.",
          "!type": "fn()"
        },
        "smoothed": {
          "!doc": "Enable or disable texture smoothing for this Game Object.\n\nIt only takes effect if the Game Object is using an image based texture.\n\nSmoothing is enabled by default.",
          "!type": "+Boolean"
        },
        "destroy": {
          "!doc": "Destroys the Game Object. This removes it from its parent group, destroys the input, event and animation handlers if present\nand nulls its reference to `game`, freeing it up for garbage collection.\n\nIf this Game Object has the Events component it will also dispatch the `onDestroy` event.\n\nYou can optionally also destroy the BaseTexture this Game Object is using. Be careful if you've\nmore than one Game Object sharing the same BaseTexture.",
          "!type": "fn(destroyChildren: +Boolean, destroyTexture: +Boolean)"
        },
        "input": {
          "!doc": "The Input Handler for this Game Object.\n\nBy default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.\n\nAfter you have done this, this property will be a reference to the Phaser InputHandler.",
          "!type": "+Phaser.InputHandler"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "left": {
          "!doc": "The left coordinate of the Game Object.\nThis is the same as `x - offsetX`.",
          "!type": "+Number"
        },
        "reset": {
          "!doc": "Resets the Particle. This places the Particle at the given x/y world coordinates and then\nsets alive, exists, visible and renderable all to true. Also resets the outOfBounds state and health values.\nIf the Particle has a physics body that too is reset.",
          "!type": "fn(x: +Number, y: +Number, health: +Number) -> +Phaser.Particle"
        },
        "preUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn() -> +Boolean"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "damage": {
          "!doc": "Damages the Game Object. This removes the given amount of health from the `health` property.\n\nIf health is taken below or is equal to zero then the `kill` method is called.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "components": {
          "!doc": "The components this Game Object has installed.",
          "!type": "+Object"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
          "!type": "+Boolean"
        },
        "transformCallback": {
          "!doc": "The callback that will apply any scale limiting to the worldTransform.",
          "!type": "+Function"
        },
        "inWorld": {
          "!doc": "Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.",
          "!type": "+Boolean"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "world": {
          "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
          "!type": "+Phaser.Point"
        },
        "top": {
          "!doc": "The y coordinate of the Game Object.\nThis is the same as `y - offsetY`.",
          "!type": "+Number"
        },
        "angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        },
        "setScaleMinMax": {
          "!doc": "Sets the scaleMin and scaleMax values. These values are used to limit how far this Game Object will scale based on its parent.\n\nFor example if this Game Object has a `minScale` value of 1 and its parent has a `scale` value of 0.5, the 0.5 will be ignored \nand the scale value of 1 will be used, as the parents scale is lower than the minimum scale this Game Object should adhere to.\n\nBy setting these values you can carefully control how Game Objects deal with responsive scaling.\n\nIf only one parameter is given then that value will be used for both scaleMin and scaleMax:\n`setScaleMinMax(1)` = scaleMin.x, scaleMin.y, scaleMax.x and scaleMax.y all = 1\n\nIf only two parameters are given the first is set as scaleMin.x and y and the second as scaleMax.x and y:\n`setScaleMinMax(0.5, 2)` = scaleMin.x and y = 0.5 and scaleMax.x and y = 2\n\nIf you wish to set `scaleMin` with different values for x and y then either modify Game Object.scaleMin directly, \nor pass `null` for the `maxX` and `maxY` parameters.\n\nCall `setScaleMinMax(null)` to clear all previously set values.",
          "!type": "fn(minX: +Number, minY: +Number, maxX: +Number, maxY: +Number)"
        },
        "checkWorldBounds": {
          "!doc": "If this is set to `true` the Game Object checks if it is within the World bounds each frame. \n\nWhen it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.\n\nIf it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.\n\nIt also optionally kills the Game Object if `outOfBoundsKill` is `true`.\n\nWhen `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "key": {
          "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
          "!type": "+String"
        },
        "texture": {
          "!doc": "The texture that the sprite is using",
          "!type": "+Texture"
        },
        "health": {
          "!doc": "The Game Objects health value. This is a handy property for setting and manipulating health on a Game Object.\n\nIt can be used in combination with the `damage` method or modified directly.",
          "!type": "+Number"
        },
        "outOfCameraBoundsKill": {
          "!doc": "If this and the `autoCull` property are both set to `true`, then the `kill` method\nis called as soon as the Game Object leaves the camera bounds.",
          "!type": "+Boolean"
        },
        "destroyPhase": {
          "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
          "!type": "+Boolean"
        },
        "right": {
          "!doc": "The right coordinate of the Game Object.\nThis is the same as `x + width - offsetX`.",
          "!type": "+Number"
        },
        "kill": {
          "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousPosition": {
          "!doc": "The position the Game Object was located in the previous frame.",
          "!type": "+Phaser.Point"
        },
        "scaleMax": {
          "!doc": "The maximum scale this Game Object will scale up to. \n\nIt allows you to prevent a parent from scaling this Game Object higher than the given value.\n\nSet it to `null` to remove the limit.",
          "!type": "+Phaser.Point"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "anchor": {
          "!doc": "The anchor sets the origin point of the texture.\nThe default is 0,0 this means the texture's origin is the top left\nSetting than anchor to 0.5,0.5 means the textures origin is centered\nSetting the anchor to 1,1 would mean the textures origin points will be the bottom right corner",
          "!type": "+Phaser.Point"
        },
        "autoCull": {
          "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The position of the Game Object on the x axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "Controls if this Game Object is processed by the core game loop.\nIf this Game Object has a physics body it also controls if its physics body is updated or not.\nWhen `exists` is set to `false` it will remove its physics body from the physics world if it has one.\nIt also toggles the `visible` property to false as well.\n\nSetting `exists` to true will add its physics body back in to the physics world, if it has one.\nIt will also set the `visible` property to `true`.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The position of the Game Object on the y axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
          "!type": "+Number"
        },
        "scaleMin": {
          "!doc": "The minimum scale this Game Object will scale down to.\n\nIt allows you to prevent a parent from scaling this Game Object lower than the given value.\n\nSet it to `null` to remove the limit.",
          "!type": "+Phaser.Point"
        },
        "body": {
          "!doc": "`body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated \nproperties and methods via it.\n\nBy default Game Objects won't add themselves to any physics system and their `body` property will be `null`.\n\nTo enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object\nand `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.\n\nYou can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.\n\nImportant: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5, \nso the physics body is centered on the Game Object.\n\nIf you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.",
          "!type": "+Phaser.Physics.Arcade.Body"
        },
        "inCamera": {
          "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
          "!type": "+Boolean"
        },
        "autoScale": {
          "!doc": "If this Particle automatically scales this is set to true by Particle.setScaleData.",
          "!type": "+Boolean"
        },
        "offsetX": {
          "!doc": "The amount the Game Object is visually offset from its x coordinate.\nThis is the same as `width * anchor.x`.\nIt will only be > 0 if anchor.x is not equal to zero.",
          "!type": "+Number"
        },
        "tintedTexture": {
          "!doc": "A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)",
          "!type": "+Phaser.Canvas"
        },
        "offsetY": {
          "!doc": "The amount the Game Object is visually offset from its y coordinate.\nThis is the same as `height * anchor.y`.\nIt will only be > 0 if anchor.y is not equal to zero.",
          "!type": "+Number"
        },
        "fixedToCamera": {
          "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
          "!type": "+Boolean"
        },
        "renderOrderID": {
          "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
          "!type": "+Number"
        },
        "previousRotation": {
          "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
          "!type": "+Number"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.\nThis is the same as `y + height - offsetY`.",
          "!type": "+Number"
        },
        "cameraOffset": {
          "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
          "!type": "+Phaser.Point"
        },
        "moveDown": {
          "!doc": "Moves this Game Object down one place in its parents display list.\nThis call has no effect if the Game Object is already at the bottom of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "updateCrop": {
          "!doc": "If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,\nor the rectangle it references, then you need to update the crop frame by calling this method.",
          "!type": "fn()"
        },
        "setAlphaData": {
          "!doc": "Called by the Emitter if autoAlpha has been enabled. Passes over the alpha ease data and resets the alpha counter.",
          "!type": "fn()"
        },
        "overlap": {
          "!doc": "Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object, \nwhich can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.\n\nThis check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.\n\nTherefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.\nIt should be fine for low-volume testing where physics isn't required.",
          "!type": "fn(displayObject: +Phaser.Sprite) -> +Boolean"
        },
        "autoAlpha": {
          "!doc": "If this Particle automatically changes alpha this is set to true by Particle.setAlphaData.",
          "!type": "+Boolean"
        },
        "loadTexture": {
          "!doc": "Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.\n\nIf your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.\n\nYou should only use `loadTexture` if you want to replace the base texture entirely.\n\nCalling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.\n\nYou can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite. \nDoing this then sets the key to be the `frame` argument (the frame is set to zero). \n\nThis allows you to create sprites using `load.image` during development, and then change them \nto use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS' \nand swapping it to be the key of the atlas data.\n\nNote: You cannot use a RenderTexture as a texture for a TileSprite.",
          "!type": "fn(key: +String, frame: +String, stopAnimation: +Boolean)"
        },
        "name": {
          "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
          "!type": "+String"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "crop": {
          "!doc": "Crop allows you to crop the texture being used to display this Game Object.\nSetting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.\n\nCropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,\nor by modifying `cropRect` property directly and then calling `updateCrop`.\n\nThe rectangle object given to this method can be either a `Phaser.Rectangle` or any other object \nso long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.\n\nA reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`, \nin which case the values are duplicated to a local object.",
          "!type": "fn(rect: +Phaser.Rectangle, copy: +Boolean)"
        },
        "alphaData": {
          "!doc": "A reference to the alphaData array owned by the Emitter that emitted this Particle.",
          "!type": "+Array"
        },
        "frame": {
          "!doc": "Gets or sets the current frame index of the texture being used to render this Game Object.\n\nTo change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,\nfor example: `player.frame = 4`.\n\nIf the frame index given doesn't exist it will revert to the first frame found in the texture.\n\nIf you are using a texture atlas then you should use the `frameName` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+Number"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "shader": {
          "!doc": "The shader that will be used to render the texture to the stage. Set to null to remove a current shader.",
          "!type": "+PIXI.AbstractFilter"
        },
        "cropRect": {
          "!doc": "The Rectangle used to crop the texture this Game Object uses.\nSet this property via `crop`. \nIf you modify this property directly you must call `updateCrop` in order to have the change take effect.",
          "!type": "+Phaser.Rectangle"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "deltaZ": {
          "!doc": "The delta value.",
          "!type": "+Number"
        },
        "transformCallbackContext": {
          "!doc": "The context under which `transformCallback` is called.",
          "!type": "+Object"
        },
        "deltaX": {
          "!doc": "Returns the delta x value. The difference between world.x now and in the previous frame.\n\nThe value will be positive if the Game Object has moved to the right or negative if to the left.",
          "!type": "+Number"
        },
        "deltaY": {
          "!doc": "Returns the delta y value. The difference between world.y now and in the previous frame.\n\nThe value will be positive if the Game Object has moved down or negative if up.",
          "!type": "+Number"
        },
        "update": {
          "!doc": "Updates the Particle scale or alpha if autoScale and autoAlpha are set.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "onEmit": {
          "!doc": "Called by the Emitter when this particle is emitted. Left empty for you to over-ride as required.",
          "!type": "fn()"
        },
        "tint": {
          "!doc": "The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.",
          "!type": "+Number"
        },
        "inputEnabled": {
          "!doc": "By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created\nfor this Game Object and it will then start to process click / touch events and more.\n\nYou can then access the Input Handler via `this.input`.\n\nNote that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.\n\nIf you set this property to false it will stop the Input Handler from processing any more input events.",
          "!type": "+Boolean"
        },
        "setFrame": {
          "!doc": "Sets the texture frame the Game Object uses for rendering.\n\nThis is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.",
          "!type": "fn(frame: +Phaser.Frame)"
        },
        "animations": {
          "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
          "!type": "+Phaser.AnimationManager"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "heal": {
          "!doc": "Heal the Game Object. This adds the given amount of health to the `health` property.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "setHealth": {
          "!doc": "Sets the health property of the Game Object to the given amount.\nWill never exceed the `maxHealth` value.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "debug": {
          "!doc": "A debug flag designed for use with `Game.enableStep`.",
          "!type": "+Boolean"
        },
        "frameName": {
          "!doc": "Gets or sets the current frame name of the texture being used to render this Game Object.\n\nTo change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use, \nfor example: `player.frameName = \"idle\"`.\n\nIf the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.\n\nIf you are using a sprite sheet then you should use the `frame` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+String"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends this Game Object to the bottom of its parents display list.\nVisually this means it will render below all other children in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "resetFrame": {
          "!doc": "Resets the texture frame dimensions that the Game Object uses for rendering.",
          "!type": "fn()"
        },
        "pendingDestroy": {
          "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
          "!type": "+Boolean"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.\n\nWarning: You cannot have a blend mode and a filter active on the same Sprite. Doing so will render the sprite invisible.",
          "!type": "+Number"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "fresh": {
          "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
          "!type": "+Boolean"
        }
      }
    },
    "PluginManager": {
      "!doc": "The Plugin Manager is responsible for the loading, running and unloading of Phaser Plugins.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "add": {
          "!doc": "Add a new Plugin into the PluginManager.\nThe Plugin must have 2 properties: game and parent. Plugin.game is set to the game reference the PluginManager uses, and parent is set to the PluginManager.",
          "!type": "fn(plugin: +Object, parameter: +any) -> +Phaser.Plugin"
        },
        "postRender": {
          "!doc": "Post-render is called after the Game Renderer and State.render have run.\nIt only calls plugins who have visible=true.",
          "!type": "fn()"
        },
        "removeAll": {
          "!doc": "Remove all Plugins from the PluginManager. It calls Plugin.destroy on every plugin before removing it from the manager.",
          "!type": "fn()"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "postUpdate": {
          "!doc": "PostUpdate is the last thing to be called before the world render.\nIn particular, it is called after the world postUpdate, which means the camera has been adjusted.\nIt only calls plugins who have active=true.",
          "!type": "fn()"
        },
        "plugins": {
          "!doc": "An array of all the plugins being managed by this PluginManager.",
          "!type": "+Array._Phaser.Plugin_"
        },
        "update": {
          "!doc": "Update is called after all the core subsystems (Input, Tweens, Sound, etc) and the State have updated, but before the render.\nIt only calls plugins who have active=true.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Clear down this PluginManager, calls destroy on every plugin and nulls out references.",
          "!type": "fn()"
        },
        "preUpdate": {
          "!doc": "Pre-update is called at the very start of the update cycle, before any other subsystems have been updated (including Physics).\nIt only calls plugins who have active=true.",
          "!type": "fn()"
        },
        "render": {
          "!doc": "Render is called right after the Game Renderer completes, but before the State.render.\nIt only calls plugins who have visible=true.",
          "!type": "fn()"
        },
        "remove": {
          "!doc": "Remove a Plugin from the PluginManager. It calls Plugin.destroy on the plugin before removing it from the manager.",
          "!type": "fn(plugin: +Phaser.Plugin)"
        }
      }
    },
    "CANVAS_FILTER": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Matrix": {
      "!doc": "The Matrix is a 3x3 matrix mostly used for display transforms within the renderer.\n\nIt is represented like so:\n\n| a | b | tx |\n| c | d | ty |\n| 0 | 0 | 1 |",
      "!type": "fn(a: +Number, b: +Number, c: +Number, d: +Number, tx: +Number, ty: +Number)",
      "prototype": {
        "rotate": {
          "!doc": "Applies a rotation transformation to this matrix.",
          "!type": "fn(angle: +Number) -> +Phaser.Matrix"
        },
        "a": {
          "!doc": "",
          "!type": "+Number"
        },
        "b": {
          "!doc": "",
          "!type": "+Number"
        },
        "c": {
          "!doc": "",
          "!type": "+Number"
        },
        "d": {
          "!doc": "",
          "!type": "+Number"
        },
        "tx": {
          "!doc": "",
          "!type": "+Number"
        },
        "apply": {
          "!doc": "Get a new position with the current transformation applied.\n\nCan be used to go from a childs coordinate space to the world coordinate space (e.g. rendering)",
          "!type": "fn(pos: +Phaser.Point, newPos: +Phaser.Point) -> +Phaser.Point"
        },
        "ty": {
          "!doc": "",
          "!type": "+Number"
        },
        "fromArray": {
          "!doc": "Sets the values of this Matrix to the values in the given array.\n\nThe Array elements should be set as follows:\n\na = array[0]\nb = array[1]\nc = array[3]\nd = array[4]\ntx = array[2]\nty = array[5]",
          "!type": "fn(array: +Array) -> +Phaser.Matrix"
        },
        "scale": {
          "!doc": "Applies a scale transformation to this matrix.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Matrix"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "copyFrom": {
          "!doc": "Copies the properties from the given Matrix into this Matrix.",
          "!type": "fn(matrix: +Phaser.Matrix) -> +Phaser.Matrix"
        },
        "translate": {
          "!doc": "Translates the matrix on the x and y.\nThis is the same as Matrix.tx += x.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Matrix"
        },
        "copyTo": {
          "!doc": "Copies the properties from this Matrix to the given Matrix.",
          "!type": "fn(matrix: +Phaser.Matrix) -> +Phaser.Matrix"
        },
        "applyInverse": {
          "!doc": "Get a new position with the inverse of the current transformation applied.\n\nCan be used to go from the world coordinate space to a childs coordinate space. (e.g. input)",
          "!type": "fn(pos: +Phaser.Point, newPos: +Phaser.Point) -> +Phaser.Point"
        },
        "identity": {
          "!doc": "Resets this Matrix to an identity (default) matrix.",
          "!type": "fn() -> +Phaser.Matrix"
        },
        "clone": {
          "!doc": "Creates a new Matrix object based on the values of this Matrix.\nIf you provide the output parameter the values of this Matrix will be copied over to it.\nIf the output parameter is blank a new Matrix object will be created.",
          "!type": "fn(output: +Phaser.Matrix) -> +Phaser.Matrix"
        },
        "toArray": {
          "!doc": "Creates a Float32 Array with values populated from this Matrix object.",
          "!type": "fn(transpose: +Boolean, array: +PIXI.Float32Array) -> +PIXI.Float32Array"
        },
        "setTo": {
          "!doc": "Sets the values of this Matrix to the given values.",
          "!type": "fn(a: +Number, b: +Number, c: +Number, d: +Number, tx: +Number, ty: +Number) -> +Phaser.Matrix"
        },
        "append": {
          "!doc": "Appends the given Matrix to this Matrix.",
          "!type": "fn(matrix: +Phaser.Matrix) -> +Phaser.Matrix"
        }
      }
    },
    "IMAGE": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "StateManager": {
      "!doc": "The State Manager is responsible for loading, setting up and switching game states.",
      "!type": "fn(game: +Phaser.Game, pendingState: +Phaser.State)",
      "prototype": {
        "onLoadUpdateCallback": {
          "!doc": "This is called when the State is updated during the preload phase.",
          "!type": "+Function"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "onLoadRenderCallback": {
          "!doc": "This is called when the State is rendered during the preload phase.",
          "!type": "+Function"
        },
        "onPreRenderCallback": {
          "!doc": "This is called before the state is rendered and before the stage is cleared but after all game objects have had their final properties adjusted.",
          "!type": "+Function"
        },
        "link": {
          "!doc": "Links game properties to the State given by the key.",
          "!type": "fn(key: +String)"
        },
        "onResumedCallback": {
          "!doc": "This is called when the game is resumed from a paused state.",
          "!type": "+Function"
        },
        "update": {
          "!doc": "",
          "!type": "fn()"
        },
        "onUpdateCallback": {
          "!doc": "This is called when the state is updated, every game loop. It doesn't happen during preload (@see onLoadUpdateCallback).",
          "!type": "+Function"
        },
        "onRenderCallback": {
          "!doc": "This is called post-render. It doesn't happen during preload (see onLoadRenderCallback).",
          "!type": "+Function"
        },
        "remove": {
          "!doc": "Delete the given state.",
          "!type": "fn(key: +String)"
        },
        "states": {
          "!doc": "The object containing Phaser.States.",
          "!type": "+Object"
        },
        "current": {
          "!doc": "The current active State object.",
          "!type": "+String"
        },
        "onPreloadCallback": {
          "!doc": "This is called when the state starts to load assets.",
          "!type": "+Function"
        },
        "pauseUpdate": {
          "!doc": "",
          "!type": "fn()"
        },
        "clearCurrentState": {
          "!doc": "This method clears the current State, calling its shutdown callback. The process also removes any active tweens,\nresets the camera, resets input, clears physics, removes timers and if set clears the world and cache too.",
          "!type": "fn()"
        },
        "checkState": {
          "!doc": "Checks if a given phaser state is valid. A State is considered valid if it has at least one of the core functions: preload, create, update or render.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "getCurrentState": {
          "!doc": "Gets the current State.",
          "!type": "fn() -> +Phaser.State"
        },
        "onPauseUpdateCallback": {
          "!doc": "This is called every frame while the game is paused.",
          "!type": "+Function"
        },
        "onStateChange": {
          "!doc": "onStateChange is a Phaser.Signal that is dispatched whenever the game changes state.\n\nIt is dispatched only when the new state is started, which isn't usually at the same time as StateManager.start\nis called because state swapping is done in sync with the game loop. It is dispatched *before* any of the new states\nmethods (such as preload and create) are called, and *after* the previous states shutdown method has been run.\n\nThe callback you specify is sent two parameters: the string based key of the new state, \nand the second parameter is the string based key of the old / previous state.",
          "!type": "+Phaser.Signal"
        },
        "render": {
          "!doc": "",
          "!type": "fn()"
        },
        "add": {
          "!doc": "Adds a new State into the StateManager. You must give each State a unique key by which you'll identify it.\nThe State can be either a Phaser.State object (or an object that extends it), a plain JavaScript object or a function.\nIf a function is given a new state object will be created by calling it.",
          "!type": "fn(key: +String, state: +Phaser.State, autoStart: +Boolean)"
        },
        "resume": {
          "!doc": "",
          "!type": "fn()"
        },
        "onPausedCallback": {
          "!doc": "This is called when the game is paused.",
          "!type": "+Function"
        },
        "restart": {
          "!doc": "Restarts the current State. State.shutDown will be called (if it exists) before the State is restarted.",
          "!type": "fn(clearWorld: +Boolean, clearCache: +Boolean, parameter: +any)"
        },
        "preRender": {
          "!doc": "",
          "!type": "fn(elapsedTime: +Number)"
        },
        "created": {
          "!doc": "True if the current state has had its `create` method run (if it has one, if not this is true by default).",
          "!type": "+Boolean"
        },
        "onCreateCallback": {
          "!doc": "This is called when the state preload has finished and creation begins.",
          "!type": "+Function"
        },
        "start": {
          "!doc": "Start the given State. If a State is already running then State.shutDown will be called (if it exists) before switching to the new State.",
          "!type": "fn(key: +String, clearWorld: +Boolean, clearCache: +Boolean, parameter: +any)"
        },
        "onInitCallback": {
          "!doc": "This is called when the state is set as the active state.",
          "!type": "+Function"
        },
        "destroy": {
          "!doc": "Removes all StateManager callback references to the State object, nulls the game reference and clears the States object.\nYou don't recover from this without rebuilding the Phaser instance again.",
          "!type": "fn()"
        },
        "onResizeCallback": {
          "!doc": "This is called if ScaleManager.scalemode is RESIZE and a resize event occurs. It's passed the new width and height.",
          "!type": "+Function"
        },
        "pause": {
          "!doc": "",
          "!type": "fn()"
        },
        "unlink": {
          "!doc": "Nulls all State level Phaser properties, including a reference to Game.",
          "!type": "fn(key: +String)"
        },
        "loadComplete": {
          "!doc": "",
          "!type": "fn()"
        },
        "resize": {
          "!doc": "",
          "!type": "fn()"
        },
        "onShutDownCallback": {
          "!doc": "This is called when the state is shut down (i.e. swapped to another state).",
          "!type": "+Function"
        },
        "preUpdate": {
          "!doc": "preUpdate is called right at the start of the game loop. It is responsible for changing to a new state that was requested previously.",
          "!type": "fn()"
        }
      }
    },
    "Button": {
      "init": {
        "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
        "!type": "fn()"
      },
      "install": {
        "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
        "!type": "fn()"
      },
      "!doc": "Create a new `Button` object. A Button is a special type of Sprite that is set-up to handle Pointer events automatically.\n\nThe four states a Button responds to are:\n\n* 'Over' - when the Pointer moves over the Button. This is also commonly known as 'hover'.\n* 'Out' - when the Pointer that was previously over the Button moves out of it.\n* 'Down' - when the Pointer is pressed down on the Button. I.e. touched on a touch enabled device or clicked with the mouse.\n* 'Up' - when the Pointer that was pressed down on the Button is released again.\n\nA different texture/frame and activation sound can be specified for any of the states.\n\nFrames can be specified as either an integer (the frame ID) or a string (the frame name); the same values that can be used with a Sprite constructor.",
      "!type": "fn(game: +Phaser.Game, x: +Number, y: +Number, key: +String, callback: +Function, callbackContext: +Object, overFrame: +String, outFrame: +String, downFrame: +String, upFrame: +String)",
      "prototype": {
        "play": {
          "!doc": "Plays an Animation.\n\nThe animation should have previously been created via `animations.add`.\n\nIf the animation is already playing calling this again won't do anything.\nIf you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.",
          "!type": "fn(name: +String, frameRate: +Number, loop: +Boolean, killOnComplete: +Boolean) -> +Phaser.Animation"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "setOverSound": {
          "!doc": "The Sound to be played when a Pointer moves over this Button.",
          "!type": "fn(sound: +Phaser.Sound, marker: +String)"
        },
        "lifespan": {
          "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
          "!type": "+Number"
        },
        "onInputOut": {
          "!doc": "The Signal (or event) dispatched when this Button is in an Out state.",
          "!type": "+Phaser.Signal"
        },
        "type": {
          "!doc": "The Phaser Object Type.",
          "!type": "+Number"
        },
        "onInputUp": {
          "!doc": "The Signal (or event) dispatched when this Button is in an Up state.",
          "!type": "+Phaser.Signal"
        },
        "resizeFrame": {
          "!doc": "Resizes the Frame dimensions that the Game Object uses for rendering.\n\nYou shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData\nit can be useful to adjust the dimensions directly in this way.",
          "!type": "fn(parent: +Object, width: +Number, height: +Number)"
        },
        "onInputUpHandler": {
          "!doc": "Internal function that handles input events.",
          "!type": "fn(sprite: +Phaser.Button, pointer: +Phaser.Pointer)"
        },
        "onInputOverHandler": {
          "!doc": "Internal function that handles input events.",
          "!type": "fn(sprite: +Phaser.Button, pointer: +Phaser.Pointer)"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "revive": {
          "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
          "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
        },
        "bringToTop": {
          "!doc": "Brings this Game Object to the top of its parents display list.\nVisually this means it will render over the top of any old child in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "events": {
          "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
          "!type": "+Phaser.Events"
        },
        "moveUp": {
          "!doc": "Moves this Game Object up one place in its parents display list.\nThis call has no effect if the Game Object is already at the top of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "justReleasedPreventsOver": {
          "!doc": "Suppresse the over event if a pointer was just released and it matches the given {@link Phaser.PointerModer pointer mode bitmask}.\n\nThis behavior was introduced in Phaser 2.3.1; this property is a soft-revert of the change.",
          "!type": "+Phaser.PointerMode"
        },
        "postUpdate": {
          "!doc": "Internal method called by the World postUpdate cycle.",
          "!type": "fn()"
        },
        "smoothed": {
          "!doc": "Enable or disable texture smoothing for this Game Object.\n\nIt only takes effect if the Game Object is using an image based texture.\n\nSmoothing is enabled by default.",
          "!type": "+Boolean"
        },
        "destroy": {
          "!doc": "Destroys the Game Object. This removes it from its parent group, destroys the input, event and animation handlers if present\nand nulls its reference to `game`, freeing it up for garbage collection.\n\nIf this Game Object has the Events component it will also dispatch the `onDestroy` event.\n\nYou can optionally also destroy the BaseTexture this Game Object is using. Be careful if you've\nmore than one Game Object sharing the same BaseTexture.",
          "!type": "fn(destroyChildren: +Boolean, destroyTexture: +Boolean)"
        },
        "setUpSound": {
          "!doc": "The Sound to be played when a Pointer has pressed down and is released from this Button.",
          "!type": "fn(sound: +Phaser.Sound, marker: +String)"
        },
        "onInputDownHandler": {
          "!doc": "Internal function that handles input events.",
          "!type": "fn(sprite: +Phaser.Button, pointer: +Phaser.Pointer)"
        },
        "onOverSoundMarker": {
          "!doc": "The Sound Marker used in conjunction with the onOverSound.",
          "!type": "+String"
        },
        "input": {
          "!doc": "The Input Handler for this Game Object.\n\nBy default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.\n\nAfter you have done this, this property will be a reference to the Phaser InputHandler.",
          "!type": "+Phaser.InputHandler"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "left": {
          "!doc": "The left coordinate of the Game Object.\nThis is the same as `x - offsetX`.",
          "!type": "+Number"
        },
        "reset": {
          "!doc": "Resets the Game Object.\n\nThis moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`, \n`visible` and `renderable` to true.\n\nIf this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.\n\nIf this Game Object has a Physics Body it will reset the Body.",
          "!type": "fn(x: +Number, y: +Number, health: +Number) -> +PIXI.DisplayObject"
        },
        "preUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn()"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "components": {
          "!doc": "The components this Game Object has installed.",
          "!type": "+Object"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
          "!type": "+Boolean"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "world": {
          "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
          "!type": "+Phaser.Point"
        },
        "top": {
          "!doc": "The y coordinate of the Game Object.\nThis is the same as `y - offsetY`.",
          "!type": "+Number"
        },
        "angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        },
        "key": {
          "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
          "!type": "+String"
        },
        "onUpSoundMarker": {
          "!doc": "The Sound Marker used in conjunction with the onUpSound.",
          "!type": "+String"
        },
        "setFrames": {
          "!doc": "Used to manually set the frames that will be used for the different states of the Button.\n\nFrames can be specified as either an integer (the frame ID) or a string (the frame name); these are the same values that can be used with a Sprite constructor.",
          "!type": "fn(overFrame: +String, outFrame: +String, downFrame: +String, upFrame: +String)"
        },
        "onDownSound": {
          "!doc": "The Sound to be played when this Buttons Down state is activated.",
          "!type": "+Phaser.Sound"
        },
        "texture": {
          "!doc": "The texture that the sprite is using",
          "!type": "+Texture"
        },
        "destroyPhase": {
          "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
          "!type": "+Boolean"
        },
        "right": {
          "!doc": "The right coordinate of the Game Object.\nThis is the same as `x + width - offsetX`.",
          "!type": "+Number"
        },
        "kill": {
          "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousPosition": {
          "!doc": "The position the Game Object was located in the previous frame.",
          "!type": "+Phaser.Point"
        },
        "onInputOutHandler": {
          "!doc": "Internal function that handles input events.",
          "!type": "fn(sprite: +Phaser.Button, pointer: +Phaser.Pointer)"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "anchor": {
          "!doc": "The anchor sets the origin point of the texture.\nThe default is 0,0 this means the texture's origin is the top left\nSetting than anchor to 0.5,0.5 means the textures origin is centered\nSetting the anchor to 1,1 would mean the textures origin points will be the bottom right corner",
          "!type": "+Phaser.Point"
        },
        "autoCull": {
          "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "onInputOver": {
          "!doc": "The Signal (or event) dispatched when this Button is in an Over state.",
          "!type": "+Phaser.Signal"
        },
        "exists": {
          "!doc": "Controls if this Game Object is processed by the core game loop.\nIf this Game Object has a physics body it also controls if its physics body is updated or not.\nWhen `exists` is set to `false` it will remove its physics body from the physics world if it has one.\nIt also toggles the `visible` property to false as well.\n\nSetting `exists` to true will add its physics body back in to the physics world, if it has one.\nIt will also set the `visible` property to `true`.",
          "!type": "+Boolean"
        },
        "z": {
          "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
          "!type": "+Number"
        },
        "clearFrames": {
          "!doc": "Clears all of the frames set on this Button.",
          "!type": "fn()"
        },
        "onOutSoundMarker": {
          "!doc": "The Sound Marker used in conjunction with the onOutSound.",
          "!type": "+String"
        },
        "onInputDown": {
          "!doc": "The Signal (or event) dispatched when this Button is in an Down state.",
          "!type": "+Phaser.Signal"
        },
        "inCamera": {
          "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
          "!type": "+Boolean"
        },
        "offsetX": {
          "!doc": "The amount the Game Object is visually offset from its x coordinate.\nThis is the same as `width * anchor.x`.\nIt will only be > 0 if anchor.x is not equal to zero.",
          "!type": "+Number"
        },
        "tintedTexture": {
          "!doc": "A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)",
          "!type": "+Phaser.Canvas"
        },
        "offsetY": {
          "!doc": "The amount the Game Object is visually offset from its y coordinate.\nThis is the same as `height * anchor.y`.\nIt will only be > 0 if anchor.y is not equal to zero.",
          "!type": "+Number"
        },
        "onUpSound": {
          "!doc": "The Sound to be played when this Buttons Up state is activated.",
          "!type": "+Phaser.Sound"
        },
        "setSounds": {
          "!doc": "Sets the sounds to be played whenever this Button is interacted with. Sounds can be either full Sound objects, or markers pointing to a section of a Sound object.\nThe most common forms of sounds are 'hover' effects and 'click' effects, which is why the order of the parameters is overSound then downSound.\n\nCall this function with no parameters to reset all sounds on this Button.",
          "!type": "fn(overSound: +Phaser.Sound, overMarker: +String, downSound: +Phaser.Sound, downMarker: +String, outSound: +Phaser.Sound, outMarker: +String, upSound: +Phaser.Sound, upMarker: +String)"
        },
        "fixedToCamera": {
          "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
          "!type": "+Boolean"
        },
        "renderOrderID": {
          "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
          "!type": "+Number"
        },
        "previousRotation": {
          "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
          "!type": "+Number"
        },
        "onDownSoundMarker": {
          "!doc": "The Sound Marker used in conjunction with the onDownSound.",
          "!type": "+String"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.\nThis is the same as `y + height - offsetY`.",
          "!type": "+Number"
        },
        "cameraOffset": {
          "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
          "!type": "+Phaser.Point"
        },
        "moveDown": {
          "!doc": "Moves this Game Object down one place in its parents display list.\nThis call has no effect if the Game Object is already at the bottom of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "updateCrop": {
          "!doc": "If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,\nor the rectangle it references, then you need to update the crop frame by calling this method.",
          "!type": "fn()"
        },
        "overlap": {
          "!doc": "Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object, \nwhich can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.\n\nThis check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.\n\nTherefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.\nIt should be fine for low-volume testing where physics isn't required.",
          "!type": "fn(displayObject: +Phaser.Sprite) -> +Boolean"
        },
        "loadTexture": {
          "!doc": "Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.\n\nIf your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.\n\nYou should only use `loadTexture` if you want to replace the base texture entirely.\n\nCalling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.\n\nYou can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite. \nDoing this then sets the key to be the `frame` argument (the frame is set to zero). \n\nThis allows you to create sprites using `load.image` during development, and then change them \nto use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS' \nand swapping it to be the key of the atlas data.\n\nNote: You cannot use a RenderTexture as a texture for a TileSprite.",
          "!type": "fn(key: +String, frame: +String, stopAnimation: +Boolean)"
        },
        "onOverSound": {
          "!doc": "The Sound to be played when this Buttons Over state is activated.",
          "!type": "+Phaser.Sound"
        },
        "freezeFrames": {
          "!doc": "When true the the texture frame will not be automatically switched on up/down/over/out events.",
          "!type": "+Boolean"
        },
        "name": {
          "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
          "!type": "+String"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "crop": {
          "!doc": "Crop allows you to crop the texture being used to display this Game Object.\nSetting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.\n\nCropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,\nor by modifying `cropRect` property directly and then calling `updateCrop`.\n\nThe rectangle object given to this method can be either a `Phaser.Rectangle` or any other object \nso long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.\n\nA reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`, \nin which case the values are duplicated to a local object.",
          "!type": "fn(rect: +Phaser.Rectangle, copy: +Boolean)"
        },
        "frame": {
          "!doc": "Gets or sets the current frame index of the texture being used to render this Game Object.\n\nTo change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,\nfor example: `player.frame = 4`.\n\nIf the frame index given doesn't exist it will revert to the first frame found in the texture.\n\nIf you are using a texture atlas then you should use the `frameName` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+Number"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "shader": {
          "!doc": "The shader that will be used to render the texture to the stage. Set to null to remove a current shader.",
          "!type": "+PIXI.AbstractFilter"
        },
        "cropRect": {
          "!doc": "The Rectangle used to crop the texture this Game Object uses.\nSet this property via `crop`. \nIf you modify this property directly you must call `updateCrop` in order to have the change take effect.",
          "!type": "+Phaser.Rectangle"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "setOutSound": {
          "!doc": "The Sound to be played when a Pointer moves out of this Button.",
          "!type": "fn(sound: +Phaser.Sound, marker: +String)"
        },
        "update": {
          "!doc": "Override this method in your own custom objects to handle any update requirements.\nIt is called immediately after `preUpdate` and before `postUpdate`.\nRemember if this Game Object has any children you should call update on those too.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "onOverMouseOnly": {
          "!doc": "If true then onOver events (such as onOverSound) will only be triggered if the Pointer object causing them was the Mouse Pointer.\nThe frame will still be changed as applicable.",
          "!type": "+Boolean"
        },
        "onOutSound": {
          "!doc": "The Sound to be played when this Buttons Out state is activated.",
          "!type": "+Phaser.Sound"
        },
        "tint": {
          "!doc": "The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.",
          "!type": "+Number"
        },
        "inputEnabled": {
          "!doc": "By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created\nfor this Game Object and it will then start to process click / touch events and more.\n\nYou can then access the Input Handler via `this.input`.\n\nNote that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.\n\nIf you set this property to false it will stop the Input Handler from processing any more input events.",
          "!type": "+Boolean"
        },
        "setDownSound": {
          "!doc": "The Sound to be played when a Pointer presses down on this Button.",
          "!type": "fn(sound: +Phaser.Sound, marker: +String)"
        },
        "setFrame": {
          "!doc": "Sets the texture frame the Game Object uses for rendering.\n\nThis is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.",
          "!type": "fn(frame: +Phaser.Frame)"
        },
        "forceOut": {
          "!doc": "When the Button is touched / clicked and then released you can force it to enter a state of \"out\" instead of \"up\".\n\nThis can also accept a {@link Phaser.PointerModer pointer mode bitmask} for more refined control.",
          "!type": "+Boolean"
        },
        "removedFromWorld": {
          "!doc": "Called when this Button is removed from the World.",
          "!type": "fn()"
        },
        "animations": {
          "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
          "!type": "+Phaser.AnimationManager"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "debug": {
          "!doc": "A debug flag designed for use with `Game.enableStep`.",
          "!type": "+Boolean"
        },
        "frameName": {
          "!doc": "Gets or sets the current frame name of the texture being used to render this Game Object.\n\nTo change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use, \nfor example: `player.frameName = \"idle\"`.\n\nIf the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.\n\nIf you are using a sprite sheet then you should use the `frame` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+String"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends this Game Object to the bottom of its parents display list.\nVisually this means it will render below all other children in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "resetFrame": {
          "!doc": "Resets the texture frame dimensions that the Game Object uses for rendering.",
          "!type": "fn()"
        },
        "pendingDestroy": {
          "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
          "!type": "+Boolean"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.\n\nWarning: You cannot have a blend mode and a filter active on the same Sprite. Doing so will render the sprite invisible.",
          "!type": "+Number"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "fresh": {
          "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
          "!type": "+Boolean"
        }
      }
    },
    "FlexLayer": {
      "SORT_ASCENDING": "+Number",
      "RETURN_TOTAL": "+Number",
      "!doc": "WARNING: This is an EXPERIMENTAL class. The API will change significantly in the coming versions and is incomplete.\nPlease try to avoid using in production games with a long time to build.\nThis is also why the documentation is incomplete.\n\nA responsive grid layer.",
      "RETURN_NONE": "+Number",
      "!type": "fn(manager: +Phaser.FlexGrid, position: +Phaser.Point, bounds: +Phaser.Rectangle, scale: +Phaser.Point)",
      "SORT_DESCENDING": "+Number",
      "RETURN_CHILD": "+Number",
      "prototype": {
        "xy": {
          "!doc": "Positions the child found at the given index within this group to the given x and y coordinates.",
          "!type": "fn(index: +Number, x: +Number, y: +Number)"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "descendingSortHandler": {
          "!doc": "An internal helper function for the sort process.",
          "!type": "fn(a: +Object, b: +Object)"
        },
        "type": {
          "!doc": "Internal Phaser Type value.",
          "!type": "+Number"
        },
        "moveAll": {
          "!doc": "Moves all children from this Group to the Group given.",
          "!type": "fn(group: +Phaser.Group, silent: +Boolean) -> +Phaser.Group"
        },
        "removeAll": {
          "!doc": "Removes all children from this group, but does not remove the group from its parent.",
          "!type": "fn(destroy: +Boolean, silent: +Boolean)"
        },
        "enableBody": {
          "!doc": "If true all Sprites created by, or added to this group, will have a physics body enabled on them.\n\nThe default body type is controlled with {@link #physicsBodyType}.",
          "!type": "+Boolean"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "customSort": {
          "!doc": "Sort the children in the group according to custom sort function.\n\nThe `sortHandler` is provided the two parameters: the two children involved in the comparison (a and b).\nIt should return -1 if `a > b`, 1 if `a < b` or 0 if `a === b`.",
          "!type": "fn(sortHandler: +Function, context: +Object)"
        },
        "enableBodyDebug": {
          "!doc": "If true when a physics body is created (via {@link #enableBody}) it will create a physics debug object as well.\n\nThis only works for P2 bodies.",
          "!type": "+Boolean"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "bringToTop": {
          "!doc": "Brings the given child to the top of this group so it renders above all other children.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "moveUp": {
          "!doc": "Moves the given child up one place in this group unless it's already at the top.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "postUpdate": {
          "!doc": "The core postUpdate - as called by World.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Destroys this group.\n\nRemoves all children, then removes this group from its parent and nulls references.",
          "!type": "fn(destroyChildren: +Boolean, soft: +Boolean)"
        },
        "cursorIndex": {
          "!doc": "The current index of the Group cursor. Advance it with Group.next.",
          "!type": "+Number"
        },
        "getFirstDead": {
          "!doc": "Get the first child that is dead (`child.alive === false`).\n\nThis is handy for checking if everything has been wiped out and adding to the pool as needed.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no dead ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "physicsSortDirection": {
          "!doc": "If this Group contains Arcade Physics Sprites you can set a custom sort direction via this property.\n\nIt should be set to one of the Phaser.Physics.Arcade sort direction constants: \n\nPhaser.Physics.Arcade.SORT_NONE\nPhaser.Physics.Arcade.LEFT_RIGHT\nPhaser.Physics.Arcade.RIGHT_LEFT\nPhaser.Physics.Arcade.TOP_BOTTOM\nPhaser.Physics.Arcade.BOTTOM_TOP\n\nIf set to `null` the Group will use whatever Phaser.Physics.Arcade.sortDirection is set to. This is the default behavior.",
          "!type": "+Number"
        },
        "addAt": {
          "!doc": "Adds an existing object to this group.\n\nThe child is added to the group at the location specified by the index value, this allows you to control child ordering.",
          "!type": "fn(child: +DisplayObject, index: +Number, silent: +Boolean) -> +PIXI.DisplayObject"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "forEachAlive": {
          "!doc": "Call a function on each alive child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "resetCursor": {
          "!doc": "Sets the group cursor to the first child in the group.\n\nIf the optional index parameter is given it sets the cursor to the object at that index instead.",
          "!type": "fn(index: +Number) -> +Object"
        },
        "addMultiple": {
          "!doc": "Adds an array of existing Display Objects to this Group.\n\nThe Display Objects are automatically added to the top of this Group, and will render on-top of everything already in this Group.\n\nAs well as an array you can also pass another Group as the first argument. In this case all of the children from that\nGroup will be removed from it and added into this Group.",
          "!type": "fn(children: +Array._DisplayObject_, silent: +Boolean) -> +Array._DisplayObject_"
        },
        "setProperty": {
          "!doc": "Sets a property to the given value on the child. The operation parameter controls how the value is set.\n\nThe operations are:\n- 0: set the existing value to the given value; if force is `true` a new property will be created if needed\n- 1: will add the given value to the value already present.\n- 2: will subtract the given value from the value already present.\n- 3: will multiply the value already present by the given value.\n- 4: will divide the value already present by the given value.",
          "!type": "fn(child: +Object, key: +Array, value: +Object, operation: +Number, force: +Boolean) -> +Boolean"
        },
        "bounds": {
          "!doc": "",
          "!type": "+Phaser.Rectangle"
        },
        "preUpdate": {
          "!doc": "The core preUpdate - as called by World.",
          "!type": "fn()"
        },
        "hash": {
          "!doc": "The hash array is an array belonging to this Group into which you can add any of its children via Group.addToHash and Group.removeFromHash.\n\nOnly children of this Group can be added to and removed from the hash.\n\nThis hash is used automatically by Phaser Arcade Physics in order to perform non z-index based destructive sorting.\nHowever if you don't use Arcade Physics, or this isn't a physics enabled Group, then you can use the hash to perform your own\nsorting and filtering of Group children without touching their z-index (and therefore display draw order)",
          "!type": "+Array"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "addToHash": {
          "!doc": "Adds a child of this Group into the hash array.\nThis call will return false if the child is not a child of this Group, or is already in the hash.",
          "!type": "fn(child: +DisplayObject) -> +Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "The alive property is useful for Groups that are children of other Groups and need to be included/excluded in checks like forEachAlive.",
          "!type": "+Boolean"
        },
        "bottomRight": {
          "!doc": "",
          "!type": "+Phaser.Point"
        },
        "checkProperty": {
          "!doc": "Checks a property for the given value on the child.",
          "!type": "fn(child: +Object, key: +Array, value: +Object, force: +Boolean) -> +Boolean"
        },
        "callbackFromArray": {
          "!doc": "Returns a reference to a function that exists on a child of the group based on the given callback array.",
          "!type": "fn(child: +Object, callback: +Array, length: +Number)"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "multiplyAll": {
          "!doc": "Multiplies the given property by the amount on all children in this group.\n\n`Group.multiplyAll('x', 2)` will x2 the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "getByName": {
          "!doc": "Searches the Group for the first instance of a child with the `name`\nproperty matching the given argument. Should more than one child have\nthe same name only the first instance is returned.",
          "!type": "fn(name: +String) -> +Object"
        },
        "angle": {
          "!doc": "The angle of rotation of the group container, in degrees.\n\nThis adjusts the group itself by modifying its local rotation transform.\n\nThis has no impact on the rotation/angle properties of the children, but it will update their worldTransform\nand on-screen orientation and position.",
          "!type": "+Number"
        },
        "persist": {
          "!doc": "Should the FlexLayer remain through a State swap?",
          "!type": "+Boolean"
        },
        "iterate": {
          "!doc": "Iterates over the children of the group performing one of several actions for matched children.\n\nA child is considered a match when it has a property, named `key`, whose value is equal to `value`\naccording to a strict equality comparison.\n\nThe result depends on the `returnType`:\n\n- {@link Phaser.Group.RETURN_TOTAL RETURN_TOTAL}:\n    The callback, if any, is applied to all matching children. The number of matched children is returned.\n- {@link Phaser.Group.RETURN_NONE RETURN_NONE}:\n    The callback, if any, is applied to all matching children. No value is returned.\n- {@link Phaser.Group.RETURN_CHILD RETURN_CHILD}:\n    The callback, if any, is applied to the *first* matching child and the *first* matched child is returned.\n    If there is no matching child then null is returned.\n\nIf `args` is specified it must be an array. The matched child will be assigned to the first\nelement and the entire array will be applied to the callback function.",
          "!type": "fn(key: +String, value: +Object, returnType: +Number, callback: +Function, callbackContext: +Object, args: +Array._any_) -> +Object"
        },
        "bottomLeft": {
          "!doc": "",
          "!type": "+Phaser.Point"
        },
        "onDestroy": {
          "!doc": "This signal is dispatched when the group is destroyed.",
          "!type": "+Phaser.Signal"
        },
        "set": {
          "!doc": "Quickly set a property on a single child of this group to a new value.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(child: +Phaser.Sprite, key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean) -> +Boolean"
        },
        "getFirstExists": {
          "!doc": "Get the first display object that exists, or doesn't exist.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if none matching your exists argument were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(exists: +Boolean, createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "topRight": {
          "!doc": "",
          "!type": "+Phaser.Point"
        },
        "reverse": {
          "!doc": "Reverses all children in this group.\n\nThis operation applies only to immediate children and does not propagate to subgroups.",
          "!type": "fn()"
        },
        "filter": {
          "!doc": "Find children matching a certain predicate.\n\nFor example:\n\n    var healthyList = Group.filter(function(child, index, children) {\n        return child.health > 10 ? true : false;\n    }, true);\n    healthyList.callAll('attack');\n\nNote: Currently this will skip any children which are Groups themselves.",
          "!type": "fn(predicate: +Function, checkExists: +Boolean) -> +Phaser.ArraySet"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "addAll": {
          "!doc": "Adds the amount to the given property on all children in this group.\n\n`Group.addAll('x', 10)` will add 10 to the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "grid": {
          "!doc": "A reference to the FlexGrid that owns this layer.",
          "!type": "+Phaser.FlexGrid"
        },
        "ignoreDestroy": {
          "!doc": "A group with `ignoreDestroy` set to `true` ignores all calls to its `destroy` method.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The x coordinate of the group container.\n\nYou can adjust the group container itself by modifying its coordinates.\nThis will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "If exists is true the group is updated, otherwise it is skipped.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The y coordinate of the group container.\n\nYou can adjust the group container itself by modifying its coordinates.\nThis will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z-depth value of this object within its parent container/Group - the World is a Group as well.\nThis value must be unique for each child in a Group.",
          "!type": "+Number"
        },
        "divideAll": {
          "!doc": "Divides the given property by the amount on all children in this group.\n\n`Group.divideAll('x', 2)` will half the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "setAllChildren": {
          "!doc": "Quickly set the same property across all children of this group, and any child Groups, to a new value.\n\nIf this group contains other Groups then the same property is set across their children as well, iterating down until it reaches the bottom.\nUnlike with `setAll` the property is NOT set on child Groups itself.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
        },
        "physicsBodyType": {
          "!doc": "If {@link #enableBody} is true this is the type of physics body that is created on new Sprites.\n\nThe valid values are {@link Phaser.Physics.ARCADE}, {@link Phaser.Physics.P2JS}, {@link Phaser.Physics.NINJA}, etc.",
          "!type": "+Number"
        },
        "getIndex": {
          "!doc": "Get the index position of the given child in this group, which should match the child's `z` property.",
          "!type": "fn(child: +Object) -> +Number"
        },
        "getBottom": {
          "!doc": "Returns the child at the bottom of this group.\n\nThe bottom child the child being displayed (rendered) below every other child.",
          "!type": "fn() -> +Object"
        },
        "replace": {
          "!doc": "Replaces a child of this group with the given newChild. The newChild cannot be a member of this group.",
          "!type": "fn(oldChild: +Object, newChild: +Object) -> +Object"
        },
        "resetChild": {
          "!doc": "Takes a child and if the `x` and `y` arguments are given it calls `child.reset(x, y)` on it.\n\nIf the `key` and optionally the `frame` arguments are given, it calls `child.loadTexture(key, frame)` on it.\n\nThe two operations are separate. For example if you just wish to load a new texture then pass `null` as the x and y values.",
          "!type": "fn(child: +DisplayObject, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "getRandom": {
          "!doc": "Returns a random child from the group.",
          "!type": "fn(startIndex: +Number, length: +Number) -> +Object"
        },
        "forEachExists": {
          "!doc": "Call a function on each existing child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "getTop": {
          "!doc": "Return the child at the top of this group.\n\nThe top child is the child displayed (rendered) above every other child.",
          "!type": "fn() -> +Object"
        },
        "create": {
          "!doc": "Creates a new Phaser.Sprite object and adds it to the top of this group.\n\nUse {@link #classType} to change the type of object created.",
          "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String, exists: +Boolean) -> +PIXI.DisplayObject"
        },
        "countDead": {
          "!doc": "Get the number of dead children in this group.",
          "!type": "fn() -> +Number"
        },
        "subAll": {
          "!doc": "Subtracts the amount from the given property on all children in this group.\n\n`Group.subAll('x', 10)` will minus 10 from the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "fixedToCamera": {
          "!doc": "A Group that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Group.cameraOffset.\n\nNote that the cameraOffset values are in addition to any parent in the display list.\nSo if this Group was in a Group that has x: 200, then this will be added to the cameraOffset.x",
          "!type": "+Boolean"
        },
        "add": {
          "!doc": "Adds an existing object as the top child in this group.\n\nThe child is automatically added to the top of the group and is displayed on top of every previous child.\n\nIf Group.enableBody is set then a physics body will be created on the object, so long as one does not already exist.\n\nUse {@link #addAt} to control where a child is added. Use {@link #create} to create and add a new child.",
          "!type": "fn(child: +DisplayObject, silent: +Boolean) -> +PIXI.DisplayObject"
        },
        "visible": {
          "!doc": "The visible state of the group. Non-visible Groups and all of their children are not rendered.",
          "!type": "+Boolean"
        },
        "swap": {
          "!doc": "Swaps the position of two children in this group.\n\nBoth children must be in this group, a child cannot be swapped with itself, and unparented children cannot be swapped.",
          "!type": "fn(child1: +Object, child2: +Object)"
        },
        "cameraOffset": {
          "!doc": "If this object is {@link #fixedToCamera} then this stores the x/y position offset relative to the top-left of the camera view.\nIf the parent of this Group is also `fixedToCamera` then the offset here is in addition to that and should typically be disabled.",
          "!type": "+Phaser.Point"
        },
        "sort": {
          "!doc": "Sort the children in the group according to a particular key and ordering.\n\nCall this function to sort the group according to a particular key value and order.\n\nFor example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.\n\nInternally this uses a standard JavaScript Array sort, so everything that applies there also applies here, including\nalphabetical sorting, mixing strings and numbers, and Unicode sorting. See MDN for more details.",
          "!type": "fn(key: +String, order: +Number)"
        },
        "moveDown": {
          "!doc": "Moves the given child down one place in this group unless it's already at the bottom.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "hasProperty": {
          "!doc": "Checks if the child has the given property.\n\nWill scan up to 4 levels deep only.",
          "!type": "fn(child: +Object, key: +Array._string_) -> +Boolean"
        },
        "updateZ": {
          "!doc": "Internal method that re-applies all of the children's Z values.\n\nThis must be called whenever children ordering is altered so that their `z` indices are correctly updated.",
          "!type": "fn()"
        },
        "name": {
          "!doc": "A name for this group. Not used internally but useful for debugging.",
          "!type": "+String"
        },
        "ascendingSortHandler": {
          "!doc": "An internal helper function for the sort process.",
          "!type": "fn(a: +Object, b: +Object)"
        },
        "position": {
          "!doc": "",
          "!type": "+Phaser.Point"
        },
        "removeBetween": {
          "!doc": "Removes all children from this group whose index falls beteen the given startIndex and endIndex values.",
          "!type": "fn(startIndex: +Number, endIndex: +Number, destroy: +Boolean, silent: +Boolean)"
        },
        "removeFromHash": {
          "!doc": "Removes a child of this Group from the hash array.\nThis call will return false if the child is not in the hash.",
          "!type": "fn(child: +DisplayObject) -> +Boolean"
        },
        "classType": {
          "!doc": "The type of objects that will be created when using {@link #create} or {@link #createMultiple}.\n\nAny object may be used but it should extend either Sprite or Image and accept the same constructor arguments:\nwhen a new object is created it is passed the following parameters to its constructor: `(game, x, y, key, frame)`.",
          "!type": "+Object"
        },
        "next": {
          "!doc": "Advances the group cursor to the next (higher) object in the group.\n\nIf the cursor is at the end of the group (top child) it is moved the start of the group (bottom child).",
          "!type": "fn() -> +Object"
        },
        "cursor": {
          "!doc": "The current display object that the group cursor is pointing to, if any. (Can be set manually.)\n\nThe cursor is a way to iterate through the children in a Group using {@link #next} and {@link #previous}.",
          "!type": "+PIXI.DisplayObject"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "forEachDead": {
          "!doc": "Call a function on each dead child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "update": {
          "!doc": "The core update - as called by World.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "A reference to the ScaleManager.",
          "!type": "+Phaser.ScaleManager"
        },
        "countLiving": {
          "!doc": "Get the number of living children in this group.",
          "!type": "fn() -> +Number"
        },
        "remove": {
          "!doc": "Removes the given child from this group.\n\nThis will dispatch an `onRemovedFromGroup` event from the child (if it has one), and optionally destroy the child.\n\nIf the group cursor was referring to the removed child it is updated to refer to the next child.",
          "!type": "fn(child: +Object, destroy: +Boolean, silent: +Boolean) -> +Boolean"
        },
        "callAll": {
          "!doc": "Calls a function, specified by name, on all on children.\n\nThe function is called for all children regardless if they are dead or alive (see callAllExists for different options).\nAfter the method parameter and context you can add as many extra parameters as you like, which will all be passed to the child.",
          "!type": "fn(method: +String, context: +String, args: +Object)"
        },
        "total": {
          "!doc": "Total number of existing children in the group.",
          "!type": "+Number"
        },
        "alpha": {
          "!doc": "The alpha value of the group container.",
          "!type": "+Number"
        },
        "createMultiple": {
          "!doc": "Creates multiple Phaser.Sprite objects and adds them to the top of this group.\n\nUseful if you need to quickly generate a pool of identical sprites, such as bullets.\n\nBy default the sprites will be set to not exist and will be positioned at 0, 0 (relative to the group.x/y).\nUse {@link #classType} to change the type of object created.",
          "!type": "fn(quantity: +Number, key: +String, frame: +Number, exists: +Boolean)"
        },
        "bottomMiddle": {
          "!doc": "",
          "!type": "+Phaser.Point"
        },
        "setAll": {
          "!doc": "Quickly set the same property across all children of this group to a new value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be set on the group but not its children.\nIf you need that ability please see `Group.setAllChildren`.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
        },
        "callAllExists": {
          "!doc": "Calls a function, specified by name, on all children in the group who exist (or do not exist).\n\nAfter the existsValue parameter you can add as many parameters as you like, which will all be passed to the child callback.",
          "!type": "fn(callback: +String, existsValue: +Boolean, parameter: +Object)"
        },
        "debug": {
          "!doc": "Debug.",
          "!type": "fn()"
        },
        "checkAll": {
          "!doc": "Quickly check that the same property across all children of this group is equal to the given value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be checked on the group but not its children.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, force: +Boolean)"
        },
        "previous": {
          "!doc": "Moves the group cursor to the previous (lower) child in the group.\n\nIf the cursor is at the start of the group (bottom child) it is moved to the end (top child).",
          "!type": "fn() -> +Object"
        },
        "forEach": {
          "!doc": "Call a function on each child in this group.\n\nAdditional arguments for the callback can be specified after the `checkExists` parameter. For example,\n\n    Group.forEach(awardBonusGold, this, true, 100, 500)\n\nwould invoke `awardBonusGold` function with the parameters `(child, 100, 500)`.\n\nNote: This check will skip any children which are Groups themselves.",
          "!type": "fn(callback: +Function, callbackContext: +Object, checkExists: +Boolean, args: +Object)"
        },
        "rotation": {
          "!doc": "The angle of rotation of the group container, in radians.\n\nThis will adjust the group container itself by modifying its rotation.\nThis will have no impact on the rotation value of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "length": {
          "!doc": "Total number of children in this group, regardless of exists/alive status.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends the given child to the bottom of this group so it renders below all other children.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "topMiddle": {
          "!doc": "",
          "!type": "+Phaser.Point"
        },
        "getAt": {
          "!doc": "Returns the child found at the given index within this group.",
          "!type": "fn(index: +Number) -> +PIXI.DisplayObject"
        },
        "pendingDestroy": {
          "!doc": "A Group is that has `pendingDestroy` set to `true` is flagged to have its destroy method \ncalled on the next logic update.\nYou can set it directly to flag the Group to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy a Group from within one of its own callbacks \nor a callback of one of its children.",
          "!type": "+Boolean"
        },
        "getFirstAlive": {
          "!doc": "Get the first child that is alive (`child.alive === true`).\n\nThis is handy for choosing a squad leader, etc.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no alive ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "topLeft": {
          "!doc": "",
          "!type": "+Phaser.Point"
        },
        "resize": {
          "!doc": "Resize.",
          "!type": "fn()"
        }
      }
    },
    "Tilemap": {
      "NORTH": "+Number",
      "!doc": "Creates a new Phaser.Tilemap object. The map can either be populated with data from a Tiled JSON file or from a CSV file.\nTo do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.\nWhen using CSV data you must provide the key and the tileWidth and tileHeight parameters.\nIf creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.\nNote that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.\nA Tile map is rendered to the display using a TilemapLayer. It is not added to the display list directly itself.\nA map may have multiple layers. You can perform operations on the map data such as copying, pasting, filling and shuffling the tiles around.",
      "WEST": "+Number",
      "CSV": "+Number",
      "TILED_JSON": "+Number",
      "SOUTH": "+Number",
      "!type": "fn(game: +Phaser.Game, key: +String, tileWidth: +Number, tileHeight: +Number, width: +Number, height: +Number)",
      "EAST": "+Number",
      "prototype": {
        "createFromTiles": {
          "!doc": "Creates a Sprite for every object matching the given tile indexes in the map data.\nYou can specify the group that the Sprite will be created in. If none is given it will be created in the World.\nYou can optional specify if the tile will be replaced with another after the Sprite is created. This is useful if you want to lay down special \ntiles in a level that are converted to Sprites, but want to replace the tile itself with a floor tile or similar once converted.",
          "!type": "fn(tiles: +Number, replacements: +Number, key: +String, layer: +Number, group: +Phaser.Group, properties: +Object) -> +Number"
        },
        "getIndex": {
          "!doc": "Gets the layer index based on the layers name.",
          "!type": "fn(location: +Array, name: +String) -> +Number"
        },
        "getTileLeft": {
          "!doc": "Gets the tile to the left of the tile coordinates given.\nMostly used as an internal function by calculateFaces.",
          "!type": "fn(layer: +Number, x: +Number, y: +Number)"
        },
        "createBlankLayer": {
          "!doc": "Creates a new and empty layer on this Tilemap. By default TilemapLayers are fixed to the camera.",
          "!type": "fn(name: +String, width: +Number, height: +Number, tileWidth: +Number, tileHeight: +Number, group: +Phaser.Group) -> +Phaser.TilemapLayer"
        },
        "objects": {
          "!doc": "An array of Tiled Object Layers.",
          "!type": "+Array"
        },
        "replace": {
          "!doc": "Scans the given area for tiles with an index matching `source` and updates their index to match `dest`.",
          "!type": "fn(source: +Number, dest: +Number, x: +Number, y: +Number, width: +Number, height: +Number, layer: +Number)"
        },
        "setTileLocationCallback": {
          "!doc": "Sets a global collision callback for the given map location within the layer. This will affect all tiles on this layer found in the given area.\nIf a callback is already set for the tile index it will be replaced. Set the callback to null to remove it.\nIf you want to set a callback for a tile at a specific location on the map then see setTileLocationCallback.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, callback: +Function, callbackContext: +Object, layer: +Number)"
        },
        "tiles": {
          "!doc": "The super array of Tiles.",
          "!type": "+Array"
        },
        "layers": {
          "!doc": "An array of Tilemap layer data.",
          "!type": "+Array"
        },
        "create": {
          "!doc": "Creates an empty map of the given dimensions and one blank layer. If layers already exist they are erased.",
          "!type": "fn(name: +String, width: +Number, height: +Number, tileWidth: +Number, tileHeight: +Number, group: +Phaser.Group) -> +Phaser.TilemapLayer"
        },
        "putTileWorldXY": {
          "!doc": "Puts a tile into the Tilemap layer. The coordinates are given in pixel values.",
          "!type": "fn(tile: +Phaser.Tile, x: +Number, y: +Number, tileWidth: +Number, tileHeight: +Number, layer: +Number) -> +Phaser.Tile"
        },
        "height": {
          "!doc": "The height of the map (in tiles).",
          "!type": "+Number"
        },
        "getTile": {
          "!doc": "Gets a tile from the Tilemap Layer. The coordinates are given in tile values.",
          "!type": "fn(x: +Number, y: +Number, layer: +Number, nonNull: +Boolean) -> +Phaser.Tile"
        },
        "currentLayer": {
          "!doc": "The current layer.",
          "!type": "+Number"
        },
        "getTileRight": {
          "!doc": "Gets the tile to the right of the tile coordinates given.\nMostly used as an internal function by calculateFaces.",
          "!type": "fn(layer: +Number, x: +Number, y: +Number)"
        },
        "getTileWorldXY": {
          "!doc": "Gets a tile from the Tilemap layer. The coordinates are given in pixel values.",
          "!type": "fn(x: +Number, y: +Number, tileWidth: +Number, tileHeight: +Number, layer: +Number, nonNull: +Boolean) -> +Phaser.Tile"
        },
        "collideIndexes": {
          "!doc": "An array of tile indexes that collide.",
          "!type": "+Array"
        },
        "images": {
          "!doc": "An array of Tiled Image Layers.",
          "!type": "+Array"
        },
        "createFromObjects": {
          "!doc": "Creates a Sprite for every object matching the given gid in the map data. You can optionally specify the group that the Sprite will be created in. If none is\ngiven it will be created in the World. All properties from the map data objectgroup are copied across to the Sprite, so you can use this as an easy way to\nconfigure Sprite properties from within the map editor. For example giving an object a property of alpha: 0.5 in the map editor will duplicate that when the\nSprite is created. You could also give it a value like: body.velocity.x: 100 to set it moving automatically.",
          "!type": "fn(name: +String, gid: +Number, key: +String, frame: +Number, exists: +Boolean, autoCull: +Boolean, group: +Phaser.Group, CustomClass: +Object, adjustY: +Boolean)"
        },
        "getImageIndex": {
          "!doc": "Gets the image index based on its name.",
          "!type": "fn(name: +String) -> +Number"
        },
        "removeTileWorldXY": {
          "!doc": "Removes the tile located at the given coordinates and updates the collision data. The coordinates are given in pixel values.",
          "!type": "fn(x: +Number, y: +Number, tileWidth: +Number, tileHeight: +Number, layer: +Number) -> +Phaser.Tile"
        },
        "swap": {
          "!doc": "Scans the given area for tiles with an index matching tileA and swaps them with tileB.",
          "!type": "fn(tileA: +Number, tileB: +Number, x: +Number, y: +Number, width: +Number, height: +Number, layer: +Number)"
        },
        "addTilesetImage": {
          "!doc": "Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.\nNote that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled editor.",
          "!type": "fn(tileset: +String, key: +String, tileWidth: +Number, tileHeight: +Number, tileMargin: +Number, tileSpacing: +Number, gid: +Number) -> +Phaser.Tileset"
        },
        "getLayer": {
          "!doc": "Gets the TilemapLayer index as used in the setCollision calls.",
          "!type": "fn(layer: +Number) -> +Number"
        },
        "removeTile": {
          "!doc": "Removes the tile located at the given coordinates and updates the collision data.",
          "!type": "fn(x: +Number, y: +Number, layer: +Number) -> +Phaser.Tile"
        },
        "format": {
          "!doc": "The format of the map data, either Phaser.Tilemap.CSV or Phaser.Tilemap.TILED_JSON.",
          "!type": "+Number"
        },
        "destroy": {
          "!doc": "Removes all layer data from this tile map and nulls the game reference.\nNote: You are responsible for destroying any TilemapLayer objects you generated yourself, as Tilemap doesn't keep a reference to them.",
          "!type": "fn()"
        },
        "fill": {
          "!doc": "Fills the given area with the specified tile.",
          "!type": "fn(index: +Number, x: +Number, y: +Number, width: +Number, height: +Number, layer: +Number)"
        },
        "version": {
          "!doc": "The version of the map data (as specified in Tiled, usually 1).",
          "!type": "+Number"
        },
        "setPreventRecalculate": {
          "!doc": "Turn off/on the recalculation of faces for tile or collision updates. \n`setPreventRecalculate(true)` puts recalculation on hold while `setPreventRecalculate(false)` recalculates all the changed layers.",
          "!type": "fn(value: +Boolean)"
        },
        "debugMap": {
          "!doc": "Map data used for debug values only.",
          "!type": "+Array"
        },
        "collision": {
          "!doc": "An array of collision data (polylines, etc).",
          "!type": "+Array"
        },
        "setTileIndexCallback": {
          "!doc": "Sets a global collision callback for the given tile index within the layer. This will affect all tiles on this layer that have the same index.\nIf a callback is already set for the tile index it will be replaced. Set the callback to null to remove it.\nIf you want to set a callback for a tile at a specific location on the map then see setTileLocationCallback.",
          "!type": "fn(indexes: +Number, callback: +Function, callbackContext: +Object, layer: +Number)"
        },
        "calculateFaces": {
          "!doc": "Internal function.",
          "!type": "fn(layer: +Number)"
        },
        "setCollision": {
          "!doc": "Sets collision the given tile or tiles. You can pass in either a single numeric index or an array of indexes: [ 2, 3, 15, 20].\nThe `collides` parameter controls if collision will be enabled (true) or disabled (false).",
          "!type": "fn(indexes: +Number, collides: +Boolean, layer: +Number, recalculate: +Boolean)"
        },
        "createLayer": {
          "!doc": "Creates a new TilemapLayer object. By default TilemapLayers are fixed to the camera.\nThe `layer` parameter is important. If you've created your map in Tiled then you can get this by looking in Tiled and looking at the Layer name.\nOr you can open the JSON file it exports and look at the layers[].name value. Either way it must match.\nIf you wish to create a blank layer to put your own tiles on then see Tilemap.createBlankLayer.",
          "!type": "fn(layer: +Number, width: +Number, height: +Number, group: +Phaser.Group) -> +Phaser.TilemapLayer"
        },
        "removeAllLayers": {
          "!doc": "Removes all layers from this tile map.",
          "!type": "fn()"
        },
        "putTile": {
          "!doc": "Puts a tile of the given index value at the coordinate specified.\nIf you pass `null` as the tile it will pass your call over to Tilemap.removeTile instead.",
          "!type": "fn(tile: +Phaser.Tile, x: +Number, y: +Number, layer: +Number) -> +Phaser.Tile"
        },
        "tileHeight": {
          "!doc": "The base height of the tiles in the map (in pixels).",
          "!type": "+Number"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "setLayer": {
          "!doc": "Sets the current layer to the given index.",
          "!type": "fn(layer: +Number)"
        },
        "setCollisionByIndex": {
          "!doc": "Sets collision values on a tile in the set.\nYou shouldn't usually call this method directly, instead use setCollision, setCollisionBetween or setCollisionByExclusion.",
          "!type": "fn(index: +Number, collides: +Boolean, layer: +Number, recalculate: +Boolean)"
        },
        "paste": {
          "!doc": "Pastes a previously copied block of tile data into the given x/y coordinates. Data should have been prepared with Tilemap.copy.",
          "!type": "fn(x: +Number, y: +Number, tileblock: +Array, layer: +Number)"
        },
        "widthInPixels": {
          "!doc": "The width of the map in pixels based on width * tileWidth.",
          "!type": "+Number"
        },
        "imagecollections": {
          "!doc": "An array of Image Collections.",
          "!type": "+Array"
        },
        "layer": {
          "!doc": "The current layer object.",
          "!type": "+Number"
        },
        "random": {
          "!doc": "Randomises a set of tiles in a given area.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, layer: +Number)"
        },
        "heightInPixels": {
          "!doc": "The height of the map in pixels based on height * tileHeight.",
          "!type": "+Number"
        },
        "getTilesetIndex": {
          "!doc": "Gets the tileset index based on its name.",
          "!type": "fn(name: +String) -> +Number"
        },
        "setCollisionBetween": {
          "!doc": "Sets collision on a range of tiles where the tile IDs increment sequentially.\nCalling this with a start value of 10 and a stop value of 14 would set collision for tiles 10, 11, 12, 13 and 14.\nThe `collides` parameter controls if collision will be enabled (true) or disabled (false).",
          "!type": "fn(start: +Number, stop: +Number, collides: +Boolean, layer: +Number, recalculate: +Boolean)"
        },
        "setCollisionByExclusion": {
          "!doc": "Sets collision on all tiles in the given layer, except for the IDs of those in the given array.\nThe `collides` parameter controls if collision will be enabled (true) or disabled (false).",
          "!type": "fn(indexes: +Array, collides: +Boolean, layer: +Number, recalculate: +Boolean)"
        },
        "getLayerIndex": {
          "!doc": "Gets the layer index based on its name.",
          "!type": "fn(name: +String) -> +Number"
        },
        "setTileSize": {
          "!doc": "Sets the base tile size for the map.",
          "!type": "fn(tileWidth: +Number, tileHeight: +Number)"
        },
        "copy": {
          "!doc": "Copies all of the tiles in the given rectangular block into the tilemap data buffer.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, layer: +Number) -> +Array"
        },
        "dump": {
          "!doc": "Dumps the tilemap data out to the console.",
          "!type": "fn()"
        },
        "getTileAbove": {
          "!doc": "Gets the tile above the tile coordinates given.\nMostly used as an internal function by calculateFaces.",
          "!type": "fn(layer: +Number, x: +Number, y: +Number)"
        },
        "key": {
          "!doc": "The key of this map data in the Phaser.Cache.",
          "!type": "+String"
        },
        "hasTile": {
          "!doc": "Checks if there is a tile at the given location.",
          "!type": "fn(x: +Number, y: +Number, layer: +Number) -> +Boolean"
        },
        "orientation": {
          "!doc": "The orientation of the map data (as specified in Tiled), usually 'orthogonal'.",
          "!type": "+String"
        },
        "forEach": {
          "!doc": "For each tile in the given area defined by x/y and width/height run the given callback.",
          "!type": "fn(callback: +Number, context: +Number, x: +Number, y: +Number, width: +Number, height: +Number, layer: +Number)"
        },
        "searchTileIndex": {
          "!doc": "Searches the entire map layer for the first tile matching the given index, then returns that Phaser.Tile object.\nIf no match is found it returns null.\nThe search starts from the top-left tile and continues horizontally until it hits the end of the row, then it drops down to the next column.\nIf the reverse boolean is true, it scans starting from the bottom-right corner traveling up to the top-left.",
          "!type": "fn(index: +Number, skip: +Number, reverse: +Number, layer: +Number) -> +Phaser.Tile"
        },
        "tileWidth": {
          "!doc": "The base width of the tiles in the map (in pixels).",
          "!type": "+Number"
        },
        "width": {
          "!doc": "The width of the map (in tiles).",
          "!type": "+Number"
        },
        "tilesets": {
          "!doc": "An array of Tilesets.",
          "!type": "+Array"
        },
        "getTileBelow": {
          "!doc": "Gets the tile below the tile coordinates given.\nMostly used as an internal function by calculateFaces.",
          "!type": "fn(layer: +Number, x: +Number, y: +Number)"
        },
        "shuffle": {
          "!doc": "Shuffles a set of tiles in a given area. It will only randomise the tiles in that area, so if they're all the same nothing will appear to have changed!",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, layer: +Number)"
        },
        "properties": {
          "!doc": "Map specific properties as specified in Tiled.",
          "!type": "+Object"
        }
      }
    },
    "CREATURE": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Stage": {
      "!doc": "The Stage controls root level display objects upon which everything is displayed.\nIt also handles browser visibility handling and the pausing due to loss of focus.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "currentRenderOrderID": {
          "!doc": "Reset each frame, keeps a count of the total number of objects updated.",
          "!type": "+Number"
        },
        "update": {
          "!doc": "This is called automatically after the State.update, but before particles or plugins update.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "checkVisibility": {
          "!doc": "Starts a page visibility event listener running, or window.onpagehide/onpageshow if not supported by the browser.\nAlso listens for window.onblur and window.onfocus.",
          "!type": "fn()"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "backgroundColor": {
          "!doc": "Gets and sets the background color of the stage. The color can be given as a number: 0xff0000 or a hex string: '#ff0000'",
          "!type": "+Number"
        },
        "setBackgroundColor": {
          "!doc": "Sets the background color for the Stage.\n\nThe color can be given as a hex string (`'#RRGGBB'`), a CSS color string (`'rgb(r,g,b)'`), or a numeric value (`0xRRGGBB`).\n\nAn alpha channel is _not_ supported and will be ignored.\n\nIf you've set your game to be transparent then calls to setBackgroundColor are ignored.",
          "!type": "fn(color: +Number)"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "postUpdate": {
          "!doc": "This is called automatically before the renderer runs and after the plugins have updated.\nIn postUpdate this is where all the final physics calculations and object positioning happens.\nThe objects are processed in the order of the display list.\nThe only exception to this is if the camera is following an object, in which case that is updated first.",
          "!type": "fn()"
        },
        "smoothed": {
          "!doc": "Set to true to smooth all sprites rendered on this Stage, or false to disable smoothing (great for pixel art)",
          "!type": "+Boolean"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "parseConfig": {
          "!doc": "Parses a Game configuration object.",
          "!type": "fn(config: +Object)"
        },
        "destroy": {
          "!doc": "Destroys the Stage and removes event listeners.",
          "!type": "fn()"
        },
        "visibilityChange": {
          "!doc": "This method is called when the document visibility is changed.",
          "!type": "fn(event: +Event)"
        },
        "disableVisibilityChange": {
          "!doc": "By default if the browser tab loses focus the game will pause.\nYou can stop that behavior by setting this property to true.\nNote that the browser can still elect to pause your game if it wishes to do so,\nfor example swapping to another browser tab. This will cause the RAF callback to halt,\neffectively pausing your game, even though no in-game pause event is triggered if you enable this property.",
          "!type": "+Boolean"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "name": {
          "!doc": "The name of this object.",
          "!type": "+String"
        },
        "exists": {
          "!doc": "If exists is true the Stage and all children are updated, otherwise it is skipped.",
          "!type": "+Boolean"
        },
        "updateTransform": {
          "!doc": "Updates the transforms for all objects on the display list.\nThis overrides the Pixi default as we don't need the interactionManager, but do need the game property check.",
          "!type": "fn()"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "preUpdate": {
          "!doc": "This is called automatically after the plugins preUpdate and before the State.update.\nMost objects have preUpdate methods and it's where initial movement and positioning is done.",
          "!type": "fn()"
        }
      }
    },
    "TimerEvent": {
      "!doc": "A TimerEvent is a single event that is processed by a Phaser.Timer.\n\nIt consists of a delay, which is a value in milliseconds after which the event will fire.\nWhen the event fires it calls a specific callback with the specified arguments.\n\nUse {@link Phaser.Timer#add}, {@link Phaser.Timer#repeat}, or {@link Phaser.Timer#loop} methods to create a new event.",
      "!type": "fn(timer: +Phaser.Timer, delay: +Number, tick: +Number, repeatCount: +Number, loop: +Boolean, callback: +Function, callbackContext: +Object, arguments: +Array._any_)",
      "prototype": {
        "timer": {
          "!doc": "The Timer object that this TimerEvent belongs to.",
          "!type": "+Phaser.Timer"
        },
        "delay": {
          "!doc": "The delay in ms at which this TimerEvent fires.",
          "!type": "+Number"
        },
        "loop": {
          "!doc": "True if this TimerEvent loops, otherwise false.",
          "!type": "+Boolean"
        },
        "callback": {
          "!doc": "The callback that will be called when the TimerEvent occurs.",
          "!type": "+Function"
        },
        "callbackContext": {
          "!doc": "The context in which the callback will be called.",
          "!type": "+Object"
        },
        "arguments": {
          "!doc": "Additional arguments to be passed to the callback.",
          "!type": "+Array._any_"
        },
        "tick": {
          "!doc": "The tick is the next game clock time that this event will fire at.",
          "!type": "+Number"
        },
        "pendingDelete": {
          "!doc": "A flag that controls if the TimerEvent is pending deletion.",
          "!type": "+Boolean"
        },
        "repeatCount": {
          "!doc": "If this TimerEvent repeats it will do so this many times.",
          "!type": "+Number"
        }
      }
    },
    "NONE": {
      "!doc": "Direction constant.",
      "!type": "+Number"
    },
    "ROUNDEDRECTANGLE": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "DOM": {
      "!doc": "DOM utility class.\n\nProvides a useful Window and Element functions as well as cross-browser compatibility buffer.\n\nSome code originally derived from {@link https://github.com/ryanve/verge verge}.\nSome parts were inspired by the research of Ryan Van Etten, released under MIT License 2013.",
      "getOffset": {
        "!doc": "Get the [absolute] position of the element relative to the Document.\n\nThe value may vary slightly as the page is scrolled due to rounding errors.",
        "!type": "fn(element: +DOMElement, point: +Phaser.Point) -> +Phaser.Point"
      },
      "documentBounds": {
        "!doc": "The size of the document / Layout viewport.\n\nThis incorrectly reports the dimensions in IE.\n\nThe properties change dynamically.",
        "!type": "+Object"
      },
      "getScreenOrientation": {
        "!doc": "Returns the device screen orientation.\n\nOrientation values: 'portrait-primary', 'landscape-primary', 'portrait-secondary', 'landscape-secondary'.\n\nOrder of resolving:\n- Screen Orientation API, or variation of - Future track. Most desktop and mobile browsers.\n- Screen size ratio check - If fallback is 'screen', suited for desktops.\n- Viewport size ratio check - If fallback is 'viewport', suited for mobile.\n- window.orientation - If fallback is 'window.orientation', works iOS and probably most Android; non-recommended track.\n- Media query\n- Viewport size ratio check (probably only IE9 and legacy mobile gets here..)\n\nSee\n- https://w3c.github.io/screen-orientation/ (conflicts with mozOrientation/msOrientation)\n- https://developer.mozilla.org/en-US/docs/Web/API/Screen.orientation (mozOrientation)\n- http://msdn.microsoft.com/en-us/library/ie/dn342934(v=vs.85).aspx\n- https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Testing_media_queries\n- http://stackoverflow.com/questions/4917664/detect-viewport-orientation\n- http://www.matthewgifford.com/blog/2011/12/22/a-misconception-about-window-orientation",
        "!type": "fn(primaryFallback: +String)"
      },
      "visualBounds": {
        "!doc": "The bounds of the Visual viewport, as discussed in \n{@link http://www.quirksmode.org/mobile/viewports.html A tale of two viewports \u20ac\u201d part one}\nwith one difference: the viewport size _excludes_ scrollbars, as found on some desktop browsers.   \n\nSupported mobile:\n  iOS/Safari, Android 4, IE10, Firefox OS (maybe not Firefox Android), Opera Mobile 16\n\nThe properties change dynamically.",
        "!type": "+Object"
      },
      "prototype": {
        "layoutBounds": {
          "!doc": "The bounds of the Layout viewport, as discussed in \n{@link http://www.quirksmode.org/mobile/viewports2.html A tale of two viewports \u20ac\u201d part two};\nbut honoring the constraints as specified applicable viewport meta-tag.\n\nThe bounds returned are not guaranteed to be fully aligned with CSS media queries (see\n{@link http://www.matanich.com/2013/01/07/viewport-size/ What size is my viewport?}).\n\nThis is _not_ representative of the Visual bounds: in particular the non-primary axis will\ngenerally be significantly larger than the screen height on mobile devices when running with a\nconstrained viewport.\n\nThe properties change dynamically.",
          "!type": "+Object"
        },
        "documentBounds": {
          "!doc": "The size of the document / Layout viewport.\n\nThis incorrectly reports the dimensions in IE.\n\nThe properties change dynamically.",
          "!type": "+Object"
        },
        "scrollY": {
          "!doc": "A cross-browser window.scrollY.",
          "!type": "+Number"
        },
        "visualBounds": {
          "!doc": "The bounds of the Visual viewport, as discussed in \n{@link http://www.quirksmode.org/mobile/viewports.html A tale of two viewports \u20ac\u201d part one}\nwith one difference: the viewport size _excludes_ scrollbars, as found on some desktop browsers.   \n\nSupported mobile:\n  iOS/Safari, Android 4, IE10, Firefox OS (maybe not Firefox Android), Opera Mobile 16\n\nThe properties change dynamically.",
          "!type": "+Object"
        },
        "scrollX": {
          "!doc": "A cross-browser window.scrollX.",
          "!type": "+Number"
        }
      },
      "getBounds": {
        "!doc": "A cross-browser element.getBoundingClientRect method with optional cushion.\n\nReturns a plain object containing the properties `top/bottom/left/right/width/height` with respect to the top-left corner of the current viewport.\nIts properties match the native rectangle.\nThe cushion parameter is an amount of pixels (+/-) to cushion the element.\nIt adjusts the measurements such that it is possible to detect when an element is near the viewport.",
        "!type": "fn(element: +DOMElement, cushion: +Number) -> +Object"
      },
      "inLayoutViewport": {
        "!doc": "Tests if the given DOM element is within the Layout viewport.\n\nThe optional cushion parameter allows you to specify a distance.\n\ninLayoutViewport(element, 100) is `true` if the element is in the viewport or 100px near it.\ninLayoutViewport(element, -100) is `true` if the element is in the viewport or at least 100px near it.",
        "!type": "fn(element: +DOMElement, cushion: +Number) -> +Boolean"
      },
      "getAspectRatio": {
        "!doc": "Get the Visual viewport aspect ratio (or the aspect ratio of an object or element)",
        "!type": "fn(object: +DOMElement) -> +Number"
      },
      "layoutBounds": {
        "!doc": "The bounds of the Layout viewport, as discussed in \n{@link http://www.quirksmode.org/mobile/viewports2.html A tale of two viewports \u20ac\u201d part two};\nbut honoring the constraints as specified applicable viewport meta-tag.\n\nThe bounds returned are not guaranteed to be fully aligned with CSS media queries (see\n{@link http://www.matanich.com/2013/01/07/viewport-size/ What size is my viewport?}).\n\nThis is _not_ representative of the Visual bounds: in particular the non-primary axis will\ngenerally be significantly larger than the screen height on mobile devices when running with a\nconstrained viewport.\n\nThe properties change dynamically.",
        "!type": "+Object"
      },
      "scrollY": {
        "!doc": "A cross-browser window.scrollY.",
        "!type": "+Number"
      },
      "!type": "fn()",
      "scrollX": {
        "!doc": "A cross-browser window.scrollX.",
        "!type": "+Number"
      }
    },
    "LEFT": {
      "!doc": "Direction constant.",
      "!type": "+Number"
    },
    "Sound": {
      "!doc": "The Sound class constructor.",
      "!type": "fn(game: +Phaser.Game, key: +String, volume: +Number, loop: +Boolean)",
      "prototype": {
        "play": {
          "!doc": "Play this sound, or a marked section of it.",
          "!type": "fn(marker: +String, position: +Number, volume: +Number, loop: +Boolean, forceRestart: +Boolean) -> +Phaser.Sound"
        },
        "paused": {
          "!doc": "true if the sound is paused, otherwise false.",
          "!type": "+Boolean"
        },
        "fadeTo": {
          "!doc": "Fades the volume of this Sound from its current value to the given volume over the duration specified.\nAt the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter, \nand the final volume (volume) as the second parameter.",
          "!type": "fn(duration: +Number, volume: +Number)"
        },
        "onMute": {
          "!doc": "The onMouse event is dispatched when this sound is muted.",
          "!type": "+Phaser.Signal"
        },
        "removeMarker": {
          "!doc": "Removes a marker from the sound.",
          "!type": "fn(name: +String)"
        },
        "externalNode": {
          "!doc": "If defined this Sound won't connect to the SoundManager master gain node, but will instead connect to externalNode.",
          "!type": "+Object"
        },
        "usingAudioTag": {
          "!doc": "true if the sound is being played via the Audio tag.",
          "!type": "+Boolean"
        },
        "gainNode": {
          "!doc": "The gain node in a Web Audio system.",
          "!type": "+Object"
        },
        "loop": {
          "!doc": "Whether or not the sound or current sound marker will loop.",
          "!type": "+Boolean"
        },
        "context": {
          "!doc": "Reference to the AudioContext instance.",
          "!type": "+AudioContext"
        },
        "onStop": {
          "!doc": "The onStop event is dispatched when this sound stops playback.",
          "!type": "+Phaser.Signal"
        },
        "updateGlobalVolume": {
          "!doc": "Called automatically by SoundManager.volume.\n\nSets the volume of AudioTag Sounds as a percentage of the Global Volume.\n\nYou should not normally call this directly.",
          "!type": "fn(globalVolume: +float)"
        },
        "totalDuration": {
          "!doc": "The total duration of the sound in seconds.",
          "!type": "+Number"
        },
        "isPlaying": {
          "!doc": "true if the sound is currently playing, otherwise false.",
          "!type": "+Boolean"
        },
        "pendingPlayback": {
          "!doc": "true if the sound file is pending playback",
          "!type": "+Boolean"
        },
        "masterGainNode": {
          "!doc": "The master gain node in a Web Audio system.",
          "!type": "+Object"
        },
        "destroy": {
          "!doc": "Destroys this sound and all associated events and removes it from the SoundManager.",
          "!type": "fn(remove: +Boolean)"
        },
        "mute": {
          "!doc": "Gets or sets the muted state of this sound.",
          "!type": "+Boolean"
        },
        "onPlay": {
          "!doc": "The onPlay event is dispatched each time this sound is played.",
          "!type": "+Phaser.Signal"
        },
        "pause": {
          "!doc": "Pauses the sound.",
          "!type": "fn()"
        },
        "autoplay": {
          "!doc": "Boolean indicating whether the sound should start automatically.",
          "!type": "+Boolean"
        },
        "onResume": {
          "!doc": "The onResume event is dispatched when this sound is resumed from a paused state.",
          "!type": "+Phaser.Signal"
        },
        "volume": {
          "!doc": "The sound or sound marker volume. A value between 0 (silence) and 1 (full volume).",
          "!type": "+Number"
        },
        "currentTime": {
          "!doc": "The current time the sound is at.",
          "!type": "+Number"
        },
        "stop": {
          "!doc": "Stop playing this sound.",
          "!type": "fn()"
        },
        "name": {
          "!doc": "Name of the sound.",
          "!type": "+String"
        },
        "position": {
          "!doc": "The position of the current sound marker.",
          "!type": "+Number"
        },
        "onLoop": {
          "!doc": "The onLoop event is dispatched when this sound loops during playback.",
          "!type": "+Phaser.Signal"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "onDecoded": {
          "!doc": "The onDecoded event is dispatched when the sound has finished decoding (typically for mp3 files)",
          "!type": "+Phaser.Signal"
        },
        "fadeOut": {
          "!doc": "Decreases the volume of this Sound from its current value to 0 over the duration specified.\nAt the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter,\nand the final volume (0) as the second parameter.",
          "!type": "fn(duration: +Number)"
        },
        "isDecoding": {
          "!doc": "Returns true if the sound file is still decoding.",
          "!type": "+Boolean"
        },
        "update": {
          "!doc": "Called automatically by Phaser.SoundManager.",
          "!type": "fn()"
        },
        "onPause": {
          "!doc": "The onPause event is dispatched when this sound is paused.",
          "!type": "+Phaser.Signal"
        },
        "pausedPosition": {
          "!doc": "The position the sound had reached when it was paused.",
          "!type": "+Number"
        },
        "isDecoded": {
          "!doc": "Returns true if the sound file has decoded.",
          "!type": "+Boolean"
        },
        "duration": {
          "!doc": "The duration of the current sound marker in seconds.",
          "!type": "+Number"
        },
        "fadeIn": {
          "!doc": "Starts this sound playing (or restarts it if already doing so) and sets the volume to zero.\nThen increases the volume from 0 to 1 over the duration specified.\n\nAt the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter,\nand the final volume (1) as the second parameter.",
          "!type": "fn(duration: +Number, loop: +Boolean, marker: +String)"
        },
        "onFadeComplete": {
          "!doc": "The onFadeComplete event is dispatched when this sound finishes fading either in or out.",
          "!type": "+Phaser.Signal"
        },
        "startTime": {
          "!doc": "The time the Sound starts at (typically 0 unless starting from a marker)",
          "!type": "+Number"
        },
        "stopTime": {
          "!doc": "The time the sound stopped.",
          "!type": "+Number"
        },
        "loopFull": {
          "!doc": "Loops this entire sound. If you need to loop a section of it then use Sound.play and the marker and loop parameters.",
          "!type": "fn(volume: +Number) -> +Phaser.Sound"
        },
        "override": {
          "!doc": "if true when you play this sound it will always start from the beginning.",
          "!type": "+Boolean"
        },
        "durationMS": {
          "!doc": "The duration of the current sound marker in ms.",
          "!type": "+Number"
        },
        "key": {
          "!doc": "Asset key for the sound.",
          "!type": "+String"
        },
        "resume": {
          "!doc": "Resumes the sound.",
          "!type": "fn()"
        },
        "restart": {
          "!doc": "Restart the sound, or a marked section of it.",
          "!type": "fn(marker: +String, position: +Number, volume: +Number, loop: +Boolean)"
        },
        "onEndedHandler": {
          "!doc": "Called automatically by the AudioContext when the sound stops playing.\nDoesn't get called if the sound is set to loop or is a section of an Audio Sprite.",
          "!type": "fn()"
        },
        "soundHasUnlocked": {
          "!doc": "Called automatically when this sound is unlocked.",
          "!type": "fn(key: +String)"
        },
        "pausedTime": {
          "!doc": "The game time at which the sound was paused.",
          "!type": "+Number"
        },
        "usingWebAudio": {
          "!doc": "true if this sound is being played with Web Audio.",
          "!type": "+Boolean"
        },
        "allowMultiple": {
          "!doc": "This will allow you to have multiple instances of this Sound playing at once. This is only useful when running under Web Audio, and we recommend you implement a local pooling system to not flood the sound channels.",
          "!type": "+Boolean"
        },
        "onMarkerComplete": {
          "!doc": "The onMarkerComplete event is dispatched when a marker within this sound completes playback.",
          "!type": "+Phaser.Signal"
        },
        "fadeTween": {
          "!doc": "The tween that fades the audio, set via Sound.fadeIn and Sound.fadeOut.",
          "!type": "+Phaser.Tween"
        },
        "markers": {
          "!doc": "The sound markers.",
          "!type": "+Object"
        },
        "currentMarker": {
          "!doc": "The string ID of the currently playing marker, if any.",
          "!type": "+String"
        },
        "addMarker": {
          "!doc": "Adds a marker into the current Sound. A marker is represented by a unique key and a start time and duration.\nThis allows you to bundle multiple sounds together into a single audio file and use markers to jump between them for playback.",
          "!type": "fn(name: +String, start: +Number, duration: +Number, volume: +Number, loop: +Boolean)"
        }
      }
    },
    "GRAPHICS": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Line": {
      "!doc": "Creates a new Line object with a start and an end point.",
      "!type": "fn(x1: +Number, y1: +Number, x2: +Number, y2: +Number)",
      "intersectsPoints": {
        "!doc": "Checks for intersection between two lines as defined by the given start and end points.\nIf asSegment is true it will check for line segment intersection. If asSegment is false it will check for line intersection.\nReturns the intersection segment of AB and EF as a Point, or null if there is no intersection.\nAdapted from code by Keith Hair",
        "!type": "fn(a: +Phaser.Point, b: +Phaser.Point, e: +Phaser.Point, f: +Phaser.Point, asSegment: +Boolean, result: +Phaser.Point) -> +Phaser.Point"
      },
      "prototype": {
        "rotate": {
          "!doc": "Rotates the line by the amount specified in `angle`.\n\nRotation takes place from the center of the line.\nIf you wish to rotate around a different point see Line.rotateAround.\n\nIf you wish to rotate the ends of the Line then see Line.start.rotate or Line.end.rotate.",
          "!type": "fn(angle: +Number, asDegrees: +Boolean) -> +Phaser.Line"
        },
        "normalX": {
          "!doc": "Gets the x component of the left-hand normal of this line.",
          "!type": "+Number"
        },
        "normalY": {
          "!doc": "Gets the y component of the left-hand normal of this line.",
          "!type": "+Number"
        },
        "intersects": {
          "!doc": "Checks for intersection between this line and another Line.\nIf asSegment is true it will check for segment intersection. If asSegment is false it will check for line intersection.\nReturns the intersection segment of AB and EF as a Point, or null if there is no intersection.",
          "!type": "fn(line: +Phaser.Line, asSegment: +Boolean, result: +Phaser.Point) -> +Phaser.Point"
        },
        "perpSlope": {
          "!doc": "Gets the perpendicular slope of the line (x/y).",
          "!type": "+Number"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "coordinatesOnLine": {
          "!doc": "Using Bresenham's line algorithm this will return an array of all coordinates on this line.\nThe start and end points are rounded before this runs as the algorithm works on integers.",
          "!type": "fn(stepRate: +Number, results: +Array) -> +Array"
        },
        "random": {
          "!doc": "Picks a random point from anywhere on the Line segment and returns it.",
          "!type": "fn(out: +Phaser.Point) -> +Phaser.Point"
        },
        "reflect": {
          "!doc": "Returns the reflected angle between two lines.\nThis is the outgoing angle based on the angle of this line and the normalAngle of the given line.",
          "!type": "fn(line: +Phaser.Line) -> +Number"
        },
        "top": {
          "!doc": "Gets the top-most point of this line.",
          "!type": "+Number"
        },
        "pointOnSegment": {
          "!doc": "Tests if the given coordinates fall on this line and within the segment. See pointOnLine to test against just the line.",
          "!type": "fn(x: +Number, y: +Number) -> +Boolean"
        },
        "angle": {
          "!doc": "Gets the angle of the line in radians.",
          "!type": "+Number"
        },
        "end": {
          "!doc": "The end point of the line.",
          "!type": "+Phaser.Point"
        },
        "height": {
          "!doc": "Gets the height of this bounds of this line.",
          "!type": "+Number"
        },
        "centerOn": {
          "!doc": "Centers this Line on the given coordinates.\n\nThe line is centered by positioning the start and end points so that the lines midpoint matches\nthe coordinates given.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Line"
        },
        "midPoint": {
          "!doc": "Returns a Point object where the x and y values correspond to the center (or midpoint) of the Line segment.",
          "!type": "fn(out: +Phaser.Point) -> +Phaser.Point"
        },
        "bottom": {
          "!doc": "Gets the bottom-most point of this line.",
          "!type": "+Number"
        },
        "fromSprite": {
          "!doc": "Sets the line to match the x/y coordinates of the two given sprites.\nCan optionally be calculated from their center coordinates.",
          "!type": "fn(startSprite: +Phaser.Sprite, endSprite: +Phaser.Sprite, useCenter: +Boolean) -> +Phaser.Line"
        },
        "start": {
          "!doc": "The start point of the line.",
          "!type": "+Phaser.Point"
        },
        "length": {
          "!doc": "Gets the length of the line segment.",
          "!type": "+Number"
        },
        "normalAngle": {
          "!doc": "Gets the angle in radians of the normal of this line (line.angle - 90 degrees.)",
          "!type": "+Number"
        },
        "right": {
          "!doc": "Gets the right-most point of this line.",
          "!type": "+Number"
        },
        "fromAngle": {
          "!doc": "Sets this line to start at the given `x` and `y` coordinates and for the segment to extend at `angle` for the given `length`.",
          "!type": "fn(x: +Number, y: +Number, angle: +Number, length: +Number) -> +Phaser.Line"
        },
        "slope": {
          "!doc": "Gets the slope of the line (y/x).",
          "!type": "+Number"
        },
        "pointOnLine": {
          "!doc": "Tests if the given coordinates fall on this line. See pointOnSegment to test against just the line segment.",
          "!type": "fn(x: +Number, y: +Number) -> +Boolean"
        },
        "rotateAround": {
          "!doc": "Rotates the line by the amount specified in `angle`.\n\nRotation takes place around the coordinates given.",
          "!type": "fn(x: +Number, y: +Number, angle: +Number, asDegrees: +Boolean) -> +Phaser.Line"
        },
        "left": {
          "!doc": "Gets the left-most point of this line.",
          "!type": "+Number"
        },
        "clone": {
          "!doc": "Returns a new Line object with the same values for the start and end properties as this Line object.",
          "!type": "fn(output: +Phaser.Line) -> +Phaser.Line"
        },
        "x": {
          "!doc": "Gets the x coordinate of the top left of the bounds around this line.",
          "!type": "+Number"
        },
        "width": {
          "!doc": "Gets the width of this bounds of this line.",
          "!type": "+Number"
        },
        "setTo": {
          "!doc": "Sets the components of the Line to the specified values.",
          "!type": "fn(x1: +Number, y1: +Number, x2: +Number, y2: +Number) -> +Phaser.Line"
        },
        "y": {
          "!doc": "Gets the y coordinate of the top left of the bounds around this line.",
          "!type": "+Number"
        }
      }
    },
    "SPRITEBATCH": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "TileSprite": {
      "init": {
        "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
        "!type": "fn()"
      },
      "install": {
        "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
        "!type": "fn()"
      },
      "!doc": "A TileSprite is a Sprite that has a repeating texture. The texture can be scrolled and scaled independently of the TileSprite itself.\nTextures will automatically wrap and are designed so that you can create game backdrops using seamless textures as a source.\n\nTileSprites have no input handler or physics bodies by default, both need enabling in the same way as for normal Sprites.\n\nYou shouldn't ever create a TileSprite any larger than your actual screen size. If you want to create a large repeating background\nthat scrolls across the whole map of your game, then you create a TileSprite that fits the screen size and then use the `tilePosition`\nproperty to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will \nconsume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to\nadjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.\n\nAn important note about texture dimensions:\n\nWhen running under Canvas a TileSprite can use any texture size without issue. When running under WebGL the texture should ideally be\na power of two in size (i.e. 4, 8, 16, 32, 64, 128, 256, 512, etch pixels width by height). If the texture isn't a power of two\nit will be rendered to a blank canvas that is the correct size, which means you may have 'blank' areas appearing to the right and\nbottom of your frame. To avoid this ensure your textures are perfect powers of two.\n\nTileSprites support animations in the same way that Sprites do. You add and play animations using the AnimationManager. However\nif your game is running under WebGL please note that each frame of the animation must be a power of two in size, or it will receive\nadditional padding to enforce it to be so.",
      "!type": "fn(game: +Phaser.Game, x: +Number, y: +Number, width: +Number, height: +Number, key: +String, frame: +String)",
      "prototype": {
        "play": {
          "!doc": "Plays an Animation.\n\nThe animation should have previously been created via `animations.add`.\n\nIf the animation is already playing calling this again won't do anything.\nIf you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.",
          "!type": "fn(name: +String, frameRate: +Number, loop: +Boolean, killOnComplete: +Boolean) -> +Phaser.Animation"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "lifespan": {
          "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
          "!type": "+Number"
        },
        "outOfBoundsKill": {
          "!doc": "If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.",
          "!type": "+Boolean"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "resizeFrame": {
          "!doc": "Resizes the Frame dimensions that the Game Object uses for rendering.\n\nYou shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData\nit can be useful to adjust the dimensions directly in this way.",
          "!type": "fn(parent: +Object, width: +Number, height: +Number)"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "maxHealth": {
          "!doc": "The Game Objects maximum health value. This works in combination with the `heal` method to ensure\nthe health value never exceeds the maximum.",
          "!type": "+Number"
        },
        "revive": {
          "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
          "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
        },
        "autoScroll": {
          "!doc": "Sets this TileSprite to automatically scroll in the given direction until stopped via TileSprite.stopScroll().\nThe scroll speed is specified in pixels per second.\nA negative x value will scroll to the left. A positive x value will scroll to the right.\nA negative y value will scroll up. A positive y value will scroll down.",
          "!type": "fn(x: +Number, y: +Number)"
        },
        "bringToTop": {
          "!doc": "Brings this Game Object to the top of its parents display list.\nVisually this means it will render over the top of any old child in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "events": {
          "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
          "!type": "+Phaser.Events"
        },
        "moveUp": {
          "!doc": "Moves this Game Object up one place in its parents display list.\nThis call has no effect if the Game Object is already at the top of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "height": {
          "!doc": "The height of the tiling sprite",
          "!type": "+Number"
        },
        "postUpdate": {
          "!doc": "Internal method called by the World postUpdate cycle.",
          "!type": "fn()"
        },
        "textureDebug": {
          "!doc": "If enabled a green rectangle will be drawn behind the generated tiling texture, allowing you to visually\ndebug the texture being used.",
          "!type": "+Boolean"
        },
        "smoothed": {
          "!doc": "Enable or disable texture smoothing for this Game Object.\n\nIt only takes effect if the Game Object is using an image based texture.\n\nSmoothing is enabled by default.",
          "!type": "+Boolean"
        },
        "destroy": {
          "!doc": "Destroys the TileSprite. This removes it from its parent group, destroys the event and animation handlers if present\nand nulls its reference to game, freeing it up for garbage collection.",
          "!type": "fn(destroyChildren: +Boolean)"
        },
        "input": {
          "!doc": "The Input Handler for this Game Object.\n\nBy default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.\n\nAfter you have done this, this property will be a reference to the Phaser InputHandler.",
          "!type": "+Phaser.InputHandler"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "left": {
          "!doc": "The left coordinate of the Game Object.\nThis is the same as `x - offsetX`.",
          "!type": "+Number"
        },
        "reset": {
          "!doc": "Resets the TileSprite. This places the TileSprite at the given x/y world coordinates, resets the tilePosition and then\nsets alive, exists, visible and renderable all to true. Also resets the outOfBounds state.\nIf the TileSprite has a physics body that too is reset.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.TileSprite"
        },
        "refreshTexture": {
          "!doc": "If true the TilingSprite will run generateTexture on its **next** render pass.\nThis is set by the likes of Phaser.LoadTexture.setFrame.",
          "!type": "+Boolean"
        },
        "preUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn()"
        },
        "tilingTexture": {
          "!doc": "An internal Texture object that holds the tiling texture that was generated from TilingSprite.texture.",
          "!type": "+PIXI.Texture"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "damage": {
          "!doc": "Damages the Game Object. This removes the given amount of health from the `health` property.\n\nIf health is taken below or is equal to zero then the `kill` method is called.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "components": {
          "!doc": "The components this Game Object has installed.",
          "!type": "+Object"
        },
        "tileScaleOffset": {
          "!doc": "A point that represents the scale of the texture object",
          "!type": "+Phaser.Point"
        },
        "tilePosition": {
          "!doc": "The offset position of the image that is being tiled",
          "!type": "+Phaser.Point"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
          "!type": "+Boolean"
        },
        "inWorld": {
          "!doc": "Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.",
          "!type": "+Boolean"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "world": {
          "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
          "!type": "+Phaser.Point"
        },
        "top": {
          "!doc": "The y coordinate of the Game Object.\nThis is the same as `y - offsetY`.",
          "!type": "+Number"
        },
        "angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        },
        "checkWorldBounds": {
          "!doc": "If this is set to `true` the Game Object checks if it is within the World bounds each frame. \n\nWhen it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.\n\nIf it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.\n\nIt also optionally kills the Game Object if `outOfBoundsKill` is `true`.\n\nWhen `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "key": {
          "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
          "!type": "+String"
        },
        "texture": {
          "!doc": "The texture that the sprite is using",
          "!type": "+Texture"
        },
        "health": {
          "!doc": "The Game Objects health value. This is a handy property for setting and manipulating health on a Game Object.\n\nIt can be used in combination with the `damage` method or modified directly.",
          "!type": "+Number"
        },
        "outOfCameraBoundsKill": {
          "!doc": "If this and the `autoCull` property are both set to `true`, then the `kill` method\nis called as soon as the Game Object leaves the camera bounds.",
          "!type": "+Boolean"
        },
        "destroyPhase": {
          "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
          "!type": "+Boolean"
        },
        "right": {
          "!doc": "The right coordinate of the Game Object.\nThis is the same as `x + width - offsetX`.",
          "!type": "+Number"
        },
        "kill": {
          "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousPosition": {
          "!doc": "The position the Game Object was located in the previous frame.",
          "!type": "+Phaser.Point"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "anchor": {
          "!doc": "The anchor sets the origin point of the texture.\nThe default is 0,0 this means the texture's origin is the top left\nSetting than anchor to 0.5,0.5 means the textures origin is centered\nSetting the anchor to 1,1 would mean the textures origin points will be the bottom right corner",
          "!type": "+Phaser.Point"
        },
        "width": {
          "!doc": "The width of the tiling sprite",
          "!type": "+Number"
        },
        "autoCull": {
          "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The position of the Game Object on the x axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "Controls if this Game Object is processed by the core game loop.\nIf this Game Object has a physics body it also controls if its physics body is updated or not.\nWhen `exists` is set to `false` it will remove its physics body from the physics world if it has one.\nIt also toggles the `visible` property to false as well.\n\nSetting `exists` to true will add its physics body back in to the physics world, if it has one.\nIt will also set the `visible` property to `true`.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The position of the Game Object on the y axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
          "!type": "+Number"
        },
        "tilePattern": {
          "!doc": "The Context fill pattern that is used to draw the TilingSprite in Canvas mode only (will be null in WebGL).",
          "!type": "+PIXI.Texture"
        },
        "body": {
          "!doc": "`body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated \nproperties and methods via it.\n\nBy default Game Objects won't add themselves to any physics system and their `body` property will be `null`.\n\nTo enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object\nand `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.\n\nYou can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.\n\nImportant: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5, \nso the physics body is centered on the Game Object.\n\nIf you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.",
          "!type": "+Phaser.Physics.Arcade.Body"
        },
        "inCamera": {
          "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
          "!type": "+Boolean"
        },
        "offsetX": {
          "!doc": "The amount the Game Object is visually offset from its x coordinate.\nThis is the same as `width * anchor.x`.\nIt will only be > 0 if anchor.x is not equal to zero.",
          "!type": "+Number"
        },
        "tintedTexture": {
          "!doc": "A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)",
          "!type": "+Phaser.Canvas"
        },
        "offsetY": {
          "!doc": "The amount the Game Object is visually offset from its y coordinate.\nThis is the same as `height * anchor.y`.\nIt will only be > 0 if anchor.y is not equal to zero.",
          "!type": "+Number"
        },
        "fixedToCamera": {
          "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
          "!type": "+Boolean"
        },
        "renderOrderID": {
          "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
          "!type": "+Number"
        },
        "previousRotation": {
          "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
          "!type": "+Number"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "tileScale": {
          "!doc": "The scaling of the image that is being tiled",
          "!type": "+Phaser.Point"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.\nThis is the same as `y + height - offsetY`.",
          "!type": "+Number"
        },
        "cameraOffset": {
          "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
          "!type": "+Phaser.Point"
        },
        "moveDown": {
          "!doc": "Moves this Game Object down one place in its parents display list.\nThis call has no effect if the Game Object is already at the bottom of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "overlap": {
          "!doc": "Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object, \nwhich can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.\n\nThis check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.\n\nTherefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.\nIt should be fine for low-volume testing where physics isn't required.",
          "!type": "fn(displayObject: +Phaser.Sprite) -> +Boolean"
        },
        "loadTexture": {
          "!doc": "Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.\n\nIf your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.\n\nYou should only use `loadTexture` if you want to replace the base texture entirely.\n\nCalling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.\n\nYou can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite. \nDoing this then sets the key to be the `frame` argument (the frame is set to zero). \n\nThis allows you to create sprites using `load.image` during development, and then change them \nto use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS' \nand swapping it to be the key of the atlas data.\n\nNote: You cannot use a RenderTexture as a texture for a TileSprite.",
          "!type": "fn(key: +String, frame: +String, stopAnimation: +Boolean)"
        },
        "name": {
          "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
          "!type": "+String"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "frame": {
          "!doc": "Gets or sets the current frame index of the texture being used to render this Game Object.\n\nTo change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,\nfor example: `player.frame = 4`.\n\nIf the frame index given doesn't exist it will revert to the first frame found in the texture.\n\nIf you are using a texture atlas then you should use the `frameName` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+Number"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "shader": {
          "!doc": "The shader that will be used to render the texture to the stage. Set to null to remove a current shader.",
          "!type": "+PIXI.AbstractFilter"
        },
        "renderable": {
          "!doc": "Whether this sprite is renderable or not",
          "!type": "+Boolean"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "stopScroll": {
          "!doc": "Stops an automatically scrolling TileSprite.",
          "!type": "fn()"
        },
        "update": {
          "!doc": "Override this method in your own custom objects to handle any update requirements.\nIt is called immediately after `preUpdate` and before `postUpdate`.\nRemember if this Game Object has any children you should call update on those too.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "canvasBuffer": {
          "!doc": "The CanvasBuffer object that the tiled texture is drawn to.",
          "!type": "+PIXI.CanvasBuffer"
        },
        "tint": {
          "!doc": "The tint applied to the sprite. This is a hex value",
          "!type": "+Number"
        },
        "inputEnabled": {
          "!doc": "By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created\nfor this Game Object and it will then start to process click / touch events and more.\n\nYou can then access the Input Handler via `this.input`.\n\nNote that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.\n\nIf you set this property to false it will stop the Input Handler from processing any more input events.",
          "!type": "+Boolean"
        },
        "setFrame": {
          "!doc": "Sets the texture frame the Game Object uses for rendering.\n\nThis is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.",
          "!type": "fn(frame: +Phaser.Frame)"
        },
        "animations": {
          "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
          "!type": "+Phaser.AnimationManager"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "heal": {
          "!doc": "Heal the Game Object. This adds the given amount of health to the `health` property.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "setHealth": {
          "!doc": "Sets the health property of the Game Object to the given amount.\nWill never exceed the `maxHealth` value.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "debug": {
          "!doc": "A debug flag designed for use with `Game.enableStep`.",
          "!type": "+Boolean"
        },
        "frameName": {
          "!doc": "Gets or sets the current frame name of the texture being used to render this Game Object.\n\nTo change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use, \nfor example: `player.frameName = \"idle\"`.\n\nIf the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.\n\nIf you are using a sprite sheet then you should use the `frame` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+String"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends this Game Object to the bottom of its parents display list.\nVisually this means it will render below all other children in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "resetFrame": {
          "!doc": "Resets the texture frame dimensions that the Game Object uses for rendering.",
          "!type": "fn()"
        },
        "pendingDestroy": {
          "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
          "!type": "+Boolean"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite",
          "!type": "+Number"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "fresh": {
          "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
          "!type": "+Boolean"
        }
      }
    },
    "Game": {
      "!doc": "This is where the magic happens. The Game object is the heart of your game,\nproviding quick access to common functions and handling the boot process.\n\n\"Hell, there are no rules here - we're trying to accomplish something.\"\n                                                      Thomas A. Edison",
      "!type": "fn(width: +Number, height: +Number, renderer: +Number, parent: +String, state: +Object, transparent: +Boolean, antialias: +Boolean, physicsConfig: +Object)",
      "prototype": {
        "gamePaused": {
          "!doc": "Called by the Stage visibility handler.",
          "!type": "fn(event: +Object)"
        },
        "parent": {
          "!doc": "The Games DOM parent.",
          "!type": "+String"
        },
        "paused": {
          "!doc": "Gets and sets the paused state of the Game.",
          "!type": "+Boolean"
        },
        "plugins": {
          "!doc": "Reference to the plugin manager.",
          "!type": "+Phaser.PluginManager"
        },
        "lockRender": {
          "!doc": "If `false` Phaser will automatically render the display list every update. If `true` the render loop will be skipped.\nYou can toggle this value at run-time to gain exact control over when Phaser renders. This can be useful in certain types of game or application.\nPlease note that if you don't render the display list then none of the game object transforms will be updated, so use this value carefully.",
          "!type": "+Boolean"
        },
        "sound": {
          "!doc": "Reference to the sound manager.",
          "!type": "+Phaser.SoundManager"
        },
        "stepping": {
          "!doc": "Enable core loop stepping with Game.enableStep().",
          "!type": "+Boolean"
        },
        "resolution": {
          "!doc": "The resolution of your game. This value is read only, but can be changed at start time it via a game configuration object.",
          "!type": "+Number"
        },
        "clearBeforeRender": {
          "!doc": "Clear the Canvas each frame before rendering the display list.\nYou can set this to `false` to gain some performance if your game always contains a background that completely fills the display.",
          "!type": "+Boolean"
        },
        "focusLoss": {
          "!doc": "Called by the Stage visibility handler.",
          "!type": "fn(event: +Object)"
        },
        "antialias": {
          "!doc": "Anti-alias graphics. By default scaled images are smoothed in Canvas and WebGL, set anti-alias to false to disable this globally.",
          "!type": "+Boolean"
        },
        "raf": {
          "!doc": "Automatically handles the core game loop via requestAnimationFrame or setTimeout",
          "!type": "+Phaser.RequestAnimationFrame"
        },
        "updatesThisFrame": {
          "!doc": "Number of logic updates expected to occur this render frame; will be 1 unless there are catch-ups required (and allowed).",
          "!type": "+Number"
        },
        "context": {
          "!doc": "A handy reference to renderer.context (only set for CANVAS games, not WebGL)",
          "!type": "+CanvasRenderingContext2D"
        },
        "create": {
          "!doc": "The Asset Generator.",
          "!type": "+Phaser.Create"
        },
        "id": {
          "!doc": "Phaser Game ID (for when Pixi supports multiple instances).",
          "!type": "+Number"
        },
        "state": {
          "!doc": "The StateManager.",
          "!type": "+Phaser.StateManager"
        },
        "currentUpdateID": {
          "!doc": "The ID of the current/last logic update applied this render frame, starting from 0.\nThe first update is `currentUpdateID === 0` and the last update is `currentUpdateID === updatesThisFrame.`",
          "!type": "+Number"
        },
        "showDebugHeader": {
          "!doc": "Displays a Phaser version debug header in the console.",
          "!type": "fn()"
        },
        "net": {
          "!doc": "Reference to the network class.",
          "!type": "+Phaser.Net"
        },
        "particles": {
          "!doc": "The Particle Manager.",
          "!type": "+Phaser.Particles"
        },
        "height": {
          "!doc": "The current Game Height in pixels.\n\n_Do not modify this property directly:_ use {@link Phaser.ScaleManager#setGameSize} - eg. `game.scale.setGameSize(width, height)` - instead.",
          "!type": "+Number"
        },
        "add": {
          "!doc": "Reference to the Phaser.GameObjectFactory.",
          "!type": "+Phaser.GameObjectFactory"
        },
        "physicsConfig": {
          "!doc": "The Phaser.Physics.World configuration object.",
          "!type": "+Object"
        },
        "cache": {
          "!doc": "Reference to the assets cache.",
          "!type": "+Phaser.Cache"
        },
        "canvas": {
          "!doc": "A handy reference to renderer.view, the canvas that the game is being rendered in to.",
          "!type": "+HTMLCanvasElement"
        },
        "parseConfig": {
          "!doc": "Parses a Game configuration object.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Nukes the entire game from orbit.",
          "!type": "fn()"
        },
        "rnd": {
          "!doc": "Instance of repeatable random data generator helper.",
          "!type": "+Phaser.RandomDataGenerator"
        },
        "onResume": {
          "!doc": "This event is fired when the game resumes from a paused state.",
          "!type": "+Phaser.Signal"
        },
        "onFocus": {
          "!doc": "This event is fired when the game has focus (typically on page show).",
          "!type": "+Phaser.Signal"
        },
        "input": {
          "!doc": "Reference to the input manager",
          "!type": "+Phaser.Input"
        },
        "fpsProblemNotifier": {
          "!doc": "If the game is struggling to maintain the desired FPS, this signal will be dispatched.\nThe desired/chosen FPS should probably be closer to the {@link Phaser.Time#suggestedFps} value.",
          "!type": "+Phaser.Signal"
        },
        "enableStep": {
          "!doc": "Enable core game loop stepping. When enabled you must call game.step() directly (perhaps via a DOM button?)\nCalling step will advance the game loop by one frame. This is extremely useful for hard to track down errors!",
          "!type": "fn()"
        },
        "math": {
          "!doc": "Reference to the math helper.",
          "!type": "+Phaser.Math"
        },
        "device": {
          "!doc": "Contains device information and capabilities.",
          "!type": "+Phaser.Device"
        },
        "stepCount": {
          "!doc": "When stepping is enabled this contains the current step cycle.",
          "!type": "+Number"
        },
        "setUpRenderer": {
          "!doc": "Checks if the device is capable of using the requested renderer and sets it up or an alternative if not.",
          "!type": "fn()"
        },
        "renderer": {
          "!doc": "The Pixi Renderer.",
          "!type": "+PIXI.CanvasRenderer"
        },
        "tweens": {
          "!doc": "Reference to the tween manager.",
          "!type": "+Phaser.TweenManager"
        },
        "update": {
          "!doc": "The core game loop.",
          "!type": "fn(time: +Number)"
        },
        "scale": {
          "!doc": "The game scale manager.",
          "!type": "+Phaser.ScaleManager"
        },
        "onPause": {
          "!doc": "This event is fired when the game pauses.",
          "!type": "+Phaser.Signal"
        },
        "transparent": {
          "!doc": "Use a transparent canvas background or not.",
          "!type": "+Boolean"
        },
        "world": {
          "!doc": "Reference to the world.",
          "!type": "+Phaser.World"
        },
        "load": {
          "!doc": "Reference to the assets loader.",
          "!type": "+Phaser.Loader"
        },
        "updateRender": {
          "!doc": "Runs the Render cycle.\nIt starts by calling State.preRender. In here you can do any last minute adjustments of display objects as required.\nIt then calls the renderer, which renders the entire display list, starting from the Stage object and working down.\nIt then calls plugin.render on any loaded plugins, in the order in which they were enabled.\nAfter this State.render is called. Any rendering that happens here will take place on-top of the display list.\nFinally plugin.postRender is called on any loaded plugins, in the order in which they were enabled.\nThis method is called automatically by Game.update, you don't need to call it directly.\nShould you wish to have fine-grained control over when Phaser renders then use the `Game.lockRender` boolean.\nPhaser will only render when this boolean is `false`.",
          "!type": "fn(elapsedTime: +Number)"
        },
        "isRunning": {
          "!doc": "Is game running or paused?",
          "!type": "+Boolean"
        },
        "updateLogic": {
          "!doc": "Updates all logic subsystems in Phaser. Called automatically by Game.update.",
          "!type": "fn(timeStep: +Number)"
        },
        "preserveDrawingBuffer": {
          "!doc": "The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.",
          "!type": "+Boolean"
        },
        "physics": {
          "!doc": "Reference to the physics manager.",
          "!type": "+Phaser.Physics"
        },
        "pendingStep": {
          "!doc": "An internal property used by enableStep, but also useful to query from your own game objects.",
          "!type": "+Boolean"
        },
        "boot": {
          "!doc": "Initialize engine sub modules and start the game.",
          "!type": "fn()"
        },
        "renderType": {
          "!doc": "The Renderer this game will use. Either Phaser.AUTO, Phaser.CANVAS or Phaser.WEBGL.",
          "!type": "+Number"
        },
        "camera": {
          "!doc": "A handy reference to world.camera.",
          "!type": "+Phaser.Camera"
        },
        "make": {
          "!doc": "Reference to the GameObject Creator.",
          "!type": "+Phaser.GameObjectCreator"
        },
        "isBooted": {
          "!doc": "Whether the game engine is booted, aka available.",
          "!type": "+Boolean"
        },
        "debug": {
          "!doc": "A set of useful debug utilities.",
          "!type": "+Phaser.Utils.Debug"
        },
        "forceSingleUpdate": {
          "!doc": "Should the game loop force a logic update, regardless of the delta timer? Set to true if you know you need this. You can toggle it on the fly.",
          "!type": "+Boolean"
        },
        "gameResumed": {
          "!doc": "Called by the Stage visibility handler.",
          "!type": "fn(event: +Object)"
        },
        "onBlur": {
          "!doc": "This event is fired when the game no longer has focus (typically on page hide).",
          "!type": "+Phaser.Signal"
        },
        "stage": {
          "!doc": "Reference to the stage.",
          "!type": "+Phaser.Stage"
        },
        "width": {
          "!doc": "The current Game Width in pixels.\n\n_Do not modify this property directly:_ use {@link Phaser.ScaleManager#setGameSize} - eg. `game.scale.setGameSize(width, height)` - instead.",
          "!type": "+Number"
        },
        "step": {
          "!doc": "When stepping is enabled you must call this function directly (perhaps via a DOM button?) to advance the game loop by one frame.\nThis is extremely useful to hard to track down errors! Use the internal stepCount property to monitor progress.",
          "!type": "fn()"
        },
        "focusGain": {
          "!doc": "Called by the Stage visibility handler.",
          "!type": "fn(event: +Object)"
        },
        "time": {
          "!doc": "Reference to the core game clock.",
          "!type": "+Phaser.Time"
        },
        "disableStep": {
          "!doc": "Disables core game loop stepping.",
          "!type": "fn()"
        },
        "config": {
          "!doc": "The Phaser.Game configuration object.",
          "!type": "+Object"
        }
      }
    },
    "Rope": {
      "init": {
        "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
        "!type": "fn()"
      },
      "install": {
        "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
        "!type": "fn()"
      },
      "!doc": "A Rope is a Sprite that has a repeating texture.\n\nThe texture will automatically wrap on the edges as it moves.\n\nPlease note that Ropes cannot have an input handler.",
      "!type": "fn(game: +Phaser.Game, x: +Number, y: +Number, key: +String, frame: +String, points: +Array)",
      "prototype": {
        "play": {
          "!doc": "Plays an Animation.\n\nThe animation should have previously been created via `animations.add`.\n\nIf the animation is already playing calling this again won't do anything.\nIf you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.",
          "!type": "fn(name: +String, frameRate: +Number, loop: +Boolean, killOnComplete: +Boolean) -> +Phaser.Animation"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "lifespan": {
          "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
          "!type": "+Number"
        },
        "outOfBoundsKill": {
          "!doc": "If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.",
          "!type": "+Boolean"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "body": {
          "!doc": "`body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated \nproperties and methods via it.\n\nBy default Game Objects won't add themselves to any physics system and their `body` property will be `null`.\n\nTo enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object\nand `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.\n\nYou can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.\n\nImportant: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5, \nso the physics body is centered on the Game Object.\n\nIf you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.",
          "!type": "+Phaser.Physics.Arcade.Body"
        },
        "inCamera": {
          "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
          "!type": "+Boolean"
        },
        "offsetX": {
          "!doc": "The amount the Game Object is visually offset from its x coordinate.\nThis is the same as `width * anchor.x`.\nIt will only be > 0 if anchor.x is not equal to zero.",
          "!type": "+Number"
        },
        "resizeFrame": {
          "!doc": "Resizes the Frame dimensions that the Game Object uses for rendering.\n\nYou shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData\nit can be useful to adjust the dimensions directly in this way.",
          "!type": "fn(parent: +Object, width: +Number, height: +Number)"
        },
        "offsetY": {
          "!doc": "The amount the Game Object is visually offset from its y coordinate.\nThis is the same as `height * anchor.y`.\nIt will only be > 0 if anchor.y is not equal to zero.",
          "!type": "+Number"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "revive": {
          "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
          "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
        },
        "fixedToCamera": {
          "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
          "!type": "+Boolean"
        },
        "renderOrderID": {
          "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
          "!type": "+Number"
        },
        "DrawModes": {
          "!doc": "Different drawing buffer modes supported",
          "!type": "+Object"
        },
        "bringToTop": {
          "!doc": "Brings this Game Object to the top of its parents display list.\nVisually this means it will render over the top of any old child in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "events": {
          "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
          "!type": "+Phaser.Events"
        },
        "moveUp": {
          "!doc": "Moves this Game Object up one place in its parents display list.\nThis call has no effect if the Game Object is already at the top of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousRotation": {
          "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
          "!type": "+Number"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "postUpdate": {
          "!doc": "Internal method called by the World postUpdate cycle.",
          "!type": "fn()"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.\nThis is the same as `y + height - offsetY`.",
          "!type": "+Number"
        },
        "cameraOffset": {
          "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
          "!type": "+Phaser.Point"
        },
        "smoothed": {
          "!doc": "Enable or disable texture smoothing for this Game Object.\n\nIt only takes effect if the Game Object is using an image based texture.\n\nSmoothing is enabled by default.",
          "!type": "+Boolean"
        },
        "destroy": {
          "!doc": "Destroys the Game Object. This removes it from its parent group, destroys the input, event and animation handlers if present\nand nulls its reference to `game`, freeing it up for garbage collection.\n\nIf this Game Object has the Events component it will also dispatch the `onDestroy` event.\n\nYou can optionally also destroy the BaseTexture this Game Object is using. Be careful if you've\nmore than one Game Object sharing the same BaseTexture.",
          "!type": "fn(destroyChildren: +Boolean, destroyTexture: +Boolean)"
        },
        "moveDown": {
          "!doc": "Moves this Game Object down one place in its parents display list.\nThis call has no effect if the Game Object is already at the bottom of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "updateCrop": {
          "!doc": "If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,\nor the rectangle it references, then you need to update the crop frame by calling this method.",
          "!type": "fn()"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "overlap": {
          "!doc": "Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object, \nwhich can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.\n\nThis check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.\n\nTherefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.\nIt should be fine for low-volume testing where physics isn't required.",
          "!type": "fn(displayObject: +Phaser.Sprite) -> +Boolean"
        },
        "left": {
          "!doc": "The left coordinate of the Game Object.\nThis is the same as `x - offsetX`.",
          "!type": "+Number"
        },
        "loadTexture": {
          "!doc": "Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.\n\nIf your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.\n\nYou should only use `loadTexture` if you want to replace the base texture entirely.\n\nCalling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.\n\nYou can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite. \nDoing this then sets the key to be the `frame` argument (the frame is set to zero). \n\nThis allows you to create sprites using `load.image` during development, and then change them \nto use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS' \nand swapping it to be the key of the atlas data.\n\nNote: You cannot use a RenderTexture as a texture for a TileSprite.",
          "!type": "fn(key: +String, frame: +String, stopAnimation: +Boolean)"
        },
        "name": {
          "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
          "!type": "+String"
        },
        "reset": {
          "!doc": "Resets the Rope. This places the Rope at the given x/y world coordinates and then\nsets alive, exists, visible and renderable all to true. Also resets the outOfBounds state.\nIf the Rope has a physics body that too is reset.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Rope"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "preUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn()"
        },
        "crop": {
          "!doc": "Crop allows you to crop the texture being used to display this Game Object.\nSetting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.\n\nCropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,\nor by modifying `cropRect` property directly and then calling `updateCrop`.\n\nThe rectangle object given to this method can be either a `Phaser.Rectangle` or any other object \nso long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.\n\nA reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`, \nin which case the values are duplicated to a local object.",
          "!type": "fn(rect: +Phaser.Rectangle, copy: +Boolean)"
        },
        "updateAnimation": {
          "!doc": "Set to a function if you'd like the rope to animate during the update phase. Set to false or null to remove it.",
          "!type": "+Function"
        },
        "frame": {
          "!doc": "Gets or sets the current frame index of the texture being used to render this Game Object.\n\nTo change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,\nfor example: `player.frame = 4`.\n\nIf the frame index given doesn't exist it will revert to the first frame found in the texture.\n\nIf you are using a texture atlas then you should use the `frameName` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+Number"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "cropRect": {
          "!doc": "The Rectangle used to crop the texture this Game Object uses.\nSet this property via `crop`. \nIf you modify this property directly you must call `updateCrop` in order to have the change take effect.",
          "!type": "+Phaser.Rectangle"
        },
        "canvasPadding": {
          "!doc": "Triangles in canvas mode are automatically antialiased, use this value to force triangles to overlap a bit with each other.",
          "!type": "+Number"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "components": {
          "!doc": "The components this Game Object has installed.",
          "!type": "+Object"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "deltaZ": {
          "!doc": "The delta value.",
          "!type": "+Number"
        },
        "alive": {
          "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
          "!type": "+Boolean"
        },
        "transformCallbackContext": {
          "!doc": "The context under which `transformCallback` is called.",
          "!type": "+Object"
        },
        "deltaX": {
          "!doc": "Returns the delta x value. The difference between world.x now and in the previous frame.\n\nThe value will be positive if the Game Object has moved to the right or negative if to the left.",
          "!type": "+Number"
        },
        "deltaY": {
          "!doc": "Returns the delta y value. The difference between world.y now and in the previous frame.\n\nThe value will be positive if the Game Object has moved down or negative if up.",
          "!type": "+Number"
        },
        "update": {
          "!doc": "Override and use this function in your own custom objects to handle any update requirements you may have.",
          "!type": "fn()"
        },
        "transformCallback": {
          "!doc": "The callback that will apply any scale limiting to the worldTransform.",
          "!type": "+Function"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "inWorld": {
          "!doc": "Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.",
          "!type": "+Boolean"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "world": {
          "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
          "!type": "+Phaser.Point"
        },
        "top": {
          "!doc": "The y coordinate of the Game Object.\nThis is the same as `y - offsetY`.",
          "!type": "+Number"
        },
        "setFrame": {
          "!doc": "Sets the texture frame the Game Object uses for rendering.\n\nThis is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.",
          "!type": "fn(frame: +Phaser.Frame)"
        },
        "animations": {
          "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
          "!type": "+Phaser.AnimationManager"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        },
        "setScaleMinMax": {
          "!doc": "Sets the scaleMin and scaleMax values. These values are used to limit how far this Game Object will scale based on its parent.\n\nFor example if this Game Object has a `minScale` value of 1 and its parent has a `scale` value of 0.5, the 0.5 will be ignored \nand the scale value of 1 will be used, as the parents scale is lower than the minimum scale this Game Object should adhere to.\n\nBy setting these values you can carefully control how Game Objects deal with responsive scaling.\n\nIf only one parameter is given then that value will be used for both scaleMin and scaleMax:\n`setScaleMinMax(1)` = scaleMin.x, scaleMin.y, scaleMax.x and scaleMax.y all = 1\n\nIf only two parameters are given the first is set as scaleMin.x and y and the second as scaleMax.x and y:\n`setScaleMinMax(0.5, 2)` = scaleMin.x and y = 0.5 and scaleMax.x and y = 2\n\nIf you wish to set `scaleMin` with different values for x and y then either modify Game Object.scaleMin directly, \nor pass `null` for the `maxX` and `maxY` parameters.\n\nCall `setScaleMinMax(null)` to clear all previously set values.",
          "!type": "fn(minX: +Number, minY: +Number, maxX: +Number, maxY: +Number)"
        },
        "checkWorldBounds": {
          "!doc": "If this is set to `true` the Game Object checks if it is within the World bounds each frame. \n\nWhen it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.\n\nIf it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.\n\nIt also optionally kills the Game Object if `outOfBoundsKill` is `true`.\n\nWhen `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "key": {
          "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
          "!type": "+String"
        },
        "dirty": {
          "!doc": "Whether the strip is dirty or not",
          "!type": "+Boolean"
        },
        "debug": {
          "!doc": "A debug flag designed for use with `Game.enableStep`.",
          "!type": "+Boolean"
        },
        "frameName": {
          "!doc": "Gets or sets the current frame name of the texture being used to render this Game Object.\n\nTo change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use, \nfor example: `player.frameName = \"idle\"`.\n\nIf the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.\n\nIf you are using a sprite sheet then you should use the `frame` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+String"
        },
        "texture": {
          "!doc": "The texture of the strip",
          "!type": "+Texture"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "outOfCameraBoundsKill": {
          "!doc": "If this and the `autoCull` property are both set to `true`, then the `kill` method\nis called as soon as the Game Object leaves the camera bounds.",
          "!type": "+Boolean"
        },
        "sendToBack": {
          "!doc": "Sends this Game Object to the bottom of its parents display list.\nVisually this means it will render below all other children in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "destroyPhase": {
          "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
          "!type": "+Boolean"
        },
        "right": {
          "!doc": "The right coordinate of the Game Object.\nThis is the same as `x + width - offsetX`.",
          "!type": "+Number"
        },
        "kill": {
          "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "resetFrame": {
          "!doc": "Resets the texture frame dimensions that the Game Object uses for rendering.",
          "!type": "fn()"
        },
        "previousPosition": {
          "!doc": "The position the Game Object was located in the previous frame.",
          "!type": "+Phaser.Point"
        },
        "scaleMax": {
          "!doc": "The maximum scale this Game Object will scale up to. \n\nIt allows you to prevent a parent from scaling this Game Object higher than the given value.\n\nSet it to `null` to remove the limit.",
          "!type": "+Phaser.Point"
        },
        "pendingDestroy": {
          "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
          "!type": "+Boolean"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.",
          "!type": "+Number"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "autoCull": {
          "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The position of the Game Object on the x axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "Controls if this Game Object is processed by the core game loop.\nIf this Game Object has a physics body it also controls if its physics body is updated or not.\nWhen `exists` is set to `false` it will remove its physics body from the physics world if it has one.\nIt also toggles the `visible` property to false as well.\n\nSetting `exists` to true will add its physics body back in to the physics world, if it has one.\nIt will also set the `visible` property to `true`.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The position of the Game Object on the y axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
          "!type": "+Number"
        },
        "fresh": {
          "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
          "!type": "+Boolean"
        },
        "scaleMin": {
          "!doc": "The minimum scale this Game Object will scale down to.\n\nIt allows you to prevent a parent from scaling this Game Object lower than the given value.\n\nSet it to `null` to remove the limit.",
          "!type": "+Phaser.Point"
        }
      },
      "DrawModes": {
        "!doc": "Different drawing buffer modes supported",
        "!type": "+Object"
      }
    },
    "RetroFont": {
      "TEXT_SET2": "+String",
      "TEXT_SET3": "+String",
      "TEXT_SET1": "+String",
      "TEXT_SET10": "+String",
      "TEXT_SET6": "+String",
      "TEXT_SET7": "+String",
      "TEXT_SET4": "+String",
      "!doc": "A Retro Font is similar to a BitmapFont, in that it uses a texture to render the text. However unlike a BitmapFont every character in a RetroFont\nis the same size. This makes it similar to a sprite sheet. You typically find font sheets like this from old 8/16-bit games and demos.",
      "TEXT_SET5": "+String",
      "TEXT_SET8": "+String",
      "TEXT_SET9": "+String",
      "prototype": {
        "frameData": {
          "!doc": "The FrameData representing this Retro Font.",
          "!type": "+Phaser.FrameData"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "removeUnsupportedCharacters": {
          "!doc": "Internal helper function that removes all unsupported characters from the _text String, leaving only characters contained in the font set.",
          "!type": "fn(stripCR: +Boolean) -> +String"
        },
        "multiLine": {
          "!doc": "If set to true all carriage-returns in text will form new lines (see align). If false the font will only contain one single line of text (the default)",
          "!type": "+Boolean"
        },
        "autoUpperCase": {
          "!doc": "Automatically convert any text to upper case. Lots of old bitmap fonts only contain upper-case characters, so the default is true.",
          "!type": "+Boolean"
        },
        "stamp": {
          "!doc": "The image that is stamped to the RenderTexture for each character in the font.",
          "!type": "+Phaser.Image"
        },
        "align": {
          "!doc": "Alignment of the text when multiLine = true or a fixedWidth is set. Set to RetroFont.ALIGN_LEFT (default), RetroFont.ALIGN_RIGHT or RetroFont.ALIGN_CENTER.",
          "!type": "+String"
        },
        "type": {
          "!doc": "Base Phaser object type.",
          "!type": "+Number"
        },
        "renderRawXY": {
          "!doc": "This function will draw the display object to the RenderTexture at the given coordinates.\n\nWhen the display object is drawn it doesn't take into account scale, rotation or translation.\n\nIf you need those then use RenderTexture.renderXY instead.",
          "!type": "fn(displayObject: +Phaser.Sprite, x: +Number, y: +Number, clear: +Boolean)"
        },
        "characterWidth": {
          "!doc": "The width of each character in the font set.",
          "!type": "+Number"
        },
        "setFixedWidth": {
          "!doc": "If you need this RetroFont to have a fixed width and custom alignment you can set the width here.\nIf text is wider than the width specified it will be cropped off.",
          "!type": "fn(width: +Number, lineAlignment: +String)"
        },
        "offsetX": {
          "!doc": "If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.",
          "!type": "+Number"
        },
        "characterSpacingX": {
          "!doc": "If the characters in the font set have horizontal spacing between them set the required amount here.",
          "!type": "+Number"
        },
        "characterSpacingY": {
          "!doc": "If the characters in the font set have vertical spacing between them set the required amount here.",
          "!type": "+Number"
        },
        "offsetY": {
          "!doc": "If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.",
          "!type": "+Number"
        },
        "renderXY": {
          "!doc": "This function will draw the display object to the RenderTexture at the given coordinates.\n\nWhen the display object is drawn it takes into account scale and rotation.\n\nIf you don't want those then use RenderTexture.renderRawXY instead.",
          "!type": "fn(displayObject: +Phaser.Sprite, x: +Number, y: +Number, clear: +Boolean)"
        },
        "text": {
          "!doc": "Set this value to update the text in this sprite. Carriage returns are automatically stripped out if multiLine is false. Text is converted to upper case if autoUpperCase is true.",
          "!type": "+String"
        },
        "render": {
          "!doc": "This function will draw the display object to the RenderTexture.\n\nIn versions of Phaser prior to 2.4.0 the second parameter was a Phaser.Point object. \nThis is now a Matrix allowing you much more control over how the Display Object is rendered.\nIf you need to replicate the earlier behavior please use Phaser.RenderTexture.renderXY instead.\n\nIf you wish for the displayObject to be rendered taking its current scale, rotation and translation into account then either\npass `null`, leave it undefined or pass `displayObject.worldTransform` as the matrix value.",
          "!type": "fn(displayObject: +Phaser.Sprite, matrix: +Phaser.Matrix, clear: +Boolean)"
        },
        "key": {
          "!doc": "The key of the RenderTexture in the Cache, if stored there.",
          "!type": "+String"
        },
        "fixedWidth": {
          "!doc": "If you need this RetroFont image to have a fixed width you can set the width in this value.\nIf text is wider than the width specified it will be cropped off.",
          "!type": "+Number"
        },
        "smoothed": {
          "!doc": "Sets if the stamp is smoothed or not.",
          "!type": "+Boolean"
        },
        "getLongestLine": {
          "!doc": "Works out the longest line of text in _text and returns its length",
          "!type": "fn() -> +Number"
        },
        "updateOffset": {
          "!doc": "Updates the x and/or y offset that the font is rendered from. This updates all of the texture frames, so be careful how often it is called.\nNote that the values given for the x and y properties are either ADDED to or SUBTRACTED from (if negative) the existing offsetX/Y values of the characters.\nSo if the current offsetY is 8 and you want it to start rendering from y16 you would call updateOffset(0, 8) to add 8 to the current y offset.",
          "!type": "fn(xOffset: +Number, yOffset: +Number)"
        },
        "characterPerRow": {
          "!doc": "The number of characters per row in the font set.",
          "!type": "+Number"
        },
        "characterHeight": {
          "!doc": "The height of each character in the font set.",
          "!type": "+Number"
        },
        "customSpacingX": {
          "!doc": "Adds horizontal spacing between each character of the font, in pixels.",
          "!type": "+Number"
        },
        "customSpacingY": {
          "!doc": "Adds vertical spacing between each line of multi-line text, set in pixels.",
          "!type": "+Number"
        },
        "pasteLine": {
          "!doc": "Internal function that takes a single line of text (2nd parameter) and pastes it into the BitmapData at the given coordinates.\nUsed by getLine and getMultiLine",
          "!type": "fn(line: +String, x: +Number, y: +Number, customSpacingX: +Number)"
        },
        "fontSet": {
          "!doc": "A reference to the image stored in the Game.Cache that contains the font.",
          "!type": "+Phaser.Image"
        },
        "buildRetroFontText": {
          "!doc": "Updates the texture with the new text.",
          "!type": "fn()"
        },
        "setText": {
          "!doc": "A helper function that quickly sets lots of variables at once, and then updates the text.",
          "!type": "fn(content: +String, multiLine: +Boolean, characterSpacing: +Number, lineSpacing: +Number, lineAlignment: +String, allowLowerCase: +Boolean)"
        }
      },
      "ALIGN_CENTER": "+String",
      "!type": "fn(game: +Phaser.Game, key: +String, characterWidth: +Number, characterHeight: +Number, chars: +String, charsPerRow: +Number, xSpacing: +Number, ySpacing: +Number, xOffset: +Number, yOffset: +Number)",
      "ALIGN_RIGHT": "+String",
      "TEXT_SET11": "+String",
      "ALIGN_LEFT": "+String"
    },
    "FlexGrid": {
      "!doc": "WARNING: This is an EXPERIMENTAL class. The API will change significantly in the coming versions and is incomplete.\nPlease try to avoid using in production games with a long time to build.\nThis is also why the documentation is incomplete.\n\nFlexGrid is a a responsive grid manager that works in conjunction with the ScaleManager RESIZE scaling mode and FlexLayers\nto provide for game object positioning in a responsive manner.",
      "!type": "fn(manager: +Phaser.ScaleManager, width: +Number, height: +Number)",
      "prototype": {
        "fitSprite": {
          "!doc": "Fits a sprites width to the bounds.",
          "!type": "fn(sprite: +Phaser.Sprite)"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "debug": {
          "!doc": "Call in the render function to output the bounds rects.",
          "!type": "fn()"
        },
        "createFullLayer": {
          "!doc": "A full layer is placed at 0,0 and extends to the full size of the game. Children are scaled according to the fluid ratios.",
          "!type": "fn(children: +Array) -> +Phaser.FlexLayer"
        },
        "manager": {
          "!doc": "A reference to the ScaleManager.",
          "!type": "+Phaser.ScaleManager"
        },
        "scaleFactor": {
          "!doc": "The scale factor based on the game dimensions vs. the scaled dimensions.",
          "!type": "+Phaser.Point"
        },
        "createFluidLayer": {
          "!doc": "A fluid layer is centered on the game and maintains its aspect ratio as it scales up and down.",
          "!type": "fn(children: +Array) -> +Phaser.FlexLayer"
        },
        "refresh": {
          "!doc": "Updates all internal vars such as the bounds and scale values.",
          "!type": "fn()"
        },
        "onResize": {
          "!doc": "Called when the game container changes dimensions.",
          "!type": "fn(width: +Number, height: +Number)"
        },
        "setSize": {
          "!doc": "Sets the core game size. This resets the w/h parameters and bounds.",
          "!type": "fn(width: +Number, height: +Number)"
        },
        "createCustomLayer": {
          "!doc": "A custom layer is centered on the game and maintains its aspect ratio as it scales up and down.",
          "!type": "fn(width: +Number, height: +Number, children: +Array._PIXI.DisplayObject_) -> +Phaser.FlexLayer"
        },
        "reset": {
          "!doc": "Resets the layer children references",
          "!type": "fn()"
        },
        "position": {
          "!doc": "-",
          "!type": "+Phaser.Point"
        },
        "createFixedLayer": {
          "!doc": "A fixed layer is centered on the game and is the size of the required dimensions and is never scaled.",
          "!type": "fn(children: +Array._PIXI.DisplayObject_) -> +Phaser.FlexLayer"
        }
      }
    },
    "AnimationManager": {
      "!doc": "The Animation Manager is used to add, play and update Phaser Animations.\nAny Game Object such as Phaser.Sprite that supports animation contains a single AnimationManager instance.",
      "!type": "fn(sprite: +Phaser.Sprite)",
      "prototype": {
        "add": {
          "!doc": "Adds a new animation under the given key. Optionally set the frames, frame rate and loop.\nAnimations added in this way are played back with the play function.",
          "!type": "fn(name: +String, frames: +Array, frameRate: +Number, loop: +Boolean, useNumericIndex: +Boolean) -> +Phaser.Animation"
        },
        "play": {
          "!doc": "Play an animation based on the given key. The animation should previously have been added via `animations.add`\n\nIf the requested animation is already playing this request will be ignored. \nIf you need to reset an already running animation do so directly on the Animation object itself.",
          "!type": "fn(name: +String, frameRate: +Number, loop: +Boolean, killOnComplete: +Boolean) -> +Phaser.Animation"
        },
        "next": {
          "!doc": "Advances by the given number of frames in the current animation, taking the loop value into consideration.",
          "!type": "fn(quantity: +Number)"
        },
        "frameData": {
          "!doc": "The current animations FrameData.",
          "!type": "+Phaser.FrameData"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "updateIfVisible": {
          "!doc": "Should the animation data continue to update even if the Sprite.visible is set to false.",
          "!type": "+Boolean"
        },
        "paused": {
          "!doc": "Gets and sets the paused state of the current animation.",
          "!type": "+Boolean"
        },
        "frameName": {
          "!doc": "Gets or sets the current frame name and updates the Texture Cache for display.",
          "!type": "+String"
        },
        "previous": {
          "!doc": "Moves backwards the given number of frames in the current animation, taking the loop value into consideration.",
          "!type": "fn(quantity: +Number)"
        },
        "currentAnim": {
          "!doc": "The currently displayed animation, if any.",
          "!type": "+Phaser.Animation"
        },
        "update": {
          "!doc": "The main update function is called by the Sprites update loop. It's responsible for updating animation frames and firing related events.",
          "!type": "fn() -> +Boolean"
        },
        "destroy": {
          "!doc": "Destroys all references this AnimationManager contains.\nIterates through the list of animations stored in this manager and calls destroy on each of them.",
          "!type": "fn()"
        },
        "isLoaded": {
          "!doc": "Set to true once animation data has been loaded.",
          "!type": "+Boolean"
        },
        "refreshFrame": {
          "!doc": "Refreshes the current frame data back to the parent Sprite and also resets the texture data.",
          "!type": "fn()"
        },
        "stop": {
          "!doc": "Stop playback of an animation. If a name is given that specific animation is stopped, otherwise the current animation is stopped.\nThe currentAnim property of the AnimationManager is automatically set to the animation given.",
          "!type": "fn(name: +String, resetFrame: +Boolean)"
        },
        "frameTotal": {
          "!doc": "The total number of frames in the currently loaded FrameData, or -1 if no FrameData is loaded.",
          "!type": "+Number"
        },
        "getAnimation": {
          "!doc": "Returns an animation that was previously added by name.",
          "!type": "fn(name: +String) -> +Phaser.Animation"
        },
        "sprite": {
          "!doc": "A reference to the parent Sprite that owns this AnimationManager.",
          "!type": "+Phaser.Sprite"
        },
        "currentFrame": {
          "!doc": "The currently displayed Frame of animation, if any.\nThis property is only set once an Animation starts playing. Until that point it remains set as `null`.",
          "!type": "+Phaser.Frame"
        },
        "name": {
          "!doc": "Gets the current animation name, if set.",
          "!type": "+String"
        },
        "validateFrames": {
          "!doc": "Check whether the frames in the given array are valid and exist.",
          "!type": "fn(frames: +Array, useNumericIndex: +Boolean) -> +Boolean"
        },
        "frame": {
          "!doc": "Gets or sets the current frame index and updates the Texture Cache for display.",
          "!type": "+Number"
        }
      }
    },
    "Key": {
      "!doc": "If you need more fine-grained control over the handling of specific keys you can create and use Phaser.Key objects.",
      "!type": "fn(game: +Phaser.Game, keycode: +Number)",
      "prototype": {
        "repeats": {
          "!doc": "If a key is held down this holds down the number of times the key has 'repeated'.",
          "!type": "+Number"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "onHoldContext": {
          "!doc": "The context under which the onHoldCallback will be called.",
          "!type": "+Object"
        },
        "timeUp": {
          "!doc": "The timestamp when the key was last released. This is based on Game.time.now.",
          "!type": "+Number"
        },
        "ctrlKey": {
          "!doc": "The down state of the CTRL key, if pressed at the same time as this key.",
          "!type": "+Boolean"
        },
        "onHoldCallback": {
          "!doc": "A callback that is called while this Key is held down. Warning: Depending on refresh rate that could be 60+ times per second.",
          "!type": "+Function"
        },
        "update": {
          "!doc": "Called automatically by Phaser.Keyboard.",
          "!type": "fn()"
        },
        "timeDown": {
          "!doc": "The timestamp when the key was last pressed down. This is based on Game.time.now.",
          "!type": "+Number"
        },
        "downDuration": {
          "!doc": "Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,\nor was pressed down longer ago than then given duration.",
          "!type": "fn(duration: +Number) -> +Boolean"
        },
        "isDown": {
          "!doc": "The \"down\" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.",
          "!type": "+Boolean"
        },
        "onUp": {
          "!doc": "This Signal is dispatched every time this Key is released. It is only dispatched once (until the key is pressed and released again).",
          "!type": "+Phaser.Signal"
        },
        "upDuration": {
          "!doc": "Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,\nor was pressed down longer ago than then given duration.",
          "!type": "fn(duration: +Number) -> +Boolean"
        },
        "duration": {
          "!doc": "The number of milliseconds this key has been held down for.",
          "!type": "+Number"
        },
        "keyCode": {
          "!doc": "The keycode of this key.",
          "!type": "+Number"
        },
        "shiftKey": {
          "!doc": "The down state of the SHIFT key, if pressed at the same time as this key.",
          "!type": "+Boolean"
        },
        "isUp": {
          "!doc": "The \"up\" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.",
          "!type": "+Boolean"
        },
        "reset": {
          "!doc": "Resets the state of this Key.\n\nThis sets isDown to false, isUp to true, resets the time to be the current time, and _enables_ the key.\nIn addition, if it is a \"hard reset\", it clears clears any callbacks associated with the onDown and onUp events and removes the onHoldCallback.",
          "!type": "fn(hard: +Boolean)"
        },
        "onDown": {
          "!doc": "This Signal is dispatched every time this Key is pressed down. It is only dispatched once (until the key is released again).",
          "!type": "+Phaser.Signal"
        },
        "processKeyUp": {
          "!doc": "Called automatically by Phaser.Keyboard.",
          "!type": "fn(event: +KeyboardEvent)"
        },
        "altKey": {
          "!doc": "The down state of the ALT key, if pressed at the same time as this key.",
          "!type": "+Boolean"
        },
        "processKeyDown": {
          "!doc": "Called automatically by Phaser.Keyboard.",
          "!type": "fn(event: +KeyboardEvent)"
        },
        "event": {
          "!doc": "Stores the most recent DOM event.",
          "!type": "+Object"
        }
      }
    },
    "RENDERTEXTURE": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Group": {
      "SORT_ASCENDING": "+Number",
      "RETURN_TOTAL": "+Number",
      "!doc": "A Group is a container for {@link DisplayObject display objects} including {@link Phaser.Sprite Sprites} and {@link Phaser.Image Images}.\n\nGroups form the logical tree structure of the display/scene graph where local transformations are applied to children.\nFor instance, all children are also moved/rotated/scaled when the group is moved/rotated/scaled.\n\nIn addition, Groups provides support for fast pooling and object recycling.\n\nGroups are also display objects and can be nested as children within other Groups.",
      "RETURN_NONE": "+Number",
      "!type": "fn(game: +Phaser.Game, parent: +DisplayObject, name: +String, addToStage: +Boolean, enableBody: +Boolean, physicsBodyType: +Number)",
      "SORT_DESCENDING": "+Number",
      "RETURN_CHILD": "+Number",
      "prototype": {
        "xy": {
          "!doc": "Positions the child found at the given index within this group to the given x and y coordinates.",
          "!type": "fn(index: +Number, x: +Number, y: +Number)"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "descendingSortHandler": {
          "!doc": "An internal helper function for the sort process.",
          "!type": "fn(a: +Object, b: +Object)"
        },
        "type": {
          "!doc": "Internal Phaser Type value.",
          "!type": "+Number"
        },
        "moveAll": {
          "!doc": "Moves all children from this Group to the Group given.",
          "!type": "fn(group: +Phaser.Group, silent: +Boolean) -> +Phaser.Group"
        },
        "removeAll": {
          "!doc": "Removes all children from this group, but does not remove the group from its parent.",
          "!type": "fn(destroy: +Boolean, silent: +Boolean)"
        },
        "enableBody": {
          "!doc": "If true all Sprites created by, or added to this group, will have a physics body enabled on them.\n\nThe default body type is controlled with {@link #physicsBodyType}.",
          "!type": "+Boolean"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "customSort": {
          "!doc": "Sort the children in the group according to custom sort function.\n\nThe `sortHandler` is provided the two parameters: the two children involved in the comparison (a and b).\nIt should return -1 if `a > b`, 1 if `a < b` or 0 if `a === b`.",
          "!type": "fn(sortHandler: +Function, context: +Object)"
        },
        "enableBodyDebug": {
          "!doc": "If true when a physics body is created (via {@link #enableBody}) it will create a physics debug object as well.\n\nThis only works for P2 bodies.",
          "!type": "+Boolean"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "bringToTop": {
          "!doc": "Brings the given child to the top of this group so it renders above all other children.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "moveUp": {
          "!doc": "Moves the given child up one place in this group unless it's already at the top.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "postUpdate": {
          "!doc": "The core postUpdate - as called by World.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Destroys this group.\n\nRemoves all children, then removes this group from its parent and nulls references.",
          "!type": "fn(destroyChildren: +Boolean, soft: +Boolean)"
        },
        "cursorIndex": {
          "!doc": "The current index of the Group cursor. Advance it with Group.next.",
          "!type": "+Number"
        },
        "getFirstDead": {
          "!doc": "Get the first child that is dead (`child.alive === false`).\n\nThis is handy for checking if everything has been wiped out and adding to the pool as needed.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no dead ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "physicsSortDirection": {
          "!doc": "If this Group contains Arcade Physics Sprites you can set a custom sort direction via this property.\n\nIt should be set to one of the Phaser.Physics.Arcade sort direction constants: \n\nPhaser.Physics.Arcade.SORT_NONE\nPhaser.Physics.Arcade.LEFT_RIGHT\nPhaser.Physics.Arcade.RIGHT_LEFT\nPhaser.Physics.Arcade.TOP_BOTTOM\nPhaser.Physics.Arcade.BOTTOM_TOP\n\nIf set to `null` the Group will use whatever Phaser.Physics.Arcade.sortDirection is set to. This is the default behavior.",
          "!type": "+Number"
        },
        "addAt": {
          "!doc": "Adds an existing object to this group.\n\nThe child is added to the group at the location specified by the index value, this allows you to control child ordering.",
          "!type": "fn(child: +DisplayObject, index: +Number, silent: +Boolean) -> +PIXI.DisplayObject"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "forEachAlive": {
          "!doc": "Call a function on each alive child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "resetCursor": {
          "!doc": "Sets the group cursor to the first child in the group.\n\nIf the optional index parameter is given it sets the cursor to the object at that index instead.",
          "!type": "fn(index: +Number) -> +Object"
        },
        "addMultiple": {
          "!doc": "Adds an array of existing Display Objects to this Group.\n\nThe Display Objects are automatically added to the top of this Group, and will render on-top of everything already in this Group.\n\nAs well as an array you can also pass another Group as the first argument. In this case all of the children from that\nGroup will be removed from it and added into this Group.",
          "!type": "fn(children: +Array._DisplayObject_, silent: +Boolean) -> +Array._DisplayObject_"
        },
        "setProperty": {
          "!doc": "Sets a property to the given value on the child. The operation parameter controls how the value is set.\n\nThe operations are:\n- 0: set the existing value to the given value; if force is `true` a new property will be created if needed\n- 1: will add the given value to the value already present.\n- 2: will subtract the given value from the value already present.\n- 3: will multiply the value already present by the given value.\n- 4: will divide the value already present by the given value.",
          "!type": "fn(child: +Object, key: +Array, value: +Object, operation: +Number, force: +Boolean) -> +Boolean"
        },
        "preUpdate": {
          "!doc": "The core preUpdate - as called by World.",
          "!type": "fn()"
        },
        "hash": {
          "!doc": "The hash array is an array belonging to this Group into which you can add any of its children via Group.addToHash and Group.removeFromHash.\n\nOnly children of this Group can be added to and removed from the hash.\n\nThis hash is used automatically by Phaser Arcade Physics in order to perform non z-index based destructive sorting.\nHowever if you don't use Arcade Physics, or this isn't a physics enabled Group, then you can use the hash to perform your own\nsorting and filtering of Group children without touching their z-index (and therefore display draw order)",
          "!type": "+Array"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "addToHash": {
          "!doc": "Adds a child of this Group into the hash array.\nThis call will return false if the child is not a child of this Group, or is already in the hash.",
          "!type": "fn(child: +DisplayObject) -> +Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "The alive property is useful for Groups that are children of other Groups and need to be included/excluded in checks like forEachAlive.",
          "!type": "+Boolean"
        },
        "checkProperty": {
          "!doc": "Checks a property for the given value on the child.",
          "!type": "fn(child: +Object, key: +Array, value: +Object, force: +Boolean) -> +Boolean"
        },
        "callbackFromArray": {
          "!doc": "Returns a reference to a function that exists on a child of the group based on the given callback array.",
          "!type": "fn(child: +Object, callback: +Array, length: +Number)"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "multiplyAll": {
          "!doc": "Multiplies the given property by the amount on all children in this group.\n\n`Group.multiplyAll('x', 2)` will x2 the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "getByName": {
          "!doc": "Searches the Group for the first instance of a child with the `name`\nproperty matching the given argument. Should more than one child have\nthe same name only the first instance is returned.",
          "!type": "fn(name: +String) -> +Object"
        },
        "angle": {
          "!doc": "The angle of rotation of the group container, in degrees.\n\nThis adjusts the group itself by modifying its local rotation transform.\n\nThis has no impact on the rotation/angle properties of the children, but it will update their worldTransform\nand on-screen orientation and position.",
          "!type": "+Number"
        },
        "iterate": {
          "!doc": "Iterates over the children of the group performing one of several actions for matched children.\n\nA child is considered a match when it has a property, named `key`, whose value is equal to `value`\naccording to a strict equality comparison.\n\nThe result depends on the `returnType`:\n\n- {@link Phaser.Group.RETURN_TOTAL RETURN_TOTAL}:\n    The callback, if any, is applied to all matching children. The number of matched children is returned.\n- {@link Phaser.Group.RETURN_NONE RETURN_NONE}:\n    The callback, if any, is applied to all matching children. No value is returned.\n- {@link Phaser.Group.RETURN_CHILD RETURN_CHILD}:\n    The callback, if any, is applied to the *first* matching child and the *first* matched child is returned.\n    If there is no matching child then null is returned.\n\nIf `args` is specified it must be an array. The matched child will be assigned to the first\nelement and the entire array will be applied to the callback function.",
          "!type": "fn(key: +String, value: +Object, returnType: +Number, callback: +Function, callbackContext: +Object, args: +Array._any_) -> +Object"
        },
        "onDestroy": {
          "!doc": "This signal is dispatched when the group is destroyed.",
          "!type": "+Phaser.Signal"
        },
        "set": {
          "!doc": "Quickly set a property on a single child of this group to a new value.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(child: +Phaser.Sprite, key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean) -> +Boolean"
        },
        "getFirstExists": {
          "!doc": "Get the first display object that exists, or doesn't exist.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if none matching your exists argument were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(exists: +Boolean, createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "reverse": {
          "!doc": "Reverses all children in this group.\n\nThis operation applies only to immediate children and does not propagate to subgroups.",
          "!type": "fn()"
        },
        "filter": {
          "!doc": "Find children matching a certain predicate.\n\nFor example:\n\n    var healthyList = Group.filter(function(child, index, children) {\n        return child.health > 10 ? true : false;\n    }, true);\n    healthyList.callAll('attack');\n\nNote: Currently this will skip any children which are Groups themselves.",
          "!type": "fn(predicate: +Function, checkExists: +Boolean) -> +Phaser.ArraySet"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "addAll": {
          "!doc": "Adds the amount to the given property on all children in this group.\n\n`Group.addAll('x', 10)` will add 10 to the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "ignoreDestroy": {
          "!doc": "A group with `ignoreDestroy` set to `true` ignores all calls to its `destroy` method.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The x coordinate of the group container.\n\nYou can adjust the group container itself by modifying its coordinates.\nThis will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "If exists is true the group is updated, otherwise it is skipped.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The y coordinate of the group container.\n\nYou can adjust the group container itself by modifying its coordinates.\nThis will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z-depth value of this object within its parent container/Group - the World is a Group as well.\nThis value must be unique for each child in a Group.",
          "!type": "+Number"
        },
        "divideAll": {
          "!doc": "Divides the given property by the amount on all children in this group.\n\n`Group.divideAll('x', 2)` will half the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "setAllChildren": {
          "!doc": "Quickly set the same property across all children of this group, and any child Groups, to a new value.\n\nIf this group contains other Groups then the same property is set across their children as well, iterating down until it reaches the bottom.\nUnlike with `setAll` the property is NOT set on child Groups itself.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
        },
        "physicsBodyType": {
          "!doc": "If {@link #enableBody} is true this is the type of physics body that is created on new Sprites.\n\nThe valid values are {@link Phaser.Physics.ARCADE}, {@link Phaser.Physics.P2JS}, {@link Phaser.Physics.NINJA}, etc.",
          "!type": "+Number"
        },
        "getIndex": {
          "!doc": "Get the index position of the given child in this group, which should match the child's `z` property.",
          "!type": "fn(child: +Object) -> +Number"
        },
        "getBottom": {
          "!doc": "Returns the child at the bottom of this group.\n\nThe bottom child the child being displayed (rendered) below every other child.",
          "!type": "fn() -> +Object"
        },
        "replace": {
          "!doc": "Replaces a child of this group with the given newChild. The newChild cannot be a member of this group.",
          "!type": "fn(oldChild: +Object, newChild: +Object) -> +Object"
        },
        "resetChild": {
          "!doc": "Takes a child and if the `x` and `y` arguments are given it calls `child.reset(x, y)` on it.\n\nIf the `key` and optionally the `frame` arguments are given, it calls `child.loadTexture(key, frame)` on it.\n\nThe two operations are separate. For example if you just wish to load a new texture then pass `null` as the x and y values.",
          "!type": "fn(child: +DisplayObject, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "getRandom": {
          "!doc": "Returns a random child from the group.",
          "!type": "fn(startIndex: +Number, length: +Number) -> +Object"
        },
        "forEachExists": {
          "!doc": "Call a function on each existing child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "getTop": {
          "!doc": "Return the child at the top of this group.\n\nThe top child is the child displayed (rendered) above every other child.",
          "!type": "fn() -> +Object"
        },
        "create": {
          "!doc": "Creates a new Phaser.Sprite object and adds it to the top of this group.\n\nUse {@link #classType} to change the type of object created.",
          "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String, exists: +Boolean) -> +PIXI.DisplayObject"
        },
        "countDead": {
          "!doc": "Get the number of dead children in this group.",
          "!type": "fn() -> +Number"
        },
        "subAll": {
          "!doc": "Subtracts the amount from the given property on all children in this group.\n\n`Group.subAll('x', 10)` will minus 10 from the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "fixedToCamera": {
          "!doc": "A Group that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Group.cameraOffset.\n\nNote that the cameraOffset values are in addition to any parent in the display list.\nSo if this Group was in a Group that has x: 200, then this will be added to the cameraOffset.x",
          "!type": "+Boolean"
        },
        "add": {
          "!doc": "Adds an existing object as the top child in this group.\n\nThe child is automatically added to the top of the group and is displayed on top of every previous child.\n\nIf Group.enableBody is set then a physics body will be created on the object, so long as one does not already exist.\n\nUse {@link #addAt} to control where a child is added. Use {@link #create} to create and add a new child.",
          "!type": "fn(child: +DisplayObject, silent: +Boolean) -> +PIXI.DisplayObject"
        },
        "visible": {
          "!doc": "The visible state of the group. Non-visible Groups and all of their children are not rendered.",
          "!type": "+Boolean"
        },
        "swap": {
          "!doc": "Swaps the position of two children in this group.\n\nBoth children must be in this group, a child cannot be swapped with itself, and unparented children cannot be swapped.",
          "!type": "fn(child1: +Object, child2: +Object)"
        },
        "cameraOffset": {
          "!doc": "If this object is {@link #fixedToCamera} then this stores the x/y position offset relative to the top-left of the camera view.\nIf the parent of this Group is also `fixedToCamera` then the offset here is in addition to that and should typically be disabled.",
          "!type": "+Phaser.Point"
        },
        "sort": {
          "!doc": "Sort the children in the group according to a particular key and ordering.\n\nCall this function to sort the group according to a particular key value and order.\n\nFor example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.\n\nInternally this uses a standard JavaScript Array sort, so everything that applies there also applies here, including\nalphabetical sorting, mixing strings and numbers, and Unicode sorting. See MDN for more details.",
          "!type": "fn(key: +String, order: +Number)"
        },
        "moveDown": {
          "!doc": "Moves the given child down one place in this group unless it's already at the bottom.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "hasProperty": {
          "!doc": "Checks if the child has the given property.\n\nWill scan up to 4 levels deep only.",
          "!type": "fn(child: +Object, key: +Array._string_) -> +Boolean"
        },
        "updateZ": {
          "!doc": "Internal method that re-applies all of the children's Z values.\n\nThis must be called whenever children ordering is altered so that their `z` indices are correctly updated.",
          "!type": "fn()"
        },
        "name": {
          "!doc": "A name for this group. Not used internally but useful for debugging.",
          "!type": "+String"
        },
        "ascendingSortHandler": {
          "!doc": "An internal helper function for the sort process.",
          "!type": "fn(a: +Object, b: +Object)"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "removeBetween": {
          "!doc": "Removes all children from this group whose index falls beteen the given startIndex and endIndex values.",
          "!type": "fn(startIndex: +Number, endIndex: +Number, destroy: +Boolean, silent: +Boolean)"
        },
        "removeFromHash": {
          "!doc": "Removes a child of this Group from the hash array.\nThis call will return false if the child is not in the hash.",
          "!type": "fn(child: +DisplayObject) -> +Boolean"
        },
        "classType": {
          "!doc": "The type of objects that will be created when using {@link #create} or {@link #createMultiple}.\n\nAny object may be used but it should extend either Sprite or Image and accept the same constructor arguments:\nwhen a new object is created it is passed the following parameters to its constructor: `(game, x, y, key, frame)`.",
          "!type": "+Object"
        },
        "next": {
          "!doc": "Advances the group cursor to the next (higher) object in the group.\n\nIf the cursor is at the end of the group (top child) it is moved the start of the group (bottom child).",
          "!type": "fn() -> +Object"
        },
        "cursor": {
          "!doc": "The current display object that the group cursor is pointing to, if any. (Can be set manually.)\n\nThe cursor is a way to iterate through the children in a Group using {@link #next} and {@link #previous}.",
          "!type": "+PIXI.DisplayObject"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "forEachDead": {
          "!doc": "Call a function on each dead child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "update": {
          "!doc": "The core update - as called by World.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "countLiving": {
          "!doc": "Get the number of living children in this group.",
          "!type": "fn() -> +Number"
        },
        "remove": {
          "!doc": "Removes the given child from this group.\n\nThis will dispatch an `onRemovedFromGroup` event from the child (if it has one), and optionally destroy the child.\n\nIf the group cursor was referring to the removed child it is updated to refer to the next child.",
          "!type": "fn(child: +Object, destroy: +Boolean, silent: +Boolean) -> +Boolean"
        },
        "callAll": {
          "!doc": "Calls a function, specified by name, on all on children.\n\nThe function is called for all children regardless if they are dead or alive (see callAllExists for different options).\nAfter the method parameter and context you can add as many extra parameters as you like, which will all be passed to the child.",
          "!type": "fn(method: +String, context: +String, args: +Object)"
        },
        "total": {
          "!doc": "Total number of existing children in the group.",
          "!type": "+Number"
        },
        "alpha": {
          "!doc": "The alpha value of the group container.",
          "!type": "+Number"
        },
        "createMultiple": {
          "!doc": "Creates multiple Phaser.Sprite objects and adds them to the top of this group.\n\nUseful if you need to quickly generate a pool of identical sprites, such as bullets.\n\nBy default the sprites will be set to not exist and will be positioned at 0, 0 (relative to the group.x/y).\nUse {@link #classType} to change the type of object created.",
          "!type": "fn(quantity: +Number, key: +String, frame: +Number, exists: +Boolean)"
        },
        "setAll": {
          "!doc": "Quickly set the same property across all children of this group to a new value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be set on the group but not its children.\nIf you need that ability please see `Group.setAllChildren`.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
        },
        "callAllExists": {
          "!doc": "Calls a function, specified by name, on all children in the group who exist (or do not exist).\n\nAfter the existsValue parameter you can add as many parameters as you like, which will all be passed to the child callback.",
          "!type": "fn(callback: +String, existsValue: +Boolean, parameter: +Object)"
        },
        "checkAll": {
          "!doc": "Quickly check that the same property across all children of this group is equal to the given value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be checked on the group but not its children.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, force: +Boolean)"
        },
        "previous": {
          "!doc": "Moves the group cursor to the previous (lower) child in the group.\n\nIf the cursor is at the start of the group (bottom child) it is moved to the end (top child).",
          "!type": "fn() -> +Object"
        },
        "forEach": {
          "!doc": "Call a function on each child in this group.\n\nAdditional arguments for the callback can be specified after the `checkExists` parameter. For example,\n\n    Group.forEach(awardBonusGold, this, true, 100, 500)\n\nwould invoke `awardBonusGold` function with the parameters `(child, 100, 500)`.\n\nNote: This check will skip any children which are Groups themselves.",
          "!type": "fn(callback: +Function, callbackContext: +Object, checkExists: +Boolean, args: +Object)"
        },
        "rotation": {
          "!doc": "The angle of rotation of the group container, in radians.\n\nThis will adjust the group container itself by modifying its rotation.\nThis will have no impact on the rotation value of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "length": {
          "!doc": "Total number of children in this group, regardless of exists/alive status.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends the given child to the bottom of this group so it renders below all other children.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "getAt": {
          "!doc": "Returns the child found at the given index within this group.",
          "!type": "fn(index: +Number) -> +PIXI.DisplayObject"
        },
        "pendingDestroy": {
          "!doc": "A Group is that has `pendingDestroy` set to `true` is flagged to have its destroy method \ncalled on the next logic update.\nYou can set it directly to flag the Group to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy a Group from within one of its own callbacks \nor a callback of one of its children.",
          "!type": "+Boolean"
        },
        "getFirstAlive": {
          "!doc": "Get the first child that is alive (`child.alive === true`).\n\nThis is handy for choosing a squad leader, etc.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no alive ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        }
      }
    },
    "Frame": {
      "!doc": "A Frame is a single frame of an animation and is part of a FrameData collection.",
      "!type": "fn(index: +Number, x: +Number, y: +Number, width: +Number, height: +Number, name: +String)",
      "prototype": {
        "centerY": {
          "!doc": "Center Y position within the image to cut from.",
          "!type": "+Number"
        },
        "distance": {
          "!doc": "The distance from the top left to the bottom-right of this Frame.",
          "!type": "+Number"
        },
        "spriteSourceSizeW": {
          "!doc": "Width of the trimmed sprite.",
          "!type": "+Number"
        },
        "centerX": {
          "!doc": "Center X position within the image to cut from.",
          "!type": "+Number"
        },
        "spriteSourceSizeX": {
          "!doc": "X position of the trimmed sprite inside original sprite.",
          "!type": "+Number"
        },
        "bottom": {
          "!doc": "The bottom of the frame (y + height).",
          "!type": "+Number"
        },
        "index": {
          "!doc": "The index of this Frame within the FrameData set it is being added to.",
          "!type": "+Number"
        },
        "rotated": {
          "!doc": "Rotated? (not yet implemented)",
          "!type": "+Boolean"
        },
        "sourceSizeH": {
          "!doc": "Height of the original sprite before it was trimmed.",
          "!type": "+Number"
        },
        "spriteSourceSizeY": {
          "!doc": "Y position of the trimmed sprite inside original sprite.",
          "!type": "+Number"
        },
        "right": {
          "!doc": "The right of the Frame (x + width).",
          "!type": "+Number"
        },
        "setTrim": {
          "!doc": "If the frame was trimmed when added to the Texture Atlas this records the trim and source data.",
          "!type": "fn(trimmed: +Boolean, actualWidth: +Number, actualHeight: +Number, destX: +Number, destY: +Number, destWidth: +Number, destHeight: +Number)"
        },
        "spriteSourceSizeH": {
          "!doc": "Height of the trimmed sprite.",
          "!type": "+Number"
        },
        "clone": {
          "!doc": "Clones this Frame into a new Phaser.Frame object and returns it.\nNote that all properties are cloned, including the name, index and UUID.",
          "!type": "fn() -> +Phaser.Frame"
        },
        "x": {
          "!doc": "X position within the image to cut from.",
          "!type": "+Number"
        },
        "width": {
          "!doc": "Width of the frame.",
          "!type": "+Number"
        },
        "name": {
          "!doc": "Useful for Texture Atlas files (is set to the filename value).",
          "!type": "+String"
        },
        "resize": {
          "!doc": "Adjusts of all the Frame properties based on the given width and height values.",
          "!type": "fn(width: +Number, height: +Number)"
        },
        "y": {
          "!doc": "Y position within the image to cut from.",
          "!type": "+Number"
        },
        "trimmed": {
          "!doc": "Was it trimmed when packed?",
          "!type": "+Boolean"
        },
        "sourceSizeW": {
          "!doc": "Width of the original sprite before it was trimmed.",
          "!type": "+Number"
        },
        "getRect": {
          "!doc": "Returns a Rectangle set to the dimensions of this Frame.",
          "!type": "fn(out: +Phaser.Rectangle) -> +Phaser.Rectangle"
        },
        "rotationDirection": {
          "!doc": "Either 'cw' or 'ccw', rotation is always 90 degrees.",
          "!type": "+String"
        },
        "height": {
          "!doc": "Height of the frame.",
          "!type": "+Number"
        }
      }
    },
    "RETROFONT": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "BUTTON": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "TILESPRITE": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Pointer": {
      "LEFT_BUTTON": "+Number",
      "MIDDLE_BUTTON": "+Number",
      "ERASER_BUTTON": "+Number",
      "RIGHT_BUTTON": "+Number",
      "FORWARD_BUTTON": "+Number",
      "!doc": "A Pointer object is used by the Mouse, Touch and MSPoint managers and represents a single finger on the touch screen.",
      "BACK_BUTTON": "+Number",
      "NO_BUTTON": "+Number",
      "!type": "fn(game: +Phaser.Game, id: +Number, pointerMode: +Phaser.PointerMode)",
      "prototype": {
        "rawMovementY": {
          "!doc": "The vertical raw relative movement of the Pointer in pixels since last event.",
          "!type": "+Number"
        },
        "rawMovementX": {
          "!doc": "The horizontal raw relative movement of the Pointer in pixels since last event.",
          "!type": "+Number"
        },
        "isMouse": {
          "!doc": "If the Pointer is a mouse or pen / stylus this is true, otherwise false.",
          "!type": "+Boolean"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "leave": {
          "!doc": "Called when the Pointer leaves the target area.",
          "!type": "fn(event: +MouseEvent)"
        },
        "id": {
          "!doc": "The ID of the Pointer object within the game. Each game can have up to 10 active pointers.",
          "!type": "+Number"
        },
        "addClickTrampoline": {
          "!doc": "Add a click trampoline to this pointer.\n\nA click trampoline is a callback that is run on the DOM 'click' event; this is primarily\nneeded with certain browsers (ie. IE11) which restrict some actions like requestFullscreen\nto the DOM 'click' event and rejects it for 'pointer*' and 'mouse*' events.\n\nThis is used internally by the ScaleManager; click trampoline usage is uncommon.\nClick trampolines can only be added to pointers that are currently down.",
          "!type": "fn(name: +String, callback: +Function, callbackContext: +Object, callbackArgs: +Array._object_)"
        },
        "identifier": {
          "!doc": "The identifier property of the Pointer as set by the DOM event when this Pointer is started.",
          "!type": "+Number"
        },
        "timeUp": {
          "!doc": "A timestamp representing when the Pointer left the touchscreen.",
          "!type": "+Number"
        },
        "clientY": {
          "!doc": "The vertical coordinate of the Pointer within the application's client area at which the event occurred (as opposed to the coordinates within the page).",
          "!type": "+Number"
        },
        "clientX": {
          "!doc": "The horizontal coordinate of the Pointer within the application's client area at which the event occurred (as opposed to the coordinates within the page).",
          "!type": "+Number"
        },
        "timeDown": {
          "!doc": "A timestamp representing when the Pointer first touched the touchscreen.",
          "!type": "+Number"
        },
        "active": {
          "!doc": "An active pointer is one that is currently pressed down on the display. A Mouse is always active.",
          "!type": "+Boolean"
        },
        "stop": {
          "!doc": "Called when the Pointer leaves the touchscreen.",
          "!type": "fn(event: +MouseEvent)"
        },
        "totalTouches": {
          "!doc": "The total number of times this Pointer has been touched to the touchscreen.",
          "!type": "+Number"
        },
        "reset": {
          "!doc": "Resets the Pointer properties. Called by InputManager.reset when you perform a State change.",
          "!type": "fn()"
        },
        "position": {
          "!doc": "A Phaser.Point object containing the current x/y values of the pointer on the display.",
          "!type": "+Phaser.Point"
        },
        "circle": {
          "!doc": "A Phaser.Circle that is centered on the x/y coordinates of this pointer, useful for hit detection.\nThe Circle size is 44px (Apples recommended \"finger tip\" size).",
          "!type": "+Phaser.Circle"
        },
        "screenX": {
          "!doc": "The horizontal coordinate of the Pointer relative to the screen.",
          "!type": "+Number"
        },
        "screenY": {
          "!doc": "The vertical coordinate of the Pointer relative to the screen.",
          "!type": "+Number"
        },
        "updateButtons": {
          "!doc": "Called when the event.buttons property changes from zero.\nContains a button bitmask.",
          "!type": "fn(event: +MouseEvent)"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "targetObject": {
          "!doc": "The Game Object this Pointer is currently over / touching / dragging.",
          "!type": "+Object"
        },
        "resetButtons": {
          "!doc": "Resets the states of all the button booleans.",
          "!type": "fn()"
        },
        "msSinceLastClick": {
          "!doc": "The number of milliseconds since the last click or touch event.",
          "!type": "+Number"
        },
        "update": {
          "!doc": "Called by the Input Manager.",
          "!type": "fn()"
        },
        "processInteractiveObjects": {
          "!doc": "Process all interactive objects to find out which ones were updated in the recent Pointer move.",
          "!type": "fn(fromClick: +Boolean) -> +Boolean"
        },
        "resetMovement": {
          "!doc": "Resets the movementX and movementY properties. Use in your update handler after retrieving the values.",
          "!type": "fn()"
        },
        "isDown": {
          "!doc": "If the Pointer is touching the touchscreen, or *any* mouse or pen button is held down, isDown is set to true.\nIf you need to check a specific mouse or pen button then use the button properties, i.e. Pointer.rightButton.isDown.",
          "!type": "+Boolean"
        },
        "pointerMode": {
          "!doc": "The operational mode of this pointer.",
          "!type": "+Phaser.PointerMode"
        },
        "button": {
          "!doc": "The button property of the most recent DOM event when this Pointer is started.\nYou should not rely on this value for accurate button detection, instead use the Pointer properties\n`leftButton`, `rightButton`, `middleButton` and so on.",
          "!type": "+Object"
        },
        "middleButton": {
          "!doc": "If this Pointer is a Mouse or Pen / Stylus then you can access its middle button directly through this property.\n\nThe DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\nbutton control.\n\nPlease see the DeviceButton docs for details on browser button limitations.",
          "!type": "+Phaser.DeviceButton"
        },
        "duration": {
          "!doc": "How long the Pointer has been depressed on the touchscreen or *any* of the mouse buttons have been held down.\nIf not currently down it returns -1.\nIf you need to test a specific mouse or pen button then access the buttons directly, i.e. `Pointer.rightButton.duration`.",
          "!type": "+Number"
        },
        "leftButton": {
          "!doc": "If this Pointer is a Mouse or Pen / Stylus then you can access its left button directly through this property.\n\nThe DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\nbutton control.",
          "!type": "+Phaser.DeviceButton"
        },
        "isUp": {
          "!doc": "If the Pointer is not touching the touchscreen, or *all* mouse or pen buttons are up, isUp is set to true.\nIf you need to check a specific mouse or pen button then use the button properties, i.e. Pointer.rightButton.isUp.",
          "!type": "+Boolean"
        },
        "previousTapTime": {
          "!doc": "A timestamp representing when the Pointer was last tapped or clicked.",
          "!type": "+Number"
        },
        "backButton": {
          "!doc": "If this Pointer is a Mouse or Pen / Stylus then you can access its X1 (back) button directly through this property.\n\nThe DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\nbutton control.\n\nPlease see the DeviceButton docs for details on browser button limitations.",
          "!type": "+Phaser.DeviceButton"
        },
        "justReleased": {
          "!doc": "The Pointer is considered justReleased if the time it left the touchscreen is less than justReleasedRate.\nNote that calling justReleased doesn't reset the pressed status of the Pointer, it will return `true` for as long as the duration is valid.\nIf you wish to check if the Pointer was released just once then see the Sprite.events.onInputUp event.",
          "!type": "fn(duration: +Number) -> +Boolean"
        },
        "justPressed": {
          "!doc": "The Pointer is considered justPressed if the time it was pressed onto the touchscreen or clicked is less than justPressedRate.\nNote that calling justPressed doesn't reset the pressed status of the Pointer, it will return `true` for as long as the duration is valid.\nIf you wish to check if the Pointer was pressed down just once then see the Sprite.events.onInputDown event.",
          "!type": "fn(duration: +Number) -> +Boolean"
        },
        "withinGame": {
          "!doc": "true if the Pointer is over the game canvas, otherwise false.",
          "!type": "+Boolean"
        },
        "dirty": {
          "!doc": "A dirty pointer needs to re-poll any interactive objects it may have been over, regardless if it has moved or not.",
          "!type": "+Boolean"
        },
        "move": {
          "!doc": "Called when the Pointer is moved.",
          "!type": "fn(event: +MouseEvent, fromClick: +Boolean)"
        },
        "movementY": {
          "!doc": "The vertical processed relative movement of the Pointer in pixels since last event.",
          "!type": "+Number"
        },
        "movementX": {
          "!doc": "The horizontal processed relative movement of the Pointer in pixels since last event.",
          "!type": "+Number"
        },
        "start": {
          "!doc": "Called when the Pointer is pressed onto the touchscreen.",
          "!type": "fn(event: +Object)"
        },
        "positionDown": {
          "!doc": "A Phaser.Point object containing the x/y values of the pointer when it was last in a down state on the display.",
          "!type": "+Phaser.Point"
        },
        "target": {
          "!doc": "The target property of the Pointer as set by the DOM event when this Pointer is started.",
          "!type": "+Object"
        },
        "pointerId": {
          "!doc": "The pointerId property of the Pointer as set by the DOM event when this Pointer is started. The browser can and will recycle this value.",
          "!type": "+Number"
        },
        "positionUp": {
          "!doc": "A Phaser.Point object containing the x/y values of the pointer when it was last released.",
          "!type": "+Phaser.Point"
        },
        "forwardButton": {
          "!doc": "If this Pointer is a Mouse or Pen / Stylus then you can access its X2 (forward) button directly through this property.\n\nThe DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\nbutton control.\n\nPlease see the DeviceButton docs for details on browser button limitations.",
          "!type": "+Phaser.DeviceButton"
        },
        "x": {
          "!doc": "The horizontal coordinate of the Pointer. This value is automatically scaled based on the game scale.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "A Pointer object that exists is allowed to be checked for physics collisions and overlaps.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The vertical coordinate of the Pointer. This value is automatically scaled based on the game scale.",
          "!type": "+Number"
        },
        "rightButton": {
          "!doc": "If this Pointer is a Mouse or Pen / Stylus then you can access its right button directly through this property.\n\nThe DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\nbutton control.\n\nPlease see the DeviceButton docs for details on browser button limitations.",
          "!type": "+Phaser.DeviceButton"
        },
        "eraserButton": {
          "!doc": "If this Pointer is a Pen / Stylus then you can access its eraser button directly through this property.\n\nThe DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained\nbutton control.\n\nPlease see the DeviceButton docs for details on browser button limitations.",
          "!type": "+Phaser.DeviceButton"
        },
        "pageY": {
          "!doc": "The vertical coordinate of the Pointer relative to whole document.",
          "!type": "+Number"
        },
        "pageX": {
          "!doc": "The horizontal coordinate of the Pointer relative to whole document.",
          "!type": "+Number"
        }
      }
    },
    "GROUP": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Signal": {
      "!doc": "Signals are what Phaser uses to handle events and event dispatching.\nYou can listen for a Signal by binding a callback / function to it.\nThis is done by using either `Signal.add` or `Signal.addOnce`.\n\nFor example you can listen for a touch or click event from the Input Manager \nby using its `onDown` Signal:\n\n`game.input.onDown.add(function() { ... });`\n\nRather than inline your function, you can pass a reference:\n\n`game.input.onDown.add(clicked, this);`\n`function clicked () { ... }`\n\nIn this case the second argument (`this`) is the context in which your function should be called.\n\nNow every time the InputManager dispatches the `onDown` signal (or event), your function\nwill be called.\n\nVery often a Signal will send arguments to your function.\nThis is specific to the Signal itself.\nIf you're unsure then check the documentation, or failing that simply do:\n\n`Signal.add(function() { console.log(arguments); })`\n\nand it will log all of the arguments your function received from the Signal.\n\nSprites have lots of default signals you can listen to in their Events class, such as:\n\n`sprite.events.onKilled`\n\nWhich is called automatically whenever the Sprite is killed.\nThere are lots of other events, see the Events component for a list.\n\nAs well as listening to pre-defined Signals you can also create your own:\n\n`var mySignal = new Phaser.Signal();`\n\nThis creates a new Signal. You can bind a callback to it:\n\n`mySignal.add(myCallback, this);`\n\nand then finally when ready you can dispatch the Signal:\n\n`mySignal.dispatch(your arguments);`\n\nAnd your callback will be invoked. See the dispatch method for more details.",
      "!type": "fn()",
      "prototype": {
        "add": {
          "!doc": "Add an event listener for this signal.\n\nAn event listener is a callback with a related context and priority.\n\nYou can optionally provide extra arguments which will be passed to the callback after any internal parameters.\n\nFor example: `Phaser.Key.onDown` when dispatched will send the Phaser.Key object that caused the signal as the first parameter.\nAny arguments you've specified after `priority` will be sent as well:\n\n`fireButton.onDown.add(shoot, this, 0, 'lazer', 100);`\n\nWhen onDown dispatches it will call the `shoot` callback passing it: `Phaser.Key, 'lazer', 100`.\n\nWhere the first parameter is the one that Key.onDown dispatches internally and 'lazer', \nand the value 100 were the custom arguments given in the call to 'add'.",
          "!type": "fn(listener: +Function, listenerContext: +Object, priority: +Number, args: +Object) -> +Phaser.SignalBinding"
        },
        "dispatch": {
          "!doc": "Dispatch / broadcast the event to all listeners.\n\nTo create an instance-bound dispatch for this Signal, use {@link #boundDispatch}.",
          "!type": "fn(params: +Object)"
        },
        "addOnce": {
          "!doc": "Add a one-time listener - the listener is automatically removed after the first execution.\n\nIf there is as {@link Phaser.Signal#memorize memorized} event then it will be dispatched and\nthe listener will be removed immediately.",
          "!type": "fn(listener: +Function, listenerContext: +Object, priority: +Number, args: +Object) -> +Phaser.SignalBinding"
        },
        "active": {
          "!doc": "Is the Signal active? Only active signals will broadcast dispatched events.\n\nSetting this property during a dispatch will only affect the next dispatch. To stop the propagation of a signal from a listener use {@link #halt}.",
          "!type": "+Boolean"
        },
        "remove": {
          "!doc": "Remove a single event listener.",
          "!type": "fn(listener: +Function, context: +Object) -> +Function"
        },
        "getNumListeners": {
          "!doc": "Gets the total number of listeners attached to this Signal.",
          "!type": "fn() -> +Number"
        },
        "halt": {
          "!doc": "Stop propagation of the event, blocking the dispatch to next listener on the queue.\n\nThis should be called only during event dispatch as calling it before/after dispatch won't affect another broadcast.\nSee {@link #active} to enable/disable the signal entirely.",
          "!type": "fn()"
        },
        "removeAll": {
          "!doc": "Remove all event listeners.",
          "!type": "fn(context: +Object)"
        },
        "forget": {
          "!doc": "Forget the currently {@link Phaser.Signal#memorize memorized} event, if any.",
          "!type": "fn()"
        },
        "dispose": {
          "!doc": "Dispose the signal - no more events can be dispatched.\n\nThis removes all event listeners and clears references to external objects.\nCalling methods on a disposed objects results in undefined behavior.",
          "!type": "fn()"
        },
        "toString": {
          "!doc": "A string representation of the object.",
          "!type": "fn() -> +String"
        },
        "has": {
          "!doc": "Check if a specific listener is attached.",
          "!type": "fn(listener: +Function, context: +Object) -> +Boolean"
        },
        "memorize": {
          "!doc": "Memorize the previously dispatched event?\n\nIf an event has been memorized it is automatically dispatched when a new listener is added with {@link #add} or {@link #addOnce}.\nUse {@link #forget} to clear any currently memorized event.",
          "!type": "+Boolean"
        }
      }
    },
    "Events": {
      "!doc": "The Events component is a collection of events fired by the parent game object.\n\nFor example to tell when a Sprite has been added to a new group:\n\n`sprite.events.onAddedToGroup.add(yourFunction, this);`\n\nWhere `yourFunction` is the function you want called when this event occurs.\n\nThe Input-related events will only be dispatched if the Sprite has had `inputEnabled` set to `true`\nand the Animation-related events only apply to game objects with animations like {@link Phaser.Sprite}.",
      "!type": "fn(sprite: +Phaser.Sprite)",
      "prototype": {
        "parent": {
          "!doc": "The Sprite that owns these events.",
          "!type": "+Phaser.Sprite"
        },
        "onDestroy": {
          "!doc": "This signal is dispatched when the parent is destroyed.",
          "!type": "+Phaser.Signal"
        },
        "onAnimationComplete": {
          "!doc": "This signal is dispatched when the parent has an animation that finishes playing.",
          "!type": "+Phaser.Signal"
        },
        "onAddedToGroup": {
          "!doc": "This signal is dispatched when the parent is added to a new Group.",
          "!type": "+Phaser.Signal"
        },
        "onDragUpdate": {
          "!doc": "This signal is dispatched if the parent is inputEnabled and receives a drag update event from a Pointer.",
          "!type": "+Phaser.Signal"
        },
        "onRemovedFromWorld": {
          "!doc": "This signal is dispatched if this item or any of its parents are removed from the game world.",
          "!type": "+Phaser.Signal"
        },
        "onRevived": {
          "!doc": "This signal is dispatched when the parent is revived.",
          "!type": "+Phaser.Signal"
        },
        "onEnterBounds": {
          "!doc": "This signal is dispatched when the parent returns within the world bounds (only if Sprite.checkWorldBounds is true).",
          "!type": "+Phaser.Signal"
        },
        "destroy": {
          "!doc": "Removes all events.",
          "!type": "fn()"
        },
        "onInputOut": {
          "!doc": "This signal is dispatched if the parent is inputEnabled and receives an out event from a Pointer.",
          "!type": "+Phaser.Signal"
        },
        "onInputDown": {
          "!doc": "This signal is dispatched if the parent is inputEnabled and receives a down event from a Pointer.",
          "!type": "+Phaser.Signal"
        },
        "onInputUp": {
          "!doc": "This signal is dispatched if the parent is inputEnabled and receives an up event from a Pointer.",
          "!type": "+Phaser.Signal"
        },
        "onOutOfBounds": {
          "!doc": "This signal is dispatched when the parent leaves the world bounds (only if Sprite.checkWorldBounds is true).",
          "!type": "+Phaser.Signal"
        },
        "onAnimationLoop": {
          "!doc": "This signal is dispatched when the parent has an animation that loops playback.",
          "!type": "+Phaser.Signal"
        },
        "onRemovedFromGroup": {
          "!doc": "This signal is dispatched when the parent is removed from a Group.",
          "!type": "+Phaser.Signal"
        },
        "onKilled": {
          "!doc": "This signal is dispatched when the parent is killed.",
          "!type": "+Phaser.Signal"
        },
        "onInputOver": {
          "!doc": "This signal is dispatched if the parent is inputEnabled and receives an over event from a Pointer.",
          "!type": "+Phaser.Signal"
        },
        "onDragStop": {
          "!doc": "This signal is dispatched if the parent is inputEnabled and receives a drag stop event from a Pointer.",
          "!type": "+Phaser.Signal"
        },
        "onDragStart": {
          "!doc": "This signal is dispatched if the parent is inputEnabled and receives a drag start event from a Pointer.",
          "!type": "+Phaser.Signal"
        },
        "onAnimationStart": {
          "!doc": "This signal is dispatched when the parent has an animation that is played.",
          "!type": "+Phaser.Signal"
        }
      }
    },
    "CANVAS": {
      "!doc": "Canvas Renderer.",
      "!type": "+Number"
    },
    "SinglePad": {
      "!doc": "A single Phaser Gamepad",
      "!type": "fn(game: +Phaser.Game, padParent: +Object)",
      "prototype": {
        "disconnect": {
          "!doc": "Gamepad disconnect function, should be called by Phaser.Gamepad.",
          "!type": "fn()"
        },
        "game": {
          "!doc": "Local reference to game.",
          "!type": "+Phaser.Game"
        },
        "buttonValue": {
          "!doc": "Returns the value of a gamepad button. Intended mainly for cases when you have floating button values, for example\nanalog trigger buttons on the XBOX 360 controller.",
          "!type": "fn(buttonCode: +Number) -> +Number"
        },
        "onUpCallback": {
          "!doc": "This callback is invoked every time a gamepad button is released.",
          "!type": "+Function"
        },
        "axis": {
          "!doc": "Returns value of requested axis.",
          "!type": "fn(axisCode: +Number) -> +Number"
        },
        "deadZone": {
          "!doc": "Dead zone for axis feedback - within this value you won't trigger updates.",
          "!type": "+Number"
        },
        "isDown": {
          "!doc": "Returns true if the button is pressed down.",
          "!type": "fn(buttonCode: +Number) -> +Boolean"
        },
        "getButton": {
          "!doc": "Gets a DeviceButton object from this controller to be stored and referenced locally.\nThe DeviceButton object can then be polled, have events attached to it, etc.",
          "!type": "fn(buttonCode: +Number) -> +Phaser.DeviceButton"
        },
        "processButtonDown": {
          "!doc": "Handles button down press.",
          "!type": "fn(buttonCode: +Number, value: +Object)"
        },
        "isUp": {
          "!doc": "Returns true if the button is not currently pressed.",
          "!type": "fn(buttonCode: +Number) -> +Boolean"
        },
        "justReleased": {
          "!doc": "Returns the \"just released\" state of a button from this gamepad. Just released is considered as being true if the button was released within the duration given (default 250ms).",
          "!type": "fn(buttonCode: +Number, duration: +Number) -> +Boolean"
        },
        "connect": {
          "!doc": "Gamepad connect function, should be called by Phaser.Gamepad.",
          "!type": "fn(rawPad: +Object)"
        },
        "justPressed": {
          "!doc": "Returns the \"just pressed\" state of a button from this gamepad. Just pressed is considered true if the button was pressed down within the duration given (default 250ms).",
          "!type": "fn(buttonCode: +Number, duration: +Number) -> +Boolean"
        },
        "addCallbacks": {
          "!doc": "Add callbacks to this Gamepad to handle connect / disconnect / button down / button up / axis change / float value buttons.",
          "!type": "fn(context: +Object, callbacks: +Object)"
        },
        "processAxisChange": {
          "!doc": "Handles changes in axis.",
          "!type": "fn(axisState: +Object)"
        },
        "destroy": {
          "!doc": "Destroys this object and associated callback references.",
          "!type": "fn()"
        },
        "index": {
          "!doc": "The gamepad index as per browsers data",
          "!type": "+Number"
        },
        "onFloatCallback": {
          "!doc": "This callback is invoked every time a button is changed to a value where value > 0 and value < 1.",
          "!type": "+Function"
        },
        "callbackContext": {
          "!doc": "The context under which the callbacks are run.",
          "!type": "+Object"
        },
        "connected": {
          "!doc": "Whether or not this particular gamepad is connected or not.",
          "!type": "+Boolean"
        },
        "pollStatus": {
          "!doc": "Main update function called by Phaser.Gamepad.",
          "!type": "fn()"
        },
        "onDownCallback": {
          "!doc": "This callback is invoked every time a button is pressed down.",
          "!type": "+Function"
        },
        "onDisconnectCallback": {
          "!doc": "This callback is invoked every time this gamepad is disconnected",
          "!type": "+Function"
        },
        "processButtonUp": {
          "!doc": "Handles button release.",
          "!type": "fn(buttonCode: +Number, value: +Object)"
        },
        "onConnectCallback": {
          "!doc": "This callback is invoked every time this gamepad is connected",
          "!type": "+Function"
        },
        "processButtonFloat": {
          "!doc": "Handles buttons with floating values (like analog buttons that acts almost like an axis but still registers like a button)",
          "!type": "fn(buttonCode: +Number, value: +Object)"
        },
        "reset": {
          "!doc": "Reset all buttons/axes of this gamepad.",
          "!type": "fn()"
        },
        "onAxisCallback": {
          "!doc": "This callback is invoked every time an axis is changed.",
          "!type": "+Function"
        }
      }
    },
    "HEADLESS": {
      "!doc": "Headless renderer (not visual output)",
      "!type": "+Number"
    },
    "ImageCollection": {
      "!doc": "An Image Collection is a special tileset containing mulitple images, with no slicing into each image.\n\nImage Collections are normally created automatically when Tiled data is loaded.",
      "!type": "fn(name: +String, firstgid: +Number, width: +Number, height: +Number, margin: +Number, spacing: +Number, properties: +Object)",
      "prototype": {
        "imageWidth": {
          "!doc": "The width of the widest image (in pixels).",
          "!type": "+Number"
        },
        "imageSpacing": {
          "!doc": "The spacing between each image in the collection (in pixels).\nUse `setSpacing` to change.",
          "!type": "+Number"
        },
        "images": {
          "!doc": "The cached images that are a part of this collection.",
          "!type": "+Array"
        },
        "total": {
          "!doc": "The total number of images in the image collection.",
          "!type": "+Number"
        },
        "addImage": {
          "!doc": "Add an image to this Image Collection.",
          "!type": "fn(gid: +Number, image: +String)"
        },
        "name": {
          "!doc": "The name of the Image Collection.",
          "!type": "+String"
        },
        "containsImageIndex": {
          "!doc": "Returns true if and only if this image collection contains the given image index.",
          "!type": "fn(imageIndex: +Number) -> +Boolean"
        },
        "firstgid": {
          "!doc": "The Tiled firstgid value.\nThis is the starting index of the first image index this Image Collection contains.",
          "!type": "+Number"
        },
        "imageMarge": {
          "!doc": "The margin around the images in the collection (in pixels).\nUse `setSpacing` to change.",
          "!type": "+Number"
        },
        "imageHeight": {
          "!doc": "The height of the tallest image (in pixels).",
          "!type": "+Number"
        },
        "properties": {
          "!doc": "Image Collection-specific properties that are typically defined in the Tiled editor.",
          "!type": "+Object"
        }
      }
    },
    "MSPointer": {
      "!doc": "The MSPointer class handles Microsoft touch interactions with the game and the resulting Pointer objects.\n\nIt will work only in Internet Explorer 10+ and Windows Store or Windows Phone 8 apps using JavaScript.\nhttp://msdn.microsoft.com/en-us/library/ie/hh673557(v=vs.85).aspx\n\nYou should not normally access this class directly, but instead use a Phaser.Pointer object which \nnormalises all game input for you including accurate button handling.\n\nPlease note that at the current time of writing Phaser does not yet support chorded button interactions:\nhttp://www.w3.org/TR/pointerevents/#chorded-button-interactions",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "pointerMoveCallback": {
          "!doc": "A callback that can be fired on a MSPointerMove event.",
          "!type": "+Function"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "pointerDownCallback": {
          "!doc": "A callback that can be fired on a MSPointerDown event.",
          "!type": "+Function"
        },
        "start": {
          "!doc": "Starts the event listeners running.",
          "!type": "fn()"
        },
        "capture": {
          "!doc": "If true the Pointer events will have event.preventDefault applied to them, if false they will propagate fully.",
          "!type": "+Boolean"
        },
        "callbackContext": {
          "!doc": "The context under which callbacks are called (defaults to game).",
          "!type": "+Object"
        },
        "onPointerUp": {
          "!doc": "The function that handles the PointerUp event.",
          "!type": "fn(event: +PointerEvent)"
        },
        "pointerUpCallback": {
          "!doc": "A callback that can be fired on a MSPointerUp event.",
          "!type": "+Function"
        },
        "enabled": {
          "!doc": "MSPointer input will only be processed if enabled.",
          "!type": "+Boolean"
        },
        "onPointerMove": {
          "!doc": "The function that handles the PointerMove event.",
          "!type": "fn(event: +PointerEvent)"
        },
        "button": {
          "!doc": "This property was removed in Phaser 2.4 and should no longer be used.\nInstead please see the Pointer button properties such as `Pointer.leftButton`, `Pointer.rightButton` and so on.\nOr Pointer.button holds the DOM event button value if you require that.",
          "!type": "+Number"
        },
        "input": {
          "!doc": "A reference to the Phaser Input Manager.",
          "!type": "+Phaser.Input"
        },
        "stop": {
          "!doc": "Stop the event listeners.",
          "!type": "fn()"
        },
        "onPointerDown": {
          "!doc": "The function that handles the PointerDown event.",
          "!type": "fn(event: +PointerEvent)"
        },
        "onPointerOut": {
          "!doc": "The internal method that handles the pointer out event from the browser.",
          "!type": "fn(event: +PointerEvent)"
        },
        "event": {
          "!doc": "The browser MSPointer DOM event. Will be null if no event has ever been received.\nAccess this property only inside a Pointer event handler and do not keep references to it.",
          "!type": "+MSPointerEvent"
        },
        "onPointerUpGlobal": {
          "!doc": "The internal method that handles the mouse up event from the window.",
          "!type": "fn(event: +PointerEvent)"
        }
      }
    },
    "RIGHT": {
      "!doc": "Direction constant.",
      "!type": "+Number"
    },
    "PointerMode": {
      "CONTACT": "+Object",
      "!doc": "Enumeration categorizing operational modes of pointers.\n\nPointerType values represent valid bitmasks.\nFor example, a value representing both Mouse and Touch devices\ncan be expressed as `PointerMode.CURSOR | PointerMode.CONTACT`.\n\nValues may be added for future mode categorizations.",
      "!type": "fn()",
      "prototype": {},
      "CURSOR": "+Object"
    },
    "KeyCode": {
      "UNDERSCORE": "+Number",
      "FOUR": "+Number",
      "MINUS": "+Number",
      "NUMPAD_ADD": "+Number",
      "LEFT": "+Number",
      "NUMPAD_DECIMAL": "+Number",
      "TWO": "+Number",
      "NUMPAD_2": "+Number",
      "NUMPAD_3": "+Number",
      "NUMPAD_4": "+Number",
      "NUMPAD_5": "+Number",
      "NUMPAD_6": "+Number",
      "NUMPAD_7": "+Number",
      "NUMPAD_8": "+Number",
      "NUMPAD_9": "+Number",
      "A": "+Number",
      "B": "+Number",
      "C": "+Number",
      "D": "+Number",
      "E": "+Number",
      "F": "+Number",
      "NUMPAD_0": "+Number",
      "G": "+Number",
      "ONE": "+Number",
      "NUMPAD_1": "+Number",
      "H": "+Number",
      "I": "+Number",
      "ENTER": "+Number",
      "J": "+Number",
      "K": "+Number",
      "L": "+Number",
      "M": "+Number",
      "N": "+Number",
      "O": "+Number",
      "P": "+Number",
      "Q": "+Number",
      "R": "+Number",
      "DELETE": "+Number",
      "S": "+Number",
      "T": "+Number",
      "ESC": "+Number",
      "U": "+Number",
      "V": "+Number",
      "W": "+Number",
      "X": "+Number",
      "Y": "+Number",
      "RIGHT": "+Number",
      "Z": "+Number",
      "SEVEN": "+Number",
      "COMMA": "+Number",
      "HELP": "+Number",
      "BACKWARD_SLASH": "+Number",
      "!doc": "A key code represents a physical key on a keyboard.\n\nThe KeyCode class contains commonly supported keyboard key codes which can be used\nas keycode`-parameters in several {@link Phaser.Keyboard} and {@link Phaser.Key} methods.\n\n_Note_: These values should only be used indirectly, eg. as `Phaser.KeyCode.KEY`.\nFuture versions may replace the actual values, such that they remain compatible with `keycode`-parameters.\nThe current implementation maps to the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode KeyboardEvent.keyCode} property.\n\n_Note_: Use `Phaser.KeyCode.KEY` instead of `Phaser.Keyboard.KEY` to refer to a key code;\nthe latter approach is supported for compatibility.",
      "prototype": {},
      "TAB": "+Number",
      "QUOTES": "+Number",
      "ZERO": "+Number",
      "EIGHT": "+Number",
      "DOWN": "+Number",
      "ALT": "+Number",
      "FIVE": "+Number",
      "QUESTION_MARK": "+Number",
      "NINE": "+Number",
      "BACKSPACE": "+Number",
      "UP": "+Number",
      "F1": "+Number",
      "F2": "+Number",
      "NUMPAD_ENTER": "+Number",
      "F3": "+Number",
      "PAGE_UP": "+Number",
      "F4": "+Number",
      "F5": "+Number",
      "F6": "+Number",
      "F7": "+Number",
      "F8": "+Number",
      "F9": "+Number",
      "NUM_LOCK": "+Number",
      "PERIOD": "+Number",
      "END": "+Number",
      "INSERT": "+Number",
      "THREE": "+Number",
      "CONTROL": "+Number",
      "PLUS": "+Number",
      "CAPS_LOCK": "+Number",
      "SIX": "+Number",
      "NUMPAD_DIVIDE": "+Number",
      "PAGE_DOWN": "+Number",
      "SHIFT": "+Number",
      "NUMPAD_MULTIPLY": "+Number",
      "CLOSED_BRACKET": "+Number",
      "!type": "fn()",
      "SPACEBAR": "+Number",
      "F10": "+Number",
      "EQUALS": "+Number",
      "F12": "+Number",
      "F11": "+Number",
      "F14": "+Number",
      "OPEN_BRACKET": "+Number",
      "F13": "+Number",
      "COLON": "+Number",
      "F15": "+Number",
      "NUMPAD_SUBTRACT": "+Number",
      "TILDE": "+Number",
      "CLEAR": "+Number",
      "HOME": "+Number"
    },
    "BITMAPDATA": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Text": {
      "init": {
        "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
        "!type": "fn()"
      },
      "install": {
        "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
        "!type": "fn()"
      },
      "!doc": "Create a new game object for displaying Text.\n\nThis uses a local hidden Canvas object and renders the type into it. It then makes a texture from this for rendering to the view.\nBecause of this you can only display fonts that are currently loaded and available to the browser: fonts must be pre-loaded.\n\nSee {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts across mobile browsers.",
      "!type": "fn(game: +Phaser.Game, x: +Number, y: +Number, text: +String, style: +Object, style_font: +String, style_fontStyle: +String, style_fontVariant: +String, style_fontWeight: +String, style_fontSize: +String, style_backgroundColor: +String, style_fill: +String, style_align: +String, style_boundsAlignH: +String, style_boundsAlignV: +String, style_stroke: +String, style_strokeThickness: +Number, style_wordWrap: +Boolean, style_wordWrapWidth: +Number, style_maxLines: +Number, style_tabs: +Number)",
      "prototype": {
        "play": {
          "!doc": "Plays an Animation.\n\nThe animation should have previously been created via `animations.add`.\n\nIf the animation is already playing calling this again won't do anything.\nIf you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.",
          "!type": "fn(name: +String, frameRate: +Number, loop: +Boolean, killOnComplete: +Boolean) -> +Phaser.Animation"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "lifespan": {
          "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
          "!type": "+Number"
        },
        "outOfBoundsKill": {
          "!doc": "If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.",
          "!type": "+Boolean"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "updateShadow": {
          "!doc": "Sets the Shadow on the Text.context based on the Style settings, or disables it if not enabled.\nThis is called automatically by Text.updateText.",
          "!type": "fn(state: +Boolean)"
        },
        "resolution": {
          "!doc": "The resolution of the canvas the text is rendered to.\nThis defaults to match the resolution of the renderer, but can be changed on a per Text object basis.",
          "!type": "+Number"
        },
        "getBounds": {
          "!doc": "Returns the bounds of the Text as a rectangle.\nThe bounds calculation takes the worldTransform into account.",
          "!type": "fn(matrix: +Phaser.Matrix) -> +Phaser.Rectangle"
        },
        "resizeFrame": {
          "!doc": "Resizes the Frame dimensions that the Game Object uses for rendering.\n\nYou shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData\nit can be useful to adjust the dimensions directly in this way.",
          "!type": "fn(parent: +Object, width: +Number, height: +Number)"
        },
        "useAdvancedWrap": {
          "!doc": "Will this Text object use Basic or Advanced Word Wrapping?\n\nAdvanced wrapping breaks long words if they are the first of a line, and repeats the process as necessary.\nWhite space is condensed (e.g., consecutive spaces are replaced with one).\nLines are trimmed of white space before processing.\n\nIt throws an error if wordWrapWidth is less than a single character.",
          "!type": "+Boolean"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "context": {
          "!doc": "The context of the canvas element that the text is rendered to.",
          "!type": "+HTMLCanvasElement"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "maxHealth": {
          "!doc": "The Game Objects maximum health value. This works in combination with the `heal` method to ensure\nthe health value never exceeds the maximum.",
          "!type": "+Number"
        },
        "revive": {
          "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
          "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
        },
        "text": {
          "!doc": "The text to be displayed by this Text object.\nUse a \\n to insert a carriage return and split the text.\nThe text will be rendered with any style currently set.",
          "!type": "+String"
        },
        "clearFontValues": {
          "!doc": "Clears any text styles or weights font that were set by `addFontStyle` or `addFontWeight`.",
          "!type": "fn() -> +Phaser.Text"
        },
        "shadowColor": {
          "!doc": "The color of the shadow, as given in CSS rgba format. Set the alpha component to 0 to disable the shadow.",
          "!type": "+String"
        },
        "bringToTop": {
          "!doc": "Brings this Game Object to the top of its parents display list.\nVisually this means it will render over the top of any old child in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "events": {
          "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
          "!type": "+Phaser.Events"
        },
        "moveUp": {
          "!doc": "Moves this Game Object up one place in its parents display list.\nThis call has no effect if the Game Object is already at the top of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "height": {
          "!doc": "The height of the Text. Setting this will modify the scale to achieve the value requested.",
          "!type": "+Number"
        },
        "canvas": {
          "!doc": "The canvas element that the text is rendered.",
          "!type": "+HTMLCanvasElement"
        },
        "postUpdate": {
          "!doc": "Internal method called by the World postUpdate cycle.",
          "!type": "fn()"
        },
        "smoothed": {
          "!doc": "Enable or disable texture smoothing for this Game Object.\n\nIt only takes effect if the Game Object is using an image based texture.\n\nSmoothing is enabled by default.",
          "!type": "+Boolean"
        },
        "destroy": {
          "!doc": "Destroy this Text object, removing it from the group it belongs to.",
          "!type": "fn(destroyChildren: +Boolean)"
        },
        "fontStyle": {
          "!doc": "The style of the font: 'normal', 'italic', 'oblique'",
          "!type": "+String"
        },
        "input": {
          "!doc": "The Input Handler for this Game Object.\n\nBy default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.\n\nAfter you have done this, this property will be a reference to the Phaser InputHandler.",
          "!type": "+Phaser.InputHandler"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "addStrokeColor": {
          "!doc": "Set specific stroke colors for certain characters within the Text.\n\nIt works by taking a color value, which is a typical HTML string such as `#ff0000` or `rgb(255,0,0)` and a position.\nThe position value is the index of the character in the Text string to start applying this color to.\nOnce set the color remains in use until either another color or the end of the string is encountered.\nFor example if the Text was `Photon Storm` and you did `Text.addColor('#ffff00', 6)` it would color in the word `Storm` in yellow.\n\nThis has no effect if stroke is disabled or has a thickness of 0.\n\nIf you wish to change the text fill color see addColor instead.",
          "!type": "fn(color: +String, position: +Number) -> +Phaser.Text"
        },
        "left": {
          "!doc": "The left coordinate of the Game Object.\nThis is the same as `x - offsetX`.",
          "!type": "+Number"
        },
        "reset": {
          "!doc": "Resets the Game Object.\n\nThis moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`, \n`visible` and `renderable` to true.\n\nIf this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.\n\nIf this Game Object has a Physics Body it will reset the Body.",
          "!type": "fn(x: +Number, y: +Number, health: +Number) -> +PIXI.DisplayObject"
        },
        "setTextBounds": {
          "!doc": "The Text Bounds is a rectangular region that you control the dimensions of into which the Text object itself is positioned,\nregardless of the number of lines in the text, the font size or any other attribute.\n\nAlignment is controlled via the properties `boundsAlignH` and `boundsAlignV` within the Text.style object, or can be directly\nset through the setters `Text.boundsAlignH` and `Text.boundsAlignV`. Bounds alignment is independent of text alignment.\n\nFor example: If your game is 800x600 in size and you set the text bounds to be 0,0,800,600 then by setting boundsAlignH to\n'center' and boundsAlignV to 'bottom' the text will render in the center and at the bottom of your game window, regardless of\nhow many lines of text there may be. Even if you adjust the text content or change the style it will remain at the bottom center\nof the text bounds.\n\nThis is especially powerful when you need to align text against specific coordinates in your game, but the actual text dimensions\nmay vary based on font (say for multi-lingual games).\n\nIf `Text.wordWrapWidth` is greater than the width of the text bounds it is clamped to match the bounds width.\n\nCall this method with no arguments given to reset an existing textBounds.\n\nIt works by calculating the final position based on the Text.canvas size, which is modified as the text is updated. Some fonts\nhave additional padding around them which you can mitigate by tweaking the Text.padding property. It then adjusts the `pivot`\nproperty based on the given bounds and canvas size. This means if you need to set the pivot property directly in your game then\nyou either cannot use `setTextBounds` or you must place the Text object inside another DisplayObject on which you set the pivot.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number) -> +Phaser.Text"
        },
        "fontSize": {
          "!doc": "The size of the font.\n\nIf the font size is specified in pixels (eg. `32` or `'32px`') then a number (ie. `32`) representing\nthe font size in pixels is returned; otherwise the value with CSS unit is returned as a string (eg. `'12pt'`).",
          "!type": "+Number"
        },
        "preUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn()"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "damage": {
          "!doc": "Damages the Game Object. This removes the given amount of health from the `health` property.\n\nIf health is taken below or is equal to zero then the `kill` method is called.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "shadowOffsetX": {
          "!doc": "The shadowOffsetX value in pixels. This is how far offset horizontally the shadow effect will be.",
          "!type": "+Number"
        },
        "shadowOffsetY": {
          "!doc": "The shadowOffsetY value in pixels. This is how far offset vertically the shadow effect will be.",
          "!type": "+Number"
        },
        "components": {
          "!doc": "The components this Game Object has installed.",
          "!type": "+Object"
        },
        "addFontWeight": {
          "!doc": "Set specific font weights for certain characters within the Text.\n\nIt works by taking a font weight value, which is a typical string such as `normal`, `bold`, `bolder`, etc.\nThe position value is the index of the character in the Text string to start applying this font weight to.\nOnce set the font weight remains in use until either another font weight or the end of the string is encountered.\nFor example if the Text was `Photon Storm` and you did `Text.addFontWeight('bold', 6)` it would font weight in the word `Storm` in bold.\n\nIf you wish to change the text font style see addFontStyle instead.",
          "!type": "fn(style: +String, position: +Number) -> +Phaser.Text"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
          "!type": "+Boolean"
        },
        "parseList": {
          "!doc": "Converts the given array into a tab delimited string and then updates this Text object.\nThis is mostly used when you want to display external data using tab stops.\n\nThe array can be either single or multi dimensional depending on the result you need:\n\n`[ 'a', 'b', 'c' ]` would convert in to `\"a\\tb\\tc\"`.\n\nWhere as:\n\n`[\n     [ 'a', 'b', 'c' ],\n     [ 'd', 'e', 'f']\n]`\n\nwould convert in to: `\"a\\tb\\tc\\nd\\te\\tf\"`",
          "!type": "fn(list: +Array) -> +Phaser.Text"
        },
        "tabs": {
          "!doc": "The size (in pixels) of the tabs, for when text includes tab characters. 0 disables. \nCan be an integer or an array of varying tab sizes, one tab per element.\nFor example if you set tabs to 100 then when Text encounters a tab it will jump ahead 100 pixels.\nIf you set tabs to be `[100,200]` then it will set the first tab at 100px and the second at 200px.",
          "!type": "+Number"
        },
        "transformCallback": {
          "!doc": "The callback that will apply any scale limiting to the worldTransform.",
          "!type": "+Function"
        },
        "inWorld": {
          "!doc": "Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.",
          "!type": "+Boolean"
        },
        "colors": {
          "!doc": "An array of the color values as specified by {@link Phaser.Text#addColor addColor}.",
          "!type": "+Array"
        },
        "cssFont": {
          "!doc": "Change the font used.\n\nThis is equivalent of the `font` property specified to {@link Phaser.Text#setStyle setStyle}, except\nthat unlike using `setStyle` this will not change any current font fill/color settings.\n\nThe CSS font string can also be individually altered with the `font`, `fontSize`, `fontWeight`, `fontStyle`, and `fontVariant` properties.",
          "!type": "+String"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "fontStyles": {
          "!doc": "An array of the font styles values as specified by {@link Phaser.Text#addFontStyle addFontStyle}.",
          "!type": "+Array"
        },
        "setShadow": {
          "!doc": "Sets a drop shadow effect on the Text. You can specify the horizontal and vertical distance of the drop shadow with the `x` and `y` parameters.\nThe color controls the shade of the shadow (default is black) and can be either an `rgba` or `hex` value.\nThe blur is the strength of the shadow. A value of zero means a hard shadow, a value of 10 means a very soft shadow.\nTo remove a shadow already in place you can call this method with no parameters set.",
          "!type": "fn(x: +Number, y: +Number, color: +String, blur: +Number, shadowStroke: +Boolean, shadowFill: +Boolean) -> +Phaser.Text"
        },
        "autoRound": {
          "!doc": "Should the linePositionX and Y values be automatically rounded before rendering the Text?\nYou may wish to enable this if you want to remove the effect of sub-pixel aliasing from text.",
          "!type": "+Boolean"
        },
        "world": {
          "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
          "!type": "+Phaser.Point"
        },
        "top": {
          "!doc": "The y coordinate of the Game Object.\nThis is the same as `y - offsetY`.",
          "!type": "+Number"
        },
        "addFontStyle": {
          "!doc": "Set specific font styles for certain characters within the Text.\n\nIt works by taking a font style value, which is a typical string such as `normal`, `italic` or `oblique`.\nThe position value is the index of the character in the Text string to start applying this font style to.\nOnce set the font style remains in use until either another font style or the end of the string is encountered.\nFor example if the Text was `Photon Storm` and you did `Text.addFontStyle('italic', 6)` it would font style in the word `Storm` in italic.\n\nIf you wish to change the text font weight see addFontWeight instead.",
          "!type": "fn(style: +String, position: +Number) -> +Phaser.Text"
        },
        "angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        },
        "fontWeights": {
          "!doc": "An array of the font weights values as specified by {@link Phaser.Text#addFontWeight addFontWeight}.",
          "!type": "+Array"
        },
        "setScaleMinMax": {
          "!doc": "Sets the scaleMin and scaleMax values. These values are used to limit how far this Game Object will scale based on its parent.\n\nFor example if this Game Object has a `minScale` value of 1 and its parent has a `scale` value of 0.5, the 0.5 will be ignored \nand the scale value of 1 will be used, as the parents scale is lower than the minimum scale this Game Object should adhere to.\n\nBy setting these values you can carefully control how Game Objects deal with responsive scaling.\n\nIf only one parameter is given then that value will be used for both scaleMin and scaleMax:\n`setScaleMinMax(1)` = scaleMin.x, scaleMin.y, scaleMax.x and scaleMax.y all = 1\n\nIf only two parameters are given the first is set as scaleMin.x and y and the second as scaleMax.x and y:\n`setScaleMinMax(0.5, 2)` = scaleMin.x and y = 0.5 and scaleMax.x and y = 2\n\nIf you wish to set `scaleMin` with different values for x and y then either modify Game Object.scaleMin directly, \nor pass `null` for the `maxX` and `maxY` parameters.\n\nCall `setScaleMinMax(null)` to clear all previously set values.",
          "!type": "fn(minX: +Number, minY: +Number, maxX: +Number, maxY: +Number)"
        },
        "textBounds": {
          "!doc": "The textBounds property allows you to specify a rectangular region upon which text alignment is based.\nSee `Text.setTextBounds` for more details.",
          "!type": "+Phaser.Rectangle"
        },
        "checkWorldBounds": {
          "!doc": "If this is set to `true` the Game Object checks if it is within the World bounds each frame. \n\nWhen it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.\n\nIf it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.\n\nIt also optionally kills the Game Object if `outOfBoundsKill` is `true`.\n\nWhen `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "key": {
          "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
          "!type": "+String"
        },
        "shadowStroke": {
          "!doc": "Sets if the drop shadow is applied to the Text stroke.",
          "!type": "+Boolean"
        },
        "precalculateWordWrap": {
          "!doc": "Runs the given text through the Text.runWordWrap function and returns\nthe results as an array, where each element of the array corresponds to a wrapped\nline of text.\n\nUseful if you wish to control pagination on long pieces of content.",
          "!type": "fn(text: +String) -> +Array"
        },
        "texture": {
          "!doc": "The texture that the sprite is using",
          "!type": "+Texture"
        },
        "health": {
          "!doc": "The Game Objects health value. This is a handy property for setting and manipulating health on a Game Object.\n\nIt can be used in combination with the `damage` method or modified directly.",
          "!type": "+Number"
        },
        "outOfCameraBoundsKill": {
          "!doc": "If this and the `autoCull` property are both set to `true`, then the `kill` method\nis called as soon as the Game Object leaves the camera bounds.",
          "!type": "+Boolean"
        },
        "destroyPhase": {
          "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
          "!type": "+Boolean"
        },
        "boundsAlignH": {
          "!doc": "Horizontal alignment of the text within the `textBounds`. Can be: 'left', 'center' or 'right'.",
          "!type": "+String"
        },
        "right": {
          "!doc": "The right coordinate of the Game Object.\nThis is the same as `x + width - offsetX`.",
          "!type": "+Number"
        },
        "kill": {
          "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousPosition": {
          "!doc": "The position the Game Object was located in the previous frame.",
          "!type": "+Phaser.Point"
        },
        "scaleMax": {
          "!doc": "The maximum scale this Game Object will scale up to. \n\nIt allows you to prevent a parent from scaling this Game Object higher than the given value.\n\nSet it to `null` to remove the limit.",
          "!type": "+Phaser.Point"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "anchor": {
          "!doc": "The anchor sets the origin point of the texture.\nThe default is 0,0 this means the texture's origin is the top left\nSetting than anchor to 0.5,0.5 means the textures origin is centered\nSetting the anchor to 1,1 would mean the textures origin points will be the bottom right corner",
          "!type": "+Phaser.Point"
        },
        "strokeThickness": {
          "!doc": "A number that represents the thickness of the stroke. Default is 0 (no stroke)",
          "!type": "+Number"
        },
        "width": {
          "!doc": "The width of the Text. Setting this will modify the scale to achieve the value requested.",
          "!type": "+Number"
        },
        "autoCull": {
          "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The position of the Game Object on the x axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "Controls if this Game Object is processed by the core game loop.\nIf this Game Object has a physics body it also controls if its physics body is updated or not.\nWhen `exists` is set to `false` it will remove its physics body from the physics world if it has one.\nIt also toggles the `visible` property to false as well.\n\nSetting `exists` to true will add its physics body back in to the physics world, if it has one.\nIt will also set the `visible` property to `true`.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The position of the Game Object on the y axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
          "!type": "+Number"
        },
        "font": {
          "!doc": "Change the font family that the text will be rendered in, such as 'Arial'.\n\nMultiple CSS font families and generic fallbacks can be specified as long as\n{@link http://www.w3.org/TR/CSS2/fonts.html#propdef-font-family CSS font-family rules} are followed.\n\nTo change the entire font string use {@link Phaser.Text#cssFont cssFont} instead: eg. `text.cssFont = 'bold 20pt Arial'`.",
          "!type": "+String"
        },
        "scaleMin": {
          "!doc": "The minimum scale this Game Object will scale down to.\n\nIt allows you to prevent a parent from scaling this Game Object lower than the given value.\n\nSet it to `null` to remove the limit.",
          "!type": "+Phaser.Point"
        },
        "shadowBlur": {
          "!doc": "The shadowBlur value. Make the shadow softer by applying a Gaussian blur to it. A number from 0 (no blur) up to approx. 10 (depending on scene).",
          "!type": "+Number"
        },
        "addColor": {
          "!doc": "Set specific colors for certain characters within the Text.\n\nIt works by taking a color value, which is a typical HTML string such as `#ff0000` or `rgb(255,0,0)` and a position.\nThe position value is the index of the character in the Text string to start applying this color to.\nOnce set the color remains in use until either another color or the end of the string is encountered.\nFor example if the Text was `Photon Storm` and you did `Text.addColor('#ffff00', 6)` it would color in the word `Storm` in yellow.\n\nIf you wish to change the stroke color see addStrokeColor instead.",
          "!type": "fn(color: +String, position: +Number) -> +Phaser.Text"
        },
        "fontVariant": {
          "!doc": "The variant the font: 'normal', 'small-caps'",
          "!type": "+String"
        },
        "align": {
          "!doc": "Controls the horizontal alignment for multiline text.\nCan be: 'left', 'center' or 'right'.\nDoes not affect single lines of text. For that please see `setTextBounds`.",
          "!type": "+String"
        },
        "body": {
          "!doc": "`body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated \nproperties and methods via it.\n\nBy default Game Objects won't add themselves to any physics system and their `body` property will be `null`.\n\nTo enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object\nand `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.\n\nYou can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.\n\nImportant: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5, \nso the physics body is centered on the Game Object.\n\nIf you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.",
          "!type": "+Phaser.Physics.Arcade.Body"
        },
        "lineSpacing": {
          "!doc": "Additional spacing (in pixels) between each line of text if multi-line.",
          "!type": "+Number"
        },
        "inCamera": {
          "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
          "!type": "+Boolean"
        },
        "offsetX": {
          "!doc": "The amount the Game Object is visually offset from its x coordinate.\nThis is the same as `width * anchor.x`.\nIt will only be > 0 if anchor.x is not equal to zero.",
          "!type": "+Number"
        },
        "tintedTexture": {
          "!doc": "A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)",
          "!type": "+Phaser.Canvas"
        },
        "offsetY": {
          "!doc": "The amount the Game Object is visually offset from its y coordinate.\nThis is the same as `height * anchor.y`.\nIt will only be > 0 if anchor.y is not equal to zero.",
          "!type": "+Number"
        },
        "boundsAlignV": {
          "!doc": "Vertical alignment of the text within the `textBounds`. Can be: 'top', 'middle' or 'bottom'.",
          "!type": "+String"
        },
        "fixedToCamera": {
          "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
          "!type": "+Boolean"
        },
        "renderOrderID": {
          "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
          "!type": "+Number"
        },
        "fontWeight": {
          "!doc": "The weight of the font: 'normal', 'bold', or {@link http://www.w3.org/TR/CSS2/fonts.html#propdef-font-weight a valid CSS font weight}.",
          "!type": "+String"
        },
        "previousRotation": {
          "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
          "!type": "+Number"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.\nThis is the same as `y + height - offsetY`.",
          "!type": "+Number"
        },
        "cameraOffset": {
          "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
          "!type": "+Phaser.Point"
        },
        "moveDown": {
          "!doc": "Moves this Game Object down one place in its parents display list.\nThis call has no effect if the Game Object is already at the bottom of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "fill": {
          "!doc": "A canvas fillstyle that will be used on the text eg 'red', '#00FF00'.",
          "!type": "+Object"
        },
        "updateCrop": {
          "!doc": "If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,\nor the rectangle it references, then you need to update the crop frame by calling this method.",
          "!type": "fn()"
        },
        "strokeColors": {
          "!doc": "An array of the stroke color values as specified by {@link Phaser.Text#addStrokeColor addStrokeColor}.",
          "!type": "+Array"
        },
        "overlap": {
          "!doc": "Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object, \nwhich can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.\n\nThis check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.\n\nTherefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.\nIt should be fine for low-volume testing where physics isn't required.",
          "!type": "fn(displayObject: +Phaser.Sprite) -> +Boolean"
        },
        "loadTexture": {
          "!doc": "Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.\n\nIf your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.\n\nYou should only use `loadTexture` if you want to replace the base texture entirely.\n\nCalling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.\n\nYou can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite. \nDoing this then sets the key to be the `frame` argument (the frame is set to zero). \n\nThis allows you to create sprites using `load.image` during development, and then change them \nto use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS' \nand swapping it to be the key of the atlas data.\n\nNote: You cannot use a RenderTexture as a texture for a TileSprite.",
          "!type": "fn(key: +String, frame: +String, stopAnimation: +Boolean)"
        },
        "name": {
          "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
          "!type": "+String"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "crop": {
          "!doc": "Crop allows you to crop the texture being used to display this Game Object.\nSetting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.\n\nCropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,\nor by modifying `cropRect` property directly and then calling `updateCrop`.\n\nThe rectangle object given to this method can be either a `Phaser.Rectangle` or any other object \nso long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.\n\nA reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`, \nin which case the values are duplicated to a local object.",
          "!type": "fn(rect: +Phaser.Rectangle, copy: +Boolean)"
        },
        "frame": {
          "!doc": "Gets or sets the current frame index of the texture being used to render this Game Object.\n\nTo change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,\nfor example: `player.frame = 4`.\n\nIf the frame index given doesn't exist it will revert to the first frame found in the texture.\n\nIf you are using a texture atlas then you should use the `frameName` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+Number"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "shader": {
          "!doc": "The shader that will be used to render the texture to the stage. Set to null to remove a current shader.",
          "!type": "+PIXI.AbstractFilter"
        },
        "cropRect": {
          "!doc": "The Rectangle used to crop the texture this Game Object uses.\nSet this property via `crop`. \nIf you modify this property directly you must call `updateCrop` in order to have the change take effect.",
          "!type": "+Phaser.Rectangle"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "deltaZ": {
          "!doc": "The delta value.",
          "!type": "+Number"
        },
        "transformCallbackContext": {
          "!doc": "The context under which `transformCallback` is called.",
          "!type": "+Object"
        },
        "wordWrap": {
          "!doc": "Indicates if word wrap should be used.",
          "!type": "+Boolean"
        },
        "deltaX": {
          "!doc": "Returns the delta x value. The difference between world.x now and in the previous frame.\n\nThe value will be positive if the Game Object has moved to the right or negative if to the left.",
          "!type": "+Number"
        },
        "deltaY": {
          "!doc": "Returns the delta y value. The difference between world.y now and in the previous frame.\n\nThe value will be positive if the Game Object has moved down or negative if up.",
          "!type": "+Number"
        },
        "update": {
          "!doc": "Override this function to handle any special update requirements.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "tint": {
          "!doc": "The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.",
          "!type": "+Number"
        },
        "inputEnabled": {
          "!doc": "By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created\nfor this Game Object and it will then start to process click / touch events and more.\n\nYou can then access the Input Handler via `this.input`.\n\nNote that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.\n\nIf you set this property to false it will stop the Input Handler from processing any more input events.",
          "!type": "+Boolean"
        },
        "setFrame": {
          "!doc": "Sets the texture frame the Game Object uses for rendering.\n\nThis is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.",
          "!type": "fn(frame: +Phaser.Frame)"
        },
        "animations": {
          "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
          "!type": "+Phaser.AnimationManager"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "heal": {
          "!doc": "Heal the Game Object. This adds the given amount of health to the `health` property.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "setStyle": {
          "!doc": "Set the style of the text by passing a single style object to it.",
          "!type": "fn(style: +Object, style_font: +String, style_fontStyle: +String, style_fontVariant: +String, style_fontWeight: +String, style_fontSize: +String, style_backgroundColor: +String, style_fill: +String, style_align: +String, style_boundsAlignH: +String, style_boundsAlignV: +String, style_stroke: +String, style_strokeThickness: +Number, style_wordWrap: +Boolean, style_wordWrapWidth: +Number, style_maxLines: +Number, style_tabs: +Number) -> +Phaser.Text"
        },
        "setHealth": {
          "!doc": "Sets the health property of the Game Object to the given amount.\nWill never exceed the `maxHealth` value.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "padding": {
          "!doc": "Specify a padding value which is added to the line width and height when calculating the Text size.\nALlows you to add extra spacing if Phaser is unable to accurately determine the true font dimensions.",
          "!type": "+Phaser.Point"
        },
        "debug": {
          "!doc": "A debug flag designed for use with `Game.enableStep`.",
          "!type": "+Boolean"
        },
        "frameName": {
          "!doc": "Gets or sets the current frame name of the texture being used to render this Game Object.\n\nTo change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use, \nfor example: `player.frameName = \"idle\"`.\n\nIf the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.\n\nIf you are using a sprite sheet then you should use the `frame` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+String"
        },
        "wordWrapWidth": {
          "!doc": "The width at which text will wrap.",
          "!type": "+Number"
        },
        "shadowFill": {
          "!doc": "Sets if the drop shadow is applied to the Text fill.",
          "!type": "+Boolean"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends this Game Object to the bottom of its parents display list.\nVisually this means it will render below all other children in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "resetFrame": {
          "!doc": "Resets the texture frame dimensions that the Game Object uses for rendering.",
          "!type": "fn()"
        },
        "stroke": {
          "!doc": "A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'.",
          "!type": "+String"
        },
        "pendingDestroy": {
          "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
          "!type": "+Boolean"
        },
        "clearColors": {
          "!doc": "Clears any text fill or stroke colors that were set by `addColor` or `addStrokeColor`.",
          "!type": "fn() -> +Phaser.Text"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.\n\nWarning: You cannot have a blend mode and a filter active on the same Sprite. Doing so will render the sprite invisible.",
          "!type": "+Number"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "fresh": {
          "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
          "!type": "+Boolean"
        },
        "setText": {
          "!doc": "The text to be displayed by this Text object.\nUse a \\n to insert a carriage return and split the text.\nThe text will be rendered with any style currently set.",
          "!type": "fn(text: +String) -> +Phaser.Text"
        }
      }
    },
    "Physics": {
      "P2": {
        "RevoluteConstraint": {
          "!doc": "Connects two bodies at given offset points, letting them rotate relative to each other around this point.\nThe pivot points are given in world (pixel) coordinates.",
          "!type": "fn(world: +Phaser.Physics.P2, bodyA: +p2.Body, pivotA: +Float32Array, bodyB: +p2.Body, pivotB: +Float32Array, maxForce: +Number, worldPivot: +Float32Array)",
          "prototype": {
            "game": {
              "!doc": "Local reference to game.",
              "!type": "+Phaser.Game"
            },
            "world": {
              "!doc": "Local reference to P2 World.",
              "!type": "+Phaser.Physics.P2"
            }
          }
        },
        "LockConstraint": {
          "!doc": "Locks the relative position between two bodies.",
          "!type": "fn(world: +Phaser.Physics.P2, bodyA: +p2.Body, bodyB: +p2.Body, offset: +Array, angle: +Number, maxForce: +Number)",
          "prototype": {
            "game": {
              "!doc": "Local reference to game.",
              "!type": "+Phaser.Game"
            },
            "world": {
              "!doc": "Local reference to P2 World.",
              "!type": "+Phaser.Physics.P2"
            }
          }
        },
        "CollisionGroup": {
          "!doc": "Collision Group",
          "!type": "fn(bitmask: +Number)",
          "prototype": {"mask": {
            "!doc": "The CollisionGroup bitmask.",
            "!type": "+Number"
          }}
        },
        "ContactMaterial": {
          "!doc": "Defines a physics material",
          "!type": "fn(materialA: +Phaser.Physics.P2.Material, materialB: +Phaser.Physics.P2.Material, options: +Object)",
          "prototype": {}
        },
        "!doc": "This is your main access to the P2 Physics World.\nFrom here you can create materials, listen for events and add bodies into the physics simulation.",
        "PrismaticConstraint": {
          "!doc": "Connects two bodies at given offset points, letting them rotate relative to each other around this point.",
          "!type": "fn(world: +Phaser.Physics.P2, bodyA: +p2.Body, bodyB: +p2.Body, lockRotation: +Boolean, anchorA: +Array, anchorB: +Array, axis: +Array, maxForce: +Number)",
          "prototype": {
            "game": {
              "!doc": "Local reference to game.",
              "!type": "+Phaser.Game"
            },
            "world": {
              "!doc": "Local reference to P2 World.",
              "!type": "+Phaser.Physics.P2"
            }
          }
        },
        "DistanceConstraint": {
          "!doc": "A constraint that tries to keep the distance between two bodies constant.",
          "!type": "fn(world: +Phaser.Physics.P2, bodyA: +p2.Body, bodyB: +p2.Body, distance: +Number, localAnchorA: +Array, localAnchorB: +Array, maxForce: +Object)",
          "prototype": {
            "game": {
              "!doc": "Local reference to game.",
              "!type": "+Phaser.Game"
            },
            "world": {
              "!doc": "Local reference to P2 World.",
              "!type": "+Phaser.Physics.P2"
            }
          }
        },
        "PointProxy": {
          "!doc": "A PointProxy is an internal class that allows for direct getter/setter style property access to Arrays and TypedArrays.",
          "!type": "fn(world: +Phaser.Physics.P2, destination: +Object)",
          "prototype": {
            "x": {
              "!doc": "The x property of this PointProxy get and set in pixels.",
              "!type": "+Number"
            },
            "y": {
              "!doc": "The y property of this PointProxy get and set in pixels.",
              "!type": "+Number"
            },
            "mx": {
              "!doc": "The x property of this PointProxy get and set in meters.",
              "!type": "+Number"
            },
            "my": {
              "!doc": "The x property of this PointProxy get and set in meters.",
              "!type": "+Number"
            }
          }
        },
        "Material": {
          "!doc": "A P2 Material.\n\n\\o/ ~ \"Because I'm a Material girl\"",
          "!type": "fn(name: +String)",
          "prototype": {"name": {
            "!doc": "The user defined name given to this Material.",
            "!type": "+String"
          }}
        },
        "Spring": {
          "!doc": "Creates a linear spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.",
          "!type": "fn(world: +Phaser.Physics.P2, bodyA: +p2.Body, bodyB: +p2.Body, restLength: +Number, stiffness: +Number, damping: +Number, worldA: +Array, worldB: +Array, localA: +Array, localB: +Array)",
          "prototype": {
            "game": {
              "!doc": "Local reference to game.",
              "!type": "+Phaser.Game"
            },
            "world": {
              "!doc": "Local reference to P2 World.",
              "!type": "+Phaser.Physics.P2"
            },
            "data": {
              "!doc": "The actual p2 spring object.",
              "!type": "+p2.LinearSpring"
            }
          }
        },
        "prototype": {
          "getSprings": {
            "!doc": "Populates and returns an array of all current Springs in the world.",
            "!type": "fn() -> +array._Phaser.Physics.P2.Spring_"
          },
          "paused": {
            "!doc": "The paused state of the P2 World.",
            "!type": "+Boolean"
          },
          "onConstraintAdded": {
            "!doc": "This signal is dispatched when a Constraint is added to the World.\n\nIt sends 1 argument: `constraint` which is the `Phaser.Physics.P2.Constraint` that was added to the world.",
            "!type": "+Phaser.Signal"
          },
          "addConstraint": {
            "!doc": "Adds a Constraint to the world.",
            "!type": "fn(constraint: +Phaser.Physics.P2.Constraint) -> +Phaser.Physics.P2.Constraint"
          },
          "onConstraintRemoved": {
            "!doc": "This signal is dispatched when a Constraint is removed from the World.\n\nIt sends 1 argument: `constraint` which is the `Phaser.Physics.P2.Constraint` that was removed from the world.",
            "!type": "+Phaser.Signal"
          },
          "pxmi": {
            "!doc": "Convert pixel value to p2 physics scale (meters) and inverses it.\nBy default Phaser uses a scale of 20px per meter.\nIf you need to modify this you can over-ride these functions via the Physics Configuration object.",
            "!type": "fn(v: +Number) -> +Number"
          },
          "getConstraints": {
            "!doc": "Populates and returns an array of all current Constraints in the world.\nYou will get an array of p2 constraints back. This can be of mixed types, for example the array may contain\nPrismaticConstraints, RevoluteConstraints or any other valid p2 constraint type.",
            "!type": "fn() -> +array._Phaser.Physics.P2.Constraint_"
          },
          "frameRate": {
            "!doc": "The frame rate the world will be stepped at. Defaults to 1 / 60, but you can change here. Also see useElapsedTime property.",
            "!type": "+Number"
          },
          "convertTilemap": {
            "!doc": "Goes through all tiles in the given Tilemap and TilemapLayer and converts those set to collide into physics bodies.\nOnly call this *after* you have specified all of the tiles you wish to collide with calls like Tilemap.setCollisionBetween, etc.\nEvery time you call this method it will destroy any previously created bodies and remove them from the world.\nTherefore understand it's a very expensive operation and not to be done in a core game update loop.",
            "!type": "fn(map: +Phaser.Tilemap, layer: +Number, addToWorld: +Boolean, optimize: +Boolean) -> +Array"
          },
          "createMaterial": {
            "!doc": "Creates a Material. Materials are applied to Shapes owned by a Body and can be set with Body.setMaterial().\nMaterials are a way to control what happens when Shapes collide. Combine unique Materials together to create Contact Materials.\nContact Materials have properties such as friction and restitution that allow for fine-grained collision control between different Materials.",
            "!type": "fn(name: +String, body: +Phaser.Physics.P2.Body) -> +Phaser.Physics.P2.Material"
          },
          "onSpringRemoved": {
            "!doc": "This signal is dispatched when a Spring is removed from the World.\n\nIt sends 1 argument: `spring` which is either a `Phaser.Physics.P2.Spring`, `p2.LinearSpring` or `p2.RotationalSpring` that was removed from the world.",
            "!type": "+Phaser.Signal"
          },
          "enableBody": {
            "!doc": "Creates a P2 Physics body on the given game object.\nA game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.",
            "!type": "fn(object: +Object, debug: +Boolean)"
          },
          "createContactMaterial": {
            "!doc": "Creates a Contact Material from the two given Materials. You can then edit the properties of the Contact Material directly.",
            "!type": "fn(materialA: +Phaser.Physics.P2.Material, materialB: +Phaser.Physics.P2.Material, options: +Object) -> +Phaser.Physics.P2.ContactMaterial"
          },
          "enable": {
            "!doc": "This will create a P2 Physics body on the given game object or array of game objects.\nA game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\nNote: When the game object is enabled for P2 physics it has its anchor x/y set to 0.5 so it becomes centered.",
            "!type": "fn(object: +Object, debug: +Boolean, children: +Boolean)"
          },
          "onBodyRemoved": {
            "!doc": "This signal is dispatched when a Body is removed to the World.\n\nIt sends 1 argument: `body` which is the `Phaser.Physics.P2.Body` that was removed from the world.",
            "!type": "+Phaser.Signal"
          },
          "everythingCollisionGroup": {
            "!doc": "A default collision group.",
            "!type": "+Phaser.Physics.P2.CollisionGroup"
          },
          "applyDamping": {
            "!doc": "Enable to automatically apply body damping each step.",
            "!type": "+Boolean"
          },
          "removeBodyNextStep": {
            "!doc": "This will add a P2 Physics body into the removal list for the next step.",
            "!type": "fn(body: +Phaser.Physics.P2.Body)"
          },
          "onSpringAdded": {
            "!doc": "This signal is dispatched when a Spring is added to the World.\n\nIt sends 1 argument: `spring` which is either a `Phaser.Physics.P2.Spring`, `p2.LinearSpring` or `p2.RotationalSpring` that was added to the world.",
            "!type": "+Phaser.Signal"
          },
          "sleepMode": {
            "!doc": "How to deactivate bodies during simulation. Possible modes are: World.NO_SLEEPING, World.BODY_SLEEPING and World.ISLAND_SLEEPING.\nIf sleeping is enabled, you might need to wake up the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see Body.allowSleep.",
            "!type": "+Number"
          },
          "applySpringForces": {
            "!doc": "Enable to automatically apply spring forces each step.",
            "!type": "+Boolean"
          },
          "boundsCollidesWith": {
            "!doc": "An array of the bodies the world bounds collides with.",
            "!type": "+Array"
          },
          "updateBoundsCollisionGroup": {
            "!doc": "By default the World will be set to collide everything with everything. The bounds of the world is a Body with 4 shapes, one for each face.\nIf you start to use your own collision groups then your objects will no longer collide with the bounds.\nTo fix this you need to adjust the bounds to use its own collision group first BEFORE changing your Sprites collision group.",
            "!type": "fn(setCollisionGroup: +Boolean)"
          },
          "destroy": {
            "!doc": "Clears all bodies from the simulation and unlinks World from Game. Should only be called on game shutdown. Call `clear` on a State change.",
            "!type": "fn()"
          },
          "createBody": {
            "!doc": "Creates a new Body and adds it to the World.",
            "!type": "fn(x: +Number, y: +Number, mass: +Number, addToWorld: +Boolean, options: +Object, options_optimalDecomp: +Boolean, options_skipSimpleCheck: +Boolean, options_removeCollinearPoints: +Boolean, points: +Array._number_) -> +Phaser.Physics.P2.Body"
          },
          "callbackContext": {
            "!doc": "The context under which the callbacks are fired.",
            "!type": "+Object"
          },
          "getBodies": {
            "!doc": "Populates and returns an array with references to of all current Bodies in the world.",
            "!type": "fn() -> +array._Phaser.Physics.P2.Body_"
          },
          "solveConstraints": {
            "!doc": "Enable/disable constraint solving in each step.",
            "!type": "+Boolean"
          },
          "useElapsedTime": {
            "!doc": "If true the frameRate value will be ignored and instead p2 will step with the value of Game.Time.physicsElapsed, which is a delta time value.",
            "!type": "+Boolean"
          },
          "setPostBroadphaseCallback": {
            "!doc": "Sets a callback to be fired after the Broadphase has collected collision pairs in the world.\nJust because a pair exists it doesn't mean they *will* collide, just that they potentially could do.\nIf your calback returns `false` the pair will be removed from the narrowphase. This will stop them testing for collision this step.\nReturning `true` from the callback will ensure they are checked in the narrowphase.",
            "!type": "fn(callback: +Function, context: +Object)"
          },
          "pause": {
            "!doc": "Pauses the P2 World independent of the game pause state.",
            "!type": "fn()"
          },
          "boundsCollisionGroup": {
            "!doc": "A default collision group.",
            "!type": "+Phaser.Physics.P2.CollisionGroup"
          },
          "removeBody": {
            "!doc": "Removes a body from the world. This will silently fail if the body wasn't part of the world to begin with.",
            "!type": "fn(body: +Phaser.Physics.P2.Body) -> +Phaser.Physics.P2.Body"
          },
          "mpx": {
            "!doc": "Convert p2 physics value (meters) to pixel scale.\nBy default Phaser uses a scale of 20px per meter.\nIf you need to modify this you can over-ride these functions via the Physics Configuration object.",
            "!type": "fn(v: +Number) -> +Number"
          },
          "materials": {
            "!doc": "A local array of all created Materials.",
            "!type": "+array._Phaser.Physics.P2.Material_"
          },
          "createGearConstraint": {
            "!doc": "Creates a constraint that tries to keep the distance between two bodies constant.",
            "!type": "fn(bodyA: +Phaser.Sprite, bodyB: +Phaser.Sprite, angle: +Number, ratio: +Number) -> +Phaser.Physics.P2.GearConstraint"
          },
          "reset": {
            "!doc": "Called by Phaser.Physics when a State swap occurs.\nStarts the begin and end Contact listeners again.",
            "!type": "fn()"
          },
          "addContactMaterial": {
            "!doc": "Adds a Contact Material to the world.",
            "!type": "fn(material: +Phaser.Physics.P2.ContactMaterial) -> +Phaser.Physics.P2.ContactMaterial"
          },
          "createCollisionGroup": {
            "!doc": "Creates a new Collision Group and optionally applies it to the given object.\nCollision Groups are handled using bitmasks, therefore you have a fixed limit you can create before you need to re-use older groups.",
            "!type": "fn(object: +Phaser.Group)"
          },
          "nothingCollisionGroup": {
            "!doc": "A default collision group.",
            "!type": "+Phaser.Physics.P2.CollisionGroup"
          },
          "preUpdate": {
            "!doc": "Called at the start of the core update loop. Purges flagged bodies from the world.",
            "!type": "fn()"
          },
          "applyGravity": {
            "!doc": "Enable to automatically apply gravity each step.",
            "!type": "+Boolean"
          },
          "clearTilemapLayerBodies": {
            "!doc": "Clears all physics bodies from the given TilemapLayer that were created with `World.convertTilemap`.",
            "!type": "fn(map: +Phaser.Tilemap, layer: +Number)"
          },
          "getContactMaterial": {
            "!doc": "Gets a Contact Material based on the two given Materials.",
            "!type": "fn(materialA: +Phaser.Physics.P2.Material, materialB: +Phaser.Physics.P2.Material) -> +Phaser.Physics.P2.ContactMaterial"
          },
          "game": {
            "!doc": "Local reference to game.",
            "!type": "+Phaser.Game"
          },
          "createRevoluteConstraint": {
            "!doc": "Connects two bodies at given offset points, letting them rotate relative to each other around this point.\nThe pivot points are given in world (pixel) coordinates.",
            "!type": "fn(bodyA: +Phaser.Sprite, pivotA: +Array, bodyB: +Phaser.Sprite, pivotB: +Array, maxForce: +Number, worldPivot: +Float32Array) -> +Phaser.Physics.P2.RevoluteConstraint"
          },
          "update": {
            "!doc": "Internal P2 update loop.",
            "!type": "fn()"
          },
          "setMaterial": {
            "!doc": "Sets the given Material against all Shapes owned by all the Bodies in the given array.",
            "!type": "fn(material: +Phaser.Physics.P2.Material, bodies: +array._Phaser.Physics.P2.Body_)"
          },
          "toJSON": {
            "!doc": "Converts the current world into a JSON object.",
            "!type": "fn() -> +Object"
          },
          "total": {
            "!doc": "The total number of bodies in the world.",
            "!type": "+Number"
          },
          "world": {
            "!doc": "The p2 World in which the simulation is run.",
            "!type": "+p2.World"
          },
          "walls": {
            "!doc": "An object containing the 4 wall bodies that bound the physics world.",
            "!type": "+Object"
          },
          "endContactHandler": {
            "!doc": "Handles a p2 end contact event.",
            "!type": "fn(event: +Object)"
          },
          "removeSpring": {
            "!doc": "Removes a Spring from the world.",
            "!type": "fn(spring: +Phaser.Physics.P2.Spring) -> +Phaser.Physics.P2.Spring"
          },
          "emitImpactEvent": {
            "!doc": "Set to true if you want to the world to emit the \"impact\" event. Turning this off could improve performance.",
            "!type": "+Boolean"
          },
          "addSpring": {
            "!doc": "Adds a Spring to the world.",
            "!type": "fn(spring: +Phaser.Physics.P2.Spring) -> +Phaser.Physics.P2.Spring"
          },
          "removeConstraint": {
            "!doc": "Removes a Constraint from the world.",
            "!type": "fn(constraint: +Phaser.Physics.P2.Constraint) -> +Phaser.Physics.P2.Constraint"
          },
          "setImpactEvents": {
            "!doc": "Impact event handling is disabled by default. Enable it before any impact events will be dispatched.\nIn a busy world hundreds of impact events can be generated every step, so only enable this if you cannot do what you need via beginContact or collision masks.",
            "!type": "fn(state: +Boolean)"
          },
          "createDistanceConstraint": {
            "!doc": "Creates a constraint that tries to keep the distance between two bodies constant.",
            "!type": "fn(bodyA: +Phaser.Sprite, bodyB: +Phaser.Sprite, distance: +Number, localAnchorA: +Array, localAnchorB: +Array, maxForce: +Number) -> +Phaser.Physics.P2.DistanceConstraint"
          },
          "resume": {
            "!doc": "Resumes a paused P2 World.",
            "!type": "fn()"
          },
          "addBody": {
            "!doc": "Add a body to the world.",
            "!type": "fn(body: +Phaser.Physics.P2.Body) -> +Boolean"
          },
          "pxm": {
            "!doc": "Convert pixel value to p2 physics scale (meters).\nBy default Phaser uses a scale of 20px per meter.\nIf you need to modify this you can over-ride these functions via the Physics Configuration object.",
            "!type": "fn(v: +Number) -> +Number"
          },
          "getBody": {
            "!doc": "Checks the given object to see if it has a p2.Body and if so returns it.",
            "!type": "fn(object: +Object) -> +p2.Body"
          },
          "postBroadphaseCallback": {
            "!doc": "A postBroadphase callback.",
            "!type": "+Function"
          },
          "createPrismaticConstraint": {
            "!doc": "Constraint that only allows bodies to move along a line, relative to each other.\nSee http://www.iforce2d.net/b2dtut/joints-prismatic",
            "!type": "fn(bodyA: +Phaser.Sprite, bodyB: +Phaser.Sprite, lockRotation: +Boolean, anchorA: +Array, anchorB: +Array, axis: +Array, maxForce: +Number) -> +Phaser.Physics.P2.PrismaticConstraint"
          },
          "mpxi": {
            "!doc": "Convert p2 physics value (meters) to pixel scale and inverses it.\nBy default Phaser uses a scale of 20px per meter.\nIf you need to modify this you can over-ride these functions via the Physics Configuration object.",
            "!type": "fn(v: +Number) -> +Number"
          },
          "onEndContact": {
            "!doc": "This Signal is dispatched when final contact occurs between two bodies. This happens *before* the step has been done.\n\nIt sends 4 arguments: `bodyA`, `bodyB`, `shapeA` and `shapeB`.\n\nIt is possible that in certain situations the `bodyA` or `bodyB` values are `null`. You should check for this\nin your own code to avoid processing potentially null physics bodies.",
            "!type": "+Phaser.Signal"
          },
          "clear": {
            "!doc": "Clears all bodies from the simulation, resets callbacks and resets the collision bitmask.\n\nThe P2 world is also cleared:\n\n* Removes all solver equations\n* Removes all constraints\n* Removes all bodies\n* Removes all springs\n* Removes all contact materials\n\nThis is called automatically when you switch state.",
            "!type": "fn()"
          },
          "contactMaterial": {
            "!doc": "The default Contact Material being used by the World.",
            "!type": "+p2.ContactMaterial"
          },
          "collisionGroups": {
            "!doc": "An array containing the collision groups that have been defined in the World.",
            "!type": "+Array"
          },
          "convertCollisionObjects": {
            "!doc": "Converts all of the polylines objects inside a Tiled ObjectGroup into physics bodies that are added to the world.\nNote that the polylines must be created in such a way that they can withstand polygon decomposition.",
            "!type": "fn(map: +Phaser.Tilemap, layer: +Number, addToWorld: +Boolean) -> +Array"
          },
          "createRotationalSpring": {
            "!doc": "Creates a rotational spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.",
            "!type": "fn(bodyA: +Phaser.Sprite, bodyB: +Phaser.Sprite, restAngle: +Number, stiffness: +Number, damping: +Number) -> +Phaser.Physics.P2.RotationalSpring"
          },
          "setBounds": {
            "!doc": "Sets the bounds of the Physics world to match the given world pixel dimensions.\nYou can optionally set which 'walls' to create: left, right, top or bottom.\nIf none of the walls are given it will default to use the walls settings it had previously.\nI.e. if you previously told it to not have the left or right walls, and you then adjust the world size\nthe newly created bounds will also not have the left and right walls.\nExplicitly state them in the parameters to override this.",
            "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, left: +Boolean, right: +Boolean, top: +Boolean, bottom: +Boolean, setCollisionGroup: +Boolean)"
          },
          "friction": {
            "!doc": "Friction between colliding bodies. This value is used if no matching ContactMaterial is found for a Material pair.",
            "!type": "+Number"
          },
          "createLockConstraint": {
            "!doc": "Locks the relative position between two bodies.",
            "!type": "fn(bodyA: +Phaser.Sprite, bodyB: +Phaser.Sprite, offset: +Array, angle: +Number, maxForce: +Number) -> +Phaser.Physics.P2.LockConstraint"
          },
          "onContactMaterialAdded": {
            "!doc": "This signal is dispatched when a Contact Material is added to the World.\n\nIt sends 1 argument: `material` which is the `Phaser.Physics.P2.ContactMaterial` that was added to the world.",
            "!type": "+Phaser.Signal"
          },
          "onContactMaterialRemoved": {
            "!doc": "This signal is dispatched when a Contact Material is removed from the World.\n\nIt sends 1 argument: `material` which is the `Phaser.Physics.P2.ContactMaterial` that was removed from the world.",
            "!type": "+Phaser.Signal"
          },
          "onBodyAdded": {
            "!doc": "This signal is dispatched when a new Body is added to the World.\n\nIt sends 1 argument: `body` which is the `Phaser.Physics.P2.Body` that was added to the world.",
            "!type": "+Phaser.Signal"
          },
          "restitution": {
            "!doc": "Default coefficient of restitution between colliding bodies. This value is used if no matching ContactMaterial is found for a Material pair.",
            "!type": "+Number"
          },
          "gravity": {
            "!doc": "The gravity applied to all bodies each step.",
            "!type": "+Phaser.Physics.P2.InversePointProxy"
          },
          "beginContactHandler": {
            "!doc": "Handles a p2 begin contact event.",
            "!type": "fn(event: +Object)"
          },
          "createSpring": {
            "!doc": "Creates a linear spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.",
            "!type": "fn(bodyA: +Phaser.Sprite, bodyB: +Phaser.Sprite, restLength: +Number, stiffness: +Number, damping: +Number, worldA: +Array, worldB: +Array, localA: +Array, localB: +Array) -> +Phaser.Physics.P2.Spring"
          },
          "hitTest": {
            "!doc": "Test if a world point overlaps bodies. You will get an array of actual P2 bodies back. You can find out which Sprite a Body belongs to\n(if any) by checking the Body.parent.sprite property. Body.parent is a Phaser.Physics.P2.Body property.",
            "!type": "fn(worldPoint: +Phaser.Point, bodies: +Array.__Phaser.Physics.P2.Body_Phaser.Sprite_p2.Body__, precision: +Number, filterStatic: +Boolean) -> +Array"
          },
          "createParticle": {
            "!doc": "Creates a new Particle and adds it to the World.",
            "!type": "fn(x: +Number, y: +Number, mass: +Number, addToWorld: +Boolean, options: +Object, options_optimalDecomp: +Boolean, options_skipSimpleCheck: +Boolean, options_removeCollinearPoints: +Boolean, points: +Array._number_)"
          },
          "onBeginContact": {
            "!doc": "This Signal is dispatched when a first contact is created between two bodies. This happens *before* the step has been done.\n\nIt sends 5 arguments: `bodyA`, `bodyB`, `shapeA`, `shapeB` and `contactEquations`.\n\nIt is possible that in certain situations the `bodyA` or `bodyB` values are `null`. You should check for this\nin your own code to avoid processing potentially null physics bodies.",
            "!type": "+Phaser.Signal"
          },
          "time": {
            "!doc": "The World time.",
            "!type": "+Boolean"
          },
          "config": {
            "!doc": "The p2 World configuration object.",
            "!type": "+Object"
          },
          "removeContactMaterial": {
            "!doc": "Removes a Contact Material from the world.",
            "!type": "fn(material: +Phaser.Physics.P2.ContactMaterial) -> +Phaser.Physics.P2.ContactMaterial"
          }
        },
        "BodyDebug": {
          "SORT_ASCENDING": "+Number",
          "RETURN_TOTAL": "+Number",
          "!doc": "Draws a P2 Body to a Graphics instance for visual debugging.\nNeedless to say, for every body you enable debug drawing on, you are adding processor and graphical overhead.\nSo use sparingly and rarely (if ever) in production code.\n\nAlso be aware that the Debug body is only updated when the Sprite it is connected to changes position. If you\nmanipulate the sprite in any other way (such as moving it to another Group or bringToTop, etc) then you will\nneed to manually adjust its BodyDebug as well.",
          "RETURN_NONE": "+Number",
          "!type": "fn(game: +Phaser.Game, body: +Phaser.Physics.P2.Body, settings: +Object)",
          "SORT_DESCENDING": "+Number",
          "RETURN_CHILD": "+Number",
          "prototype": {
            "xy": {
              "!doc": "Positions the child found at the given index within this group to the given x and y coordinates.",
              "!type": "fn(index: +Number, x: +Number, y: +Number)"
            },
            "parent": {
              "!doc": "[read-only] The display object container that contains this display object.",
              "!type": "+PIXI.DisplayObjectContainer"
            },
            "descendingSortHandler": {
              "!doc": "An internal helper function for the sort process.",
              "!type": "fn(a: +Object, b: +Object)"
            },
            "type": {
              "!doc": "Internal Phaser Type value.",
              "!type": "+Number"
            },
            "moveAll": {
              "!doc": "Moves all children from this Group to the Group given.",
              "!type": "fn(group: +Phaser.Group, silent: +Boolean) -> +Phaser.Group"
            },
            "removeAll": {
              "!doc": "Removes all children from this group, but does not remove the group from its parent.",
              "!type": "fn(destroy: +Boolean, silent: +Boolean)"
            },
            "enableBody": {
              "!doc": "If true all Sprites created by, or added to this group, will have a physics body enabled on them.\n\nThe default body type is controlled with {@link #physicsBodyType}.",
              "!type": "+Boolean"
            },
            "children": {
              "!doc": "[read-only] The array of children of this container.",
              "!type": "+Array_DisplayObject_"
            },
            "customSort": {
              "!doc": "Sort the children in the group according to custom sort function.\n\nThe `sortHandler` is provided the two parameters: the two children involved in the comparison (a and b).\nIt should return -1 if `a > b`, 1 if `a < b` or 0 if `a === b`.",
              "!type": "fn(sortHandler: +Function, context: +Object)"
            },
            "enableBodyDebug": {
              "!doc": "If true when a physics body is created (via {@link #enableBody}) it will create a physics debug object as well.\n\nThis only works for P2 bodies.",
              "!type": "+Boolean"
            },
            "pivot": {
              "!doc": "The pivot point of the displayObject that it rotates around",
              "!type": "+Phaser.Point"
            },
            "bringToTop": {
              "!doc": "Brings the given child to the top of this group so it renders above all other children.",
              "!type": "fn(child: +Object) -> +Object"
            },
            "moveUp": {
              "!doc": "Moves the given child up one place in this group unless it's already at the top.",
              "!type": "fn(child: +Object) -> +Object"
            },
            "physicsType": {
              "!doc": "The const physics body type of this object.",
              "!type": "+Number"
            },
            "updateSpriteTransform": {
              "!doc": "Core update.",
              "!type": "fn()"
            },
            "canvas": {
              "!doc": "The canvas to render the debug info to.",
              "!type": "+Phaser.Graphics"
            },
            "postUpdate": {
              "!doc": "The core postUpdate - as called by World.",
              "!type": "fn()"
            },
            "destroy": {
              "!doc": "Destroys this group.\n\nRemoves all children, then removes this group from its parent and nulls references.",
              "!type": "fn(destroyChildren: +Boolean, soft: +Boolean)"
            },
            "cursorIndex": {
              "!doc": "The current index of the Group cursor. Advance it with Group.next.",
              "!type": "+Number"
            },
            "getFirstDead": {
              "!doc": "Get the first child that is dead (`child.alive === false`).\n\nThis is handy for checking if everything has been wiped out and adding to the pool as needed.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no dead ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
              "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
            },
            "physicsSortDirection": {
              "!doc": "If this Group contains Arcade Physics Sprites you can set a custom sort direction via this property.\n\nIt should be set to one of the Phaser.Physics.Arcade sort direction constants: \n\nPhaser.Physics.Arcade.SORT_NONE\nPhaser.Physics.Arcade.LEFT_RIGHT\nPhaser.Physics.Arcade.RIGHT_LEFT\nPhaser.Physics.Arcade.TOP_BOTTOM\nPhaser.Physics.Arcade.BOTTOM_TOP\n\nIf set to `null` the Group will use whatever Phaser.Physics.Arcade.sortDirection is set to. This is the default behavior.",
              "!type": "+Number"
            },
            "addAt": {
              "!doc": "Adds an existing object to this group.\n\nThe child is added to the group at the location specified by the index value, this allows you to control child ordering.",
              "!type": "fn(child: +DisplayObject, index: +Number, silent: +Boolean) -> +PIXI.DisplayObject"
            },
            "worldPosition": {
              "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
              "!type": "+Phaser.Point"
            },
            "forEachAlive": {
              "!doc": "Call a function on each alive child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
              "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
            },
            "resetCursor": {
              "!doc": "Sets the group cursor to the first child in the group.\n\nIf the optional index parameter is given it sets the cursor to the object at that index instead.",
              "!type": "fn(index: +Number) -> +Object"
            },
            "addMultiple": {
              "!doc": "Adds an array of existing Display Objects to this Group.\n\nThe Display Objects are automatically added to the top of this Group, and will render on-top of everything already in this Group.\n\nAs well as an array you can also pass another Group as the first argument. In this case all of the children from that\nGroup will be removed from it and added into this Group.",
              "!type": "fn(children: +Array._DisplayObject_, silent: +Boolean) -> +Array._DisplayObject_"
            },
            "setProperty": {
              "!doc": "Sets a property to the given value on the child. The operation parameter controls how the value is set.\n\nThe operations are:\n- 0: set the existing value to the given value; if force is `true` a new property will be created if needed\n- 1: will add the given value to the value already present.\n- 2: will subtract the given value from the value already present.\n- 3: will multiply the value already present by the given value.\n- 4: will divide the value already present by the given value.",
              "!type": "fn(child: +Object, key: +Array, value: +Object, operation: +Number, force: +Boolean) -> +Boolean"
            },
            "preUpdate": {
              "!doc": "The core preUpdate - as called by World.",
              "!type": "fn()"
            },
            "hash": {
              "!doc": "The hash array is an array belonging to this Group into which you can add any of its children via Group.addToHash and Group.removeFromHash.\n\nOnly children of this Group can be added to and removed from the hash.\n\nThis hash is used automatically by Phaser Arcade Physics in order to perform non z-index based destructive sorting.\nHowever if you don't use Arcade Physics, or this isn't a physics enabled Group, then you can use the hash to perform your own\nsorting and filtering of Group children without touching their z-index (and therefore display draw order)",
              "!type": "+Array"
            },
            "filterArea": {
              "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
              "!type": "+Phaser.Rectangle"
            },
            "addToHash": {
              "!doc": "Adds a child of this Group into the hash array.\nThis call will return false if the child is not a child of this Group, or is already in the hash.",
              "!type": "fn(child: +DisplayObject) -> +Boolean"
            },
            "worldScale": {
              "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
              "!type": "+Phaser.Point"
            },
            "alive": {
              "!doc": "The alive property is useful for Groups that are children of other Groups and need to be included/excluded in checks like forEachAlive.",
              "!type": "+Boolean"
            },
            "checkProperty": {
              "!doc": "Checks a property for the given value on the child.",
              "!type": "fn(child: +Object, key: +Array, value: +Object, force: +Boolean) -> +Boolean"
            },
            "callbackFromArray": {
              "!doc": "Returns a reference to a function that exists on a child of the group based on the given callback array.",
              "!type": "fn(child: +Object, callback: +Array, length: +Number)"
            },
            "worldAlpha": {
              "!doc": "[read-only] The multiplied alpha of the displayObject",
              "!type": "+Number"
            },
            "multiplyAll": {
              "!doc": "Multiplies the given property by the amount on all children in this group.\n\n`Group.multiplyAll('x', 2)` will x2 the child.x value for each child.",
              "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
            },
            "getByName": {
              "!doc": "Searches the Group for the first instance of a child with the `name`\nproperty matching the given argument. Should more than one child have\nthe same name only the first instance is returned.",
              "!type": "fn(name: +String) -> +Object"
            },
            "angle": {
              "!doc": "The angle of rotation of the group container, in degrees.\n\nThis adjusts the group itself by modifying its local rotation transform.\n\nThis has no impact on the rotation/angle properties of the children, but it will update their worldTransform\nand on-screen orientation and position.",
              "!type": "+Number"
            },
            "iterate": {
              "!doc": "Iterates over the children of the group performing one of several actions for matched children.\n\nA child is considered a match when it has a property, named `key`, whose value is equal to `value`\naccording to a strict equality comparison.\n\nThe result depends on the `returnType`:\n\n- {@link Phaser.Group.RETURN_TOTAL RETURN_TOTAL}:\n    The callback, if any, is applied to all matching children. The number of matched children is returned.\n- {@link Phaser.Group.RETURN_NONE RETURN_NONE}:\n    The callback, if any, is applied to all matching children. No value is returned.\n- {@link Phaser.Group.RETURN_CHILD RETURN_CHILD}:\n    The callback, if any, is applied to the *first* matching child and the *first* matched child is returned.\n    If there is no matching child then null is returned.\n\nIf `args` is specified it must be an array. The matched child will be assigned to the first\nelement and the entire array will be applied to the callback function.",
              "!type": "fn(key: +String, value: +Object, returnType: +Number, callback: +Function, callbackContext: +Object, args: +Array._any_) -> +Object"
            },
            "onDestroy": {
              "!doc": "This signal is dispatched when the group is destroyed.",
              "!type": "+Phaser.Signal"
            },
            "set": {
              "!doc": "Quickly set a property on a single child of this group to a new value.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
              "!type": "fn(child: +Phaser.Sprite, key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean) -> +Boolean"
            },
            "getFirstExists": {
              "!doc": "Get the first display object that exists, or doesn't exist.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if none matching your exists argument were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
              "!type": "fn(exists: +Boolean, createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
            },
            "draw": {
              "!doc": "Draws the P2 shapes to the Graphics object.",
              "!type": "fn()"
            },
            "reverse": {
              "!doc": "Reverses all children in this group.\n\nThis operation applies only to immediate children and does not propagate to subgroups.",
              "!type": "fn()"
            },
            "filter": {
              "!doc": "Find children matching a certain predicate.\n\nFor example:\n\n    var healthyList = Group.filter(function(child, index, children) {\n        return child.health > 10 ? true : false;\n    }, true);\n    healthyList.callAll('attack');\n\nNote: Currently this will skip any children which are Groups themselves.",
              "!type": "fn(predicate: +Function, checkExists: +Boolean) -> +Phaser.ArraySet"
            },
            "ppu": {
              "!doc": "Pixels per Length Unit.",
              "!type": "+Number"
            },
            "stage": {
              "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
              "!type": "+Phaser.Stage"
            },
            "addAll": {
              "!doc": "Adds the amount to the given property on all children in this group.\n\n`Group.addAll('x', 10)` will add 10 to the child.x value for each child.",
              "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
            },
            "ignoreDestroy": {
              "!doc": "A group with `ignoreDestroy` set to `true` ignores all calls to its `destroy` method.",
              "!type": "+Boolean"
            },
            "x": {
              "!doc": "The x coordinate of the group container.\n\nYou can adjust the group container itself by modifying its coordinates.\nThis will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.",
              "!type": "+Number"
            },
            "exists": {
              "!doc": "If exists is true the group is updated, otherwise it is skipped.",
              "!type": "+Boolean"
            },
            "y": {
              "!doc": "The y coordinate of the group container.\n\nYou can adjust the group container itself by modifying its coordinates.\nThis will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.",
              "!type": "+Number"
            },
            "z": {
              "!doc": "The z-depth value of this object within its parent container/Group - the World is a Group as well.\nThis value must be unique for each child in a Group.",
              "!type": "+Number"
            },
            "divideAll": {
              "!doc": "Divides the given property by the amount on all children in this group.\n\n`Group.divideAll('x', 2)` will half the child.x value for each child.",
              "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
            },
            "setAllChildren": {
              "!doc": "Quickly set the same property across all children of this group, and any child Groups, to a new value.\n\nIf this group contains other Groups then the same property is set across their children as well, iterating down until it reaches the bottom.\nUnlike with `setAll` the property is NOT set on child Groups itself.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
              "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
            },
            "physicsBodyType": {
              "!doc": "If {@link #enableBody} is true this is the type of physics body that is created on new Sprites.\n\nThe valid values are {@link Phaser.Physics.ARCADE}, {@link Phaser.Physics.P2JS}, {@link Phaser.Physics.NINJA}, etc.",
              "!type": "+Number"
            },
            "getIndex": {
              "!doc": "Get the index position of the given child in this group, which should match the child's `z` property.",
              "!type": "fn(child: +Object) -> +Number"
            },
            "getBottom": {
              "!doc": "Returns the child at the bottom of this group.\n\nThe bottom child the child being displayed (rendered) below every other child.",
              "!type": "fn() -> +Object"
            },
            "replace": {
              "!doc": "Replaces a child of this group with the given newChild. The newChild cannot be a member of this group.",
              "!type": "fn(oldChild: +Object, newChild: +Object) -> +Object"
            },
            "body": {
              "!doc": "The P2 Body to display debug data for.",
              "!type": "+Phaser.Physics.P2.Body"
            },
            "resetChild": {
              "!doc": "Takes a child and if the `x` and `y` arguments are given it calls `child.reset(x, y)` on it.\n\nIf the `key` and optionally the `frame` arguments are given, it calls `child.loadTexture(key, frame)` on it.\n\nThe two operations are separate. For example if you just wish to load a new texture then pass `null` as the x and y values.",
              "!type": "fn(child: +DisplayObject, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
            },
            "getRandom": {
              "!doc": "Returns a random child from the group.",
              "!type": "fn(startIndex: +Number, length: +Number) -> +Object"
            },
            "forEachExists": {
              "!doc": "Call a function on each existing child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
              "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
            },
            "getTop": {
              "!doc": "Return the child at the top of this group.\n\nThe top child is the child displayed (rendered) above every other child.",
              "!type": "fn() -> +Object"
            },
            "create": {
              "!doc": "Creates a new Phaser.Sprite object and adds it to the top of this group.\n\nUse {@link #classType} to change the type of object created.",
              "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String, exists: +Boolean) -> +PIXI.DisplayObject"
            },
            "countDead": {
              "!doc": "Get the number of dead children in this group.",
              "!type": "fn() -> +Number"
            },
            "subAll": {
              "!doc": "Subtracts the amount from the given property on all children in this group.\n\n`Group.subAll('x', 10)` will minus 10 from the child.x value for each child.",
              "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
            },
            "fixedToCamera": {
              "!doc": "A Group that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Group.cameraOffset.\n\nNote that the cameraOffset values are in addition to any parent in the display list.\nSo if this Group was in a Group that has x: 200, then this will be added to the cameraOffset.x",
              "!type": "+Boolean"
            },
            "add": {
              "!doc": "Adds an existing object as the top child in this group.\n\nThe child is automatically added to the top of the group and is displayed on top of every previous child.\n\nIf Group.enableBody is set then a physics body will be created on the object, so long as one does not already exist.\n\nUse {@link #addAt} to control where a child is added. Use {@link #create} to create and add a new child.",
              "!type": "fn(child: +DisplayObject, silent: +Boolean) -> +PIXI.DisplayObject"
            },
            "visible": {
              "!doc": "The visible state of the group. Non-visible Groups and all of their children are not rendered.",
              "!type": "+Boolean"
            },
            "swap": {
              "!doc": "Swaps the position of two children in this group.\n\nBoth children must be in this group, a child cannot be swapped with itself, and unparented children cannot be swapped.",
              "!type": "fn(child1: +Object, child2: +Object)"
            },
            "cameraOffset": {
              "!doc": "If this object is {@link #fixedToCamera} then this stores the x/y position offset relative to the top-left of the camera view.\nIf the parent of this Group is also `fixedToCamera` then the offset here is in addition to that and should typically be disabled.",
              "!type": "+Phaser.Point"
            },
            "sort": {
              "!doc": "Sort the children in the group according to a particular key and ordering.\n\nCall this function to sort the group according to a particular key value and order.\n\nFor example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.\n\nInternally this uses a standard JavaScript Array sort, so everything that applies there also applies here, including\nalphabetical sorting, mixing strings and numbers, and Unicode sorting. See MDN for more details.",
              "!type": "fn(key: +String, order: +Number)"
            },
            "moveDown": {
              "!doc": "Moves the given child down one place in this group unless it's already at the bottom.",
              "!type": "fn(child: +Object) -> +Object"
            },
            "hasProperty": {
              "!doc": "Checks if the child has the given property.\n\nWill scan up to 4 levels deep only.",
              "!type": "fn(child: +Object, key: +Array._string_) -> +Boolean"
            },
            "updateZ": {
              "!doc": "Internal method that re-applies all of the children's Z values.\n\nThis must be called whenever children ordering is altered so that their `z` indices are correctly updated.",
              "!type": "fn()"
            },
            "name": {
              "!doc": "A name for this group. Not used internally but useful for debugging.",
              "!type": "+String"
            },
            "ascendingSortHandler": {
              "!doc": "An internal helper function for the sort process.",
              "!type": "fn(a: +Object, b: +Object)"
            },
            "position": {
              "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
              "!type": "+Phaser.Point"
            },
            "removeBetween": {
              "!doc": "Removes all children from this group whose index falls beteen the given startIndex and endIndex values.",
              "!type": "fn(startIndex: +Number, endIndex: +Number, destroy: +Boolean, silent: +Boolean)"
            },
            "removeFromHash": {
              "!doc": "Removes a child of this Group from the hash array.\nThis call will return false if the child is not in the hash.",
              "!type": "fn(child: +DisplayObject) -> +Boolean"
            },
            "classType": {
              "!doc": "The type of objects that will be created when using {@link #create} or {@link #createMultiple}.\n\nAny object may be used but it should extend either Sprite or Image and accept the same constructor arguments:\nwhen a new object is created it is passed the following parameters to its constructor: `(game, x, y, key, frame)`.",
              "!type": "+Object"
            },
            "next": {
              "!doc": "Advances the group cursor to the next (higher) object in the group.\n\nIf the cursor is at the end of the group (top child) it is moved the start of the group (bottom child).",
              "!type": "fn() -> +Object"
            },
            "cursor": {
              "!doc": "The current display object that the group cursor is pointing to, if any. (Can be set manually.)\n\nThe cursor is a way to iterate through the children in a Group using {@link #next} and {@link #previous}.",
              "!type": "+PIXI.DisplayObject"
            },
            "worldRotation": {
              "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
              "!type": "+Number"
            },
            "game": {
              "!doc": "A reference to the currently running Game.",
              "!type": "+Phaser.Game"
            },
            "renderable": {
              "!doc": "Can this object be rendered",
              "!type": "+Boolean"
            },
            "forEachDead": {
              "!doc": "Call a function on each dead child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
              "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
            },
            "update": {
              "!doc": "The core update - as called by World.",
              "!type": "fn()"
            },
            "scale": {
              "!doc": "The scale factor of the object.",
              "!type": "+Phaser.Point"
            },
            "countLiving": {
              "!doc": "Get the number of living children in this group.",
              "!type": "fn() -> +Number"
            },
            "remove": {
              "!doc": "Removes the given child from this group.\n\nThis will dispatch an `onRemovedFromGroup` event from the child (if it has one), and optionally destroy the child.\n\nIf the group cursor was referring to the removed child it is updated to refer to the next child.",
              "!type": "fn(child: +Object, destroy: +Boolean, silent: +Boolean) -> +Boolean"
            },
            "callAll": {
              "!doc": "Calls a function, specified by name, on all on children.\n\nThe function is called for all children regardless if they are dead or alive (see callAllExists for different options).\nAfter the method parameter and context you can add as many extra parameters as you like, which will all be passed to the child.",
              "!type": "fn(method: +String, context: +String, args: +Object)"
            },
            "total": {
              "!doc": "Total number of existing children in the group.",
              "!type": "+Number"
            },
            "alpha": {
              "!doc": "The alpha value of the group container.",
              "!type": "+Number"
            },
            "createMultiple": {
              "!doc": "Creates multiple Phaser.Sprite objects and adds them to the top of this group.\n\nUseful if you need to quickly generate a pool of identical sprites, such as bullets.\n\nBy default the sprites will be set to not exist and will be positioned at 0, 0 (relative to the group.x/y).\nUse {@link #classType} to change the type of object created.",
              "!type": "fn(quantity: +Number, key: +String, frame: +Number, exists: +Boolean)"
            },
            "setAll": {
              "!doc": "Quickly set the same property across all children of this group to a new value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be set on the group but not its children.\nIf you need that ability please see `Group.setAllChildren`.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
              "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
            },
            "callAllExists": {
              "!doc": "Calls a function, specified by name, on all children in the group who exist (or do not exist).\n\nAfter the existsValue parameter you can add as many parameters as you like, which will all be passed to the child callback.",
              "!type": "fn(callback: +String, existsValue: +Boolean, parameter: +Object)"
            },
            "checkAll": {
              "!doc": "Quickly check that the same property across all children of this group is equal to the given value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be checked on the group but not its children.",
              "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, force: +Boolean)"
            },
            "previous": {
              "!doc": "Moves the group cursor to the previous (lower) child in the group.\n\nIf the cursor is at the start of the group (bottom child) it is moved to the end (top child).",
              "!type": "fn() -> +Object"
            },
            "forEach": {
              "!doc": "Call a function on each child in this group.\n\nAdditional arguments for the callback can be specified after the `checkExists` parameter. For example,\n\n    Group.forEach(awardBonusGold, this, true, 100, 500)\n\nwould invoke `awardBonusGold` function with the parameters `(child, 100, 500)`.\n\nNote: This check will skip any children which are Groups themselves.",
              "!type": "fn(callback: +Function, callbackContext: +Object, checkExists: +Boolean, args: +Object)"
            },
            "rotation": {
              "!doc": "The angle of rotation of the group container, in radians.\n\nThis will adjust the group container itself by modifying its rotation.\nThis will have no impact on the rotation value of its children, but it will update their worldTransform and on-screen position.",
              "!type": "+Number"
            },
            "length": {
              "!doc": "Total number of children in this group, regardless of exists/alive status.",
              "!type": "+Number"
            },
            "sendToBack": {
              "!doc": "Sends the given child to the bottom of this group so it renders below all other children.",
              "!type": "fn(child: +Object) -> +Object"
            },
            "getAt": {
              "!doc": "Returns the child found at the given index within this group.",
              "!type": "fn(index: +Number) -> +PIXI.DisplayObject"
            },
            "pendingDestroy": {
              "!doc": "A Group is that has `pendingDestroy` set to `true` is flagged to have its destroy method \ncalled on the next logic update.\nYou can set it directly to flag the Group to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy a Group from within one of its own callbacks \nor a callback of one of its children.",
              "!type": "+Boolean"
            },
            "getFirstAlive": {
              "!doc": "Get the first child that is alive (`child.alive === true`).\n\nThis is handy for choosing a squad leader, etc.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no alive ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
              "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
            },
            "hitArea": {
              "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
              "!type": "+Phaser.Rectangle"
            }
          }
        },
        "InversePointProxy": {
          "!doc": "A InversePointProxy is an internal class that allows for direct getter/setter style property access to Arrays and TypedArrays but inverses the values on set.",
          "!type": "fn(world: +Phaser.Physics.P2, destination: +Object)",
          "prototype": {
            "x": {
              "!doc": "The x property of this InversePointProxy get and set in pixels.",
              "!type": "+Number"
            },
            "y": {
              "!doc": "The y property of this InversePointProxy get and set in pixels.",
              "!type": "+Number"
            },
            "mx": {
              "!doc": "The x property of this InversePointProxy get and set in meters.",
              "!type": "+Number"
            },
            "my": {
              "!doc": "The y property of this InversePointProxy get and set in meters.",
              "!type": "+Number"
            }
          }
        },
        "RotationalSpring": {
          "!doc": "Creates a rotational spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.",
          "!type": "fn(world: +Phaser.Physics.P2, bodyA: +p2.Body, bodyB: +p2.Body, restAngle: +Number, stiffness: +Number, damping: +Number)",
          "prototype": {
            "game": {
              "!doc": "Local reference to game.",
              "!type": "+Phaser.Game"
            },
            "world": {
              "!doc": "Local reference to P2 World.",
              "!type": "+Phaser.Physics.P2"
            },
            "data": {
              "!doc": "The actual p2 spring object.",
              "!type": "+p2.RotationalSpring"
            }
          }
        },
        "GearConstraint": {
          "!doc": "Connects two bodies at given offset points, letting them rotate relative to each other around this point.",
          "!type": "fn(world: +Phaser.Physics.P2, bodyA: +p2.Body, bodyB: +p2.Body, angle: +Number, ratio: +Number)",
          "prototype": {
            "game": {
              "!doc": "Local reference to game.",
              "!type": "+Phaser.Game"
            },
            "world": {
              "!doc": "Local reference to P2 World.",
              "!type": "+Phaser.Physics.P2"
            }
          }
        },
        "!type": "fn(game: +Phaser.Game, config: +Object)",
        "Body": {
          "!doc": "The Physics Body is typically linked to a single Sprite and defines properties that determine how the physics body is simulated.\nThese properties affect how the body reacts to forces, what forces it generates on itself (to simulate friction), and how it reacts to collisions in the scene.\nIn most cases, the properties are used to simulate physical effects. Each body also has its own property values that determine exactly how it reacts to forces and collisions in the scene.\nBy default a single Rectangle shape is added to the Body that matches the dimensions of the parent Sprite. See addShape, removeShape, clearShapes to add extra shapes around the Body.\nNote: When bound to a Sprite to avoid single-pixel jitters on mobile devices we strongly recommend using Sprite sizes that are even on both axis, i.e. 128x128 not 127x127.\nNote: When a game object is given a P2 body it has its anchor x/y set to 0.5, so it becomes centered.",
          "KINEMATIC": "+Number",
          "!type": "fn(game: +Phaser.Game, sprite: +Phaser.Sprite, x: +Number, y: +Number, mass: +Number)",
          "prototype": {
            "setCollisionGroup": {
              "!doc": "Sets the given CollisionGroup to be the collision group for all shapes in this Body, unless a shape is specified.\nThis also resets the collisionMask.",
              "!type": "fn(group: +Phaser.Physics.CollisionGroup, shape: +p2.Shape)"
            },
            "sleepSpeedLimit": {
              "!doc": ".",
              "!type": "+Number"
            },
            "collidesWith": {
              "!doc": "Array of CollisionGroups that this Bodies shapes collide with.",
              "!type": "+Array"
            },
            "data": {
              "!doc": "The p2 Body data.",
              "!type": "+p2.Body"
            },
            "createGroupCallback": {
              "!doc": "Sets a callback to be fired any time this Body impacts with the given Group. The impact test is performed against shape.collisionGroup values.\nThe callback will be sent 4 parameters: This body, the body that impacted, the Shape in this body and the shape in the impacting body.\nThis callback will only fire if this Body has been assigned a collision group.\nNote that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\nIt also happens mid-step. So do not destroy a Body during this callback, instead set safeDestroy to true so it will be killed on the next preUpdate.",
              "!type": "fn(group: +Phaser.Physics.CollisionGroup, callback: +Function, callbackContext: +Object)"
            },
            "type": {
              "!doc": "The type of physics system this body belongs to.",
              "!type": "+Number"
            },
            "addParticle": {
              "!doc": "Adds a Particle shape to this Body. You can control the offset from the center of the body and the rotation.",
              "!type": "fn(offsetX: +Number, offsetY: +Number, rotation: +Number) -> +p2.Particle"
            },
            "addToWorld": {
              "!doc": "Adds this physics body to the world.",
              "!type": "fn()"
            },
            "removeCollisionGroup": {
              "!doc": "Removes the given CollisionGroup, or array of CollisionGroups, from the list of groups that this body will collide with and updates the collision masks.",
              "!type": "fn(group: +Phaser.Physics.CollisionGroup, clearCallback: +Boolean, shape: +p2.Shape)"
            },
            "angularForce": {
              "!doc": "The angular force acting on the body.",
              "!type": "+Number"
            },
            "clearCollision": {
              "!doc": "Clears the collision data from the shapes in this Body. Optionally clears Group and/or Mask.",
              "!type": "fn(clearGroup: +Boolean, clearMask: +Boolean, shape: +p2.Shape)"
            },
            "applyDamping": {
              "!doc": "Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details.",
              "!type": "fn(dt: +Number)"
            },
            "dynamic": {
              "!doc": "Returns true if the Body is dynamic. Setting Body.dynamic to 'false' will make it static.",
              "!type": "+Boolean"
            },
            "collideWorldBounds": {
              "!doc": "Should the Body collide with the World bounds?",
              "!type": "+Boolean"
            },
            "id": {
              "!doc": "The Body ID. Each Body that has been added to the World has a unique ID.",
              "!type": "+Number"
            },
            "getVelocityAtPoint": {
              "!doc": "Gets the velocity of a point in the body.",
              "!type": "fn(result: +Array, relativePoint: +Array) -> +Array"
            },
            "motionState": {
              "!doc": "The type of motion this body has. Should be one of: Body.STATIC (the body does not move), Body.DYNAMIC (body can move and respond to collisions) and Body.KINEMATIC (only moves according to its .velocity).",
              "!type": "+Number"
            },
            "moveUp": {
              "!doc": "If this Body is dynamic then this will move it up by setting its y velocity to the given speed.\nThe speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).",
              "!type": "fn(speed: +Number)"
            },
            "collides": {
              "!doc": "Adds the given CollisionGroup, or array of CollisionGroups, to the list of groups that this body will collide with and updates the collision masks.",
              "!type": "fn(group: +Phaser.Physics.CollisionGroup, callback: +Function, callbackContext: +Object, shape: +p2.Shape)"
            },
            "static": {
              "!doc": "Returns true if the Body is static. Setting Body.static to 'false' will make it dynamic.",
              "!type": "+Boolean"
            },
            "offset": {
              "!doc": "The offset of the Physics Body from the Sprite x/y position.",
              "!type": "+Phaser.Point"
            },
            "postUpdate": {
              "!doc": "Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.",
              "!type": "fn()"
            },
            "setRectangleFromSprite": {
              "!doc": "Clears any previously set shapes.\nThen creates a Rectangle shape sized to match the dimensions and orientation of the Sprite given.\nIf no Sprite is given it defaults to using the parent of this Body.\nIf this Body had a previously set Collision Group you will need to re-apply it to the new Shape this creates.",
              "!type": "fn(sprite: +Phaser.Sprite) -> +p2.Rectangle"
            },
            "createBodyCallback": {
              "!doc": "Sets a callback to be fired any time a shape in this Body impacts with a shape in the given Body. The impact test is performed against body.id values.\nThe callback will be sent 4 parameters: This body, the body that impacted, the Shape in this body and the shape in the impacting body.\nNote that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\nIt also happens mid-step. So do not destroy a Body during this callback, instead set safeDestroy to true so it will be killed on the next preUpdate.",
              "!type": "fn(object: +Phaser.Sprite, callback: +Function, callbackContext: +Object)"
            },
            "angularDamping": {
              "!doc": "The angular damping acting acting on the body.",
              "!type": "+Number"
            },
            "moveBackward": {
              "!doc": "Moves the Body backwards based on its current angle and the given speed.\nThe speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).",
              "!type": "fn(speed: +Number)"
            },
            "thrustLeft": {
              "!doc": "Applies a force to the Body that causes it to 'thrust' to the left, based on its current angle and the given speed.\nThe speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).",
              "!type": "fn(speed: +Number)"
            },
            "addShape": {
              "!doc": "Add a shape to the body. You can pass a local transform when adding a shape, so that the shape gets an offset and an angle relative to the body center of mass.\nWill automatically update the mass properties and bounding radius.\nIf this Body had a previously set Collision Group you will need to re-apply it to the new Shape this creates.",
              "!type": "fn(shape: +p2.Shape, offsetX: +Number, offsetY: +Number, rotation: +Number) -> +p2.Shape"
            },
            "destroy": {
              "!doc": "Destroys this Body and all references it holds to other objects.",
              "!type": "fn()"
            },
            "damping": {
              "!doc": "The linear damping acting on the body in the velocity direction.",
              "!type": "+Number"
            },
            "moveDown": {
              "!doc": "If this Body is dynamic then this will move it down by setting its y velocity to the given speed.\nThe speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).",
              "!type": "fn(speed: +Number)"
            },
            "removeShape": {
              "!doc": "Remove a shape from the body. Will automatically update the mass properties and bounding radius.",
              "!type": "fn(shape: +p2.Circle) -> +Boolean"
            },
            "toWorldFrame": {
              "!doc": "Transform a local point to world frame.",
              "!type": "fn(out: +Array, localPoint: +Array)"
            },
            "addLine": {
              "!doc": "Adds a Line shape to this Body.\nThe line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].\nYou can control the offset from the center of the body and the rotation.",
              "!type": "fn(length: +Number, offsetX: +Number, offsetY: +Number, rotation: +Number) -> +p2.Line"
            },
            "debugBody": {
              "!doc": "Reference to the debug body.",
              "!type": "+Phaser.Physics.P2.BodyDebug"
            },
            "setZeroVelocity": {
              "!doc": "If this Body is dynamic then this will zero its velocity on both axis.",
              "!type": "fn()"
            },
            "moveRight": {
              "!doc": "If this Body is dynamic then this will move it to the right by setting its x velocity to the given speed.\nThe speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).",
              "!type": "fn(speed: +Number)"
            },
            "thrust": {
              "!doc": "Applies a force to the Body that causes it to 'thrust' forwards, based on its current angle and the given speed.\nThe speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).",
              "!type": "fn(speed: +Number)"
            },
            "reset": {
              "!doc": "Resets the Body force, velocity (linear and angular) and rotation. Optionally resets damping and mass.",
              "!type": "fn(x: +Number, y: +Number, resetDamping: +Boolean, resetMass: +Boolean)"
            },
            "setZeroRotation": {
              "!doc": "If this Body is dynamic then this will zero its angular velocity.",
              "!type": "fn()"
            },
            "moveLeft": {
              "!doc": "If this Body is dynamic then this will move it to the left by setting its x velocity to the given speed.\nThe speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).",
              "!type": "fn(speed: +Number)"
            },
            "force": {
              "!doc": "The force applied to the body.",
              "!type": "+Phaser.Physics.P2.InversePointProxy"
            },
            "setRectangle": {
              "!doc": "Clears any previously set shapes. The creates a new Rectangle shape at the given size and offset, and adds it to this Body.\nIf you wish to create a Rectangle to match the size of a Sprite or Image see Body.setRectangleFromSprite.\nIf this Body had a previously set Collision Group you will need to re-apply it to the new Shape this creates.",
              "!type": "fn(width: +Number, height: +Number, offsetX: +Number, offsetY: +Number, rotation: +Number) -> +p2.Rectangle"
            },
            "preUpdate": {
              "!doc": "Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.",
              "!type": "fn()"
            },
            "updateCollisionMask": {
              "!doc": "Updates the collisionMask.",
              "!type": "fn(shape: +p2.Shape)"
            },
            "applyImpulseLocal": {
              "!doc": "Apply impulse to a point local to the body.\n\nThis could for example be a point on the Body surface. An impulse is a force added to a body during a short \nperiod of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.",
              "!type": "fn(impulse: +Float32Array, localX: +Number, localY: +Number)"
            },
            "moveForward": {
              "!doc": "Moves the Body forwards based on its current angle and the given speed.\nThe speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).",
              "!type": "fn(speed: +Number)"
            },
            "game": {
              "!doc": "Local reference to game.",
              "!type": "+Phaser.Game"
            },
            "getCollisionMask": {
              "!doc": "Gets the collision bitmask from the groups this body collides with.",
              "!type": "fn() -> +Number"
            },
            "addPlane": {
              "!doc": "Adds a Plane shape to this Body. The plane is facing in the Y direction. You can control the offset from the center of the body and the rotation.",
              "!type": "fn(offsetX: +Number, offsetY: +Number, rotation: +Number) -> +p2.Plane"
            },
            "shapeChanged": {
              "!doc": "Updates the debug draw if any body shapes change.",
              "!type": "fn()"
            },
            "mass": {
              "!doc": "The mass of the body.",
              "!type": "+Number"
            },
            "setZeroDamping": {
              "!doc": "Sets the Body damping and angularDamping to zero.",
              "!type": "fn()"
            },
            "rotateLeft": {
              "!doc": "This will rotate the Body by the given speed to the left (counter-clockwise).",
              "!type": "fn(speed: +Number)"
            },
            "adjustCenterOfMass": {
              "!doc": "Moves the shape offsets so their center of mass becomes the body center of mass.",
              "!type": "fn()"
            },
            "thrustRight": {
              "!doc": "Applies a force to the Body that causes it to 'thrust' to the right, based on its current angle and the given speed.\nThe speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).",
              "!type": "fn(speed: +Number)"
            },
            "loadPolygon": {
              "!doc": "Reads the shape data from a physics data file stored in the Game.Cache and adds it as a polygon to this Body.\n\nAs well as reading the data from the Cache you can also pass `null` as the first argument and a\nphysics data object as the second. When doing this you must ensure the structure of the object is correct in advance.\n\nFor more details see the format of the Lime / Corona Physics Editor export.",
              "!type": "fn(key: +String, object: +String) -> +Boolean"
            },
            "setMaterial": {
              "!doc": "Adds the given Material to all Shapes that belong to this Body.\nIf you only wish to apply it to a specific Shape in this Body then provide that as the 2nd parameter.",
              "!type": "fn(material: +Phaser.Physics.P2.Material, shape: +p2.Shape)"
            },
            "clearShapes": {
              "!doc": "Removes all Shapes from this Body.",
              "!type": "fn()"
            },
            "setZeroForce": {
              "!doc": "Sets the force on the body to zero.",
              "!type": "fn()"
            },
            "addPolygon": {
              "!doc": "Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points. The shape must be simple and without holes.\nThis function expects the x.y values to be given in pixels. If you want to provide them at p2 world scales then call Body.data.fromPolygon directly.",
              "!type": "fn(options: +Object, options_optimalDecomp: +Boolean, options_skipSimpleCheck: +Boolean, options_removeCollinearPoints: +Boolean, points: +Array._number_) -> +Boolean"
            },
            "inertia": {
              "!doc": "The inertia of the body around the Z axis..",
              "!type": "+Number"
            },
            "toLocalFrame": {
              "!doc": "Transform a world point to local body frame.",
              "!type": "fn(out: +Float32Array, worldPoint: +Float32Array)"
            },
            "addRectangle": {
              "!doc": "Adds a Rectangle shape to this Body. You can control the offset from the center of the body and the rotation.",
              "!type": "fn(width: +Number, height: +Number, offsetX: +Number, offsetY: +Number, rotation: +Number) -> +p2.Box"
            },
            "world": {
              "!doc": "Local reference to the P2 World.",
              "!type": "+Phaser.Physics.P2"
            },
            "allowSleep": {
              "!doc": "-",
              "!type": "+Boolean"
            },
            "sprite": {
              "!doc": "Reference to the parent Sprite.",
              "!type": "+Phaser.Sprite"
            },
            "angle": {
              "!doc": "The angle of this Body in degrees.",
              "!type": "+Number"
            },
            "removeFromWorld": {
              "!doc": "Removes this physics body from the world.",
              "!type": "fn()"
            },
            "addFixture": {
              "!doc": "Add a polygon fixture. This is used during #loadPolygon.",
              "!type": "fn(fixtureData: +String) -> +Array"
            },
            "removeNextStep": {
              "!doc": "To avoid deleting this body during a physics step, and causing all kinds of problems, set removeNextStep to true to have it removed in the next preUpdate.",
              "!type": "+Boolean"
            },
            "addCapsule": {
              "!doc": "Adds a Capsule shape to this Body.\nYou can control the offset from the center of the body and the rotation.",
              "!type": "fn(length: +Number, radius: +Number, offsetX: +Number, offsetY: +Number, rotation: +Number) -> +p2.Capsule"
            },
            "dirty": {
              "!doc": "Internally used by Sprite.x/y",
              "!type": "+Boolean"
            },
            "debug": {
              "!doc": "Enable or disable debug drawing of this body",
              "!type": "+Boolean"
            },
            "rotateRight": {
              "!doc": "This will rotate the Body by the given speed to the left (clockwise).",
              "!type": "fn(speed: +Number)"
            },
            "onEndContact": {
              "!doc": "Dispatched when contact ends between shapes in two bodies.\nThis event is fired during the step, so collision has already taken place.\n\nThe event will be sent 4 arguments in this order:\n\nThe Phaser.Physics.P2.Body it is in contact with. *This might be null* if the Body was created directly in the p2 world.\nThe p2.Body this Body has ended contact with.\nThe Shape from this body that caused the original contact.\nThe Shape from the contact body.",
              "!type": "+Phaser.Signal"
            },
            "rotation": {
              "!doc": "The angle of this Body in radians.",
              "!type": "+Number"
            },
            "setCircle": {
              "!doc": "Clears any previously set shapes. Then creates a new Circle shape and adds it to this Body.\nIf this Body had a previously set Collision Group you will need to re-apply it to the new Shape this creates.",
              "!type": "fn(radius: +Number, offsetX: +Number, offsetY: +Number, rotation: +Number)"
            },
            "velocity": {
              "!doc": "The velocity of the body. Set velocity.x to a negative value to move to the left, position to the right. velocity.y negative values move up, positive move down.",
              "!type": "+Phaser.Physics.P2.InversePointProxy"
            },
            "reverse": {
              "!doc": "Applies a force to the Body that causes it to 'thrust' backwards (in reverse), based on its current angle and the given speed.\nThe speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).",
              "!type": "fn(speed: +Number)"
            },
            "addPhaserPolygon": {
              "!doc": "Reads the shape data from a physics data file stored in the Game.Cache and adds it as a polygon to this Body.\nThe shape data format is based on the output of the\n{@link https://github.com/photonstorm/phaser/tree/master/resources/PhysicsEditor%20Exporter|custom phaser exporter} for\n{@link https://www.codeandweb.com/physicseditor|PhysicsEditor}",
              "!type": "fn(key: +String, object: +String) -> +Array"
            },
            "angularVelocity": {
              "!doc": "The angular velocity of the body.",
              "!type": "+Number"
            },
            "applyForce": {
              "!doc": "Apply force to a world point.\n\nThis could for example be a point on the RigidBody surface. Applying force \nthis way will add to Body.force and Body.angularForce.",
              "!type": "fn(force: +Float32Array, worldX: +Number, worldY: +Number)"
            },
            "kinematic": {
              "!doc": "Returns true if the Body is kinematic. Setting Body.kinematic to 'false' will make it static.",
              "!type": "+Boolean"
            },
            "applyImpulse": {
              "!doc": "Apply impulse to a point relative to the body.\nThis could for example be a point on the Body surface. An impulse is a force added to a body during a short \nperiod of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.",
              "!type": "fn(impulse: +Float32Array, worldX: +Number, worldY: +Number)"
            },
            "addCircle": {
              "!doc": "Adds a Circle shape to this Body. You can control the offset from the center of the body and the rotation.",
              "!type": "fn(radius: +Number, offsetX: +Number, offsetY: +Number, rotation: +Number) -> +p2.Circle"
            },
            "gravity": {
              "!doc": "A locally applied gravity force to the Body. Applied directly before the world step. NOTE: Not currently implemented.",
              "!type": "+Phaser.Point"
            },
            "x": {
              "!doc": "The x coordinate of this Body.",
              "!type": "+Number"
            },
            "y": {
              "!doc": "The y coordinate of this Body.",
              "!type": "+Number"
            },
            "onBeginContact": {
              "!doc": "Dispatched when a first contact is created between shapes in two bodies. \nThis event is fired during the step, so collision has already taken place.\n\nThe event will be sent 5 arguments in this order:\n\nThe Phaser.Physics.P2.Body it is in contact with. *This might be null* if the Body was created directly in the p2 world.\nThe p2.Body this Body is in contact with.\nThe Shape from this body that caused the contact.\nThe Shape from the contact body.\nThe Contact Equation data array.",
              "!type": "+Phaser.Signal"
            },
            "fixedRotation": {
              "!doc": "-",
              "!type": "+Boolean"
            }
          },
          "STATIC": "+Number",
          "DYNAMIC": "+Number"
        },
        "FixtureList": {
          "!doc": "Allow to access a list of created fixture (coming from Body#addPhaserPolygon)\nwhich itself parse the input from PhysicsEditor with the custom phaser exporter.\nYou can access fixtures of a Body by a group index or even by providing a fixture Key.\nYou can set the fixture key and also the group index for a fixture in PhysicsEditor.\nThis gives you the power to create a complex body built of many fixtures and modify them\nduring runtime (to remove parts, set masks, categories & sensor properties)",
          "!type": "fn(list: +Array)",
          "prototype": {
            "setSensor": {
              "!doc": "",
              "!type": "fn(value: +Boolean, fixtureKey: +String)"
            },
            "flatten": {
              "!doc": "A helper to flatten arrays. This is very useful as the fixtures are nested from time to time due to the way P2 creates and splits polygons.",
              "!type": "fn(array: +Array)"
            },
            "init": {
              "!doc": "",
              "!type": "fn()"
            },
            "setMask": {
              "!doc": "",
              "!type": "fn(bit: +Number, fixtureKey: +String)"
            },
            "setCategory": {
              "!doc": "",
              "!type": "fn(bit: +Number, fixtureKey: +String)"
            },
            "getGroup": {
              "!doc": "Accessor to get a group of fixtures by its group index.",
              "!type": "fn(groupID: +Number)"
            },
            "parse": {
              "!doc": "Parser for the output of Phaser.Physics.P2.Body#addPhaserPolygon",
              "!type": "fn()"
            },
            "setMaterial": {
              "!doc": "",
              "!type": "fn(material: +Object, fixtureKey: +String)"
            },
            "getFixtures": {
              "!doc": "Accessor to get either a list of specified fixtures by key or the whole fixture list",
              "!type": "fn(keys: +Array)"
            },
            "getFixtureByKey": {
              "!doc": "Accessor to get either a single fixture by its key.",
              "!type": "fn(key: +String)"
            }
          }
        }
      },
      "Ninja": {
        "Circle": {
          "!doc": "Ninja Physics Circle constructor.\nNote: This class could be massively optimised and reduced in size. I leave that challenge up to you.",
          "!type": "fn(body: +Phaser.Physics.Ninja.Body, x: +Number, y: +Number, radius: +Number)",
          "prototype": {
            "resolveCircleTile": {
              "!doc": "Resolves tile collision.",
              "!type": "fn(x: +Number, y: +Number, oH: +Number, oV: +Number, obj: +Phaser.Physics.Ninja.Circle, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "oldpos": {
              "!doc": "The position of this object in the previous update.",
              "!type": "+Phaser.Point"
            },
            "circleTileProjections": {
              "!doc": "All of the collision response handlers.",
              "!type": "+Object"
            },
            "pos": {
              "!doc": "The position of this object.",
              "!type": "+Phaser.Point"
            },
            "projCircle_Convex": {
              "!doc": "Resolves Convex tile collision.",
              "!type": "fn(x: +Number, y: +Number, oH: +Number, oV: +Number, obj: +Phaser.Physics.Ninja.Circle, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "projCircle_67DegB": {
              "!doc": "Resolves 67 Degree tile collision.",
              "!type": "fn(x: +Number, y: +Number, oH: +Number, oV: +Number, obj: +Phaser.Physics.Ninja.Circle, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "collideWorldBounds": {
              "!doc": "Collides this Circle against the world bounds.",
              "!type": "fn()"
            },
            "projCircle_45Deg": {
              "!doc": "Resolves 45 Degree tile collision.",
              "!type": "fn(x: +Number, y: +Number, oH: +Number, oV: +Number, obj: +Phaser.Physics.Ninja.Circle, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "radius": {
              "!doc": "The radius of this circle shape.",
              "!type": "+Number"
            },
            "render": {
              "!doc": "Render this circle for debugging purposes.",
              "!type": "fn(context: +Object, xOffset: +Number, yOffset: +Number, color: +String, filled: +Boolean)"
            },
            "projCircle_Full": {
              "!doc": "Resolves Full tile collision.",
              "!type": "fn(x: +Number, y: +Number, oH: +Number, oV: +Number, obj: +Phaser.Physics.Ninja.Circle, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "height": {
              "!doc": "The height.",
              "!type": "+Number"
            },
            "projCircle_22DegS": {
              "!doc": "Resolves 22 Degree tile collision.",
              "!type": "fn(x: +Number, y: +Number, oH: +Number, oV: +Number, obj: +Phaser.Physics.Ninja.Circle, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "projCircle_Concave": {
              "!doc": "Resolves Concave tile collision.",
              "!type": "fn(x: +Number, y: +Number, oH: +Number, oV: +Number, obj: +Phaser.Physics.Ninja.Circle, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "destroy": {
              "!doc": "Destroys this Circle's reference to Body and System",
              "!type": "fn()"
            },
            "collideCircleVsTile": {
              "!doc": "Collides this Circle with a Tile.",
              "!type": "fn(t: +Phaser.Physics.Ninja.Tile) -> +Boolean"
            },
            "velocity": {
              "!doc": "The velocity of this object.",
              "!type": "+Phaser.Point"
            },
            "integrate": {
              "!doc": "Updates this Circles position.",
              "!type": "fn()"
            },
            "reportCollisionVsWorld": {
              "!doc": "Process a world collision and apply the resulting forces.",
              "!type": "fn(px: +Number, py: +Number, dx: +Number, dy: +Number, obj: +Number)"
            },
            "projCircle_22DegB": {
              "!doc": "Resolves 22 Degree tile collision.",
              "!type": "fn(x: +Number, y: +Number, oH: +Number, oV: +Number, obj: +Phaser.Physics.Ninja.Circle, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "system": {
              "!doc": "A reference to the body that owns this shape.",
              "!type": "+Phaser.Physics.Ninja.Body"
            },
            "projCircle_67DegS": {
              "!doc": "Resolves 67 Degree tile collision.",
              "!type": "fn(x: +Number, y: +Number, oH: +Number, oV: +Number, obj: +Phaser.Physics.Ninja.Circle, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "width": {
              "!doc": "The width.",
              "!type": "+Number"
            },
            "projCircle_Half": {
              "!doc": "Resolves Half tile collision.",
              "!type": "fn(x: +Number, y: +Number, oH: +Number, oV: +Number, obj: +Phaser.Physics.Ninja.Circle, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "xw": {
              "!doc": "Half the width.",
              "!type": "+Number"
            }
          }
        },
        "!doc": "Ninja Physics. The Ninja Physics system was created in Flash by Metanet Software and ported to JavaScript by Richard Davey.\n\nIt allows for AABB and Circle to Tile collision. Tiles can be any of 34 different types, including slopes, convex and concave shapes.\n\nIt does what it does very well, but is ripe for expansion and optimisation. Here are some features that I'd love to see the community add:\n\n* AABB to AABB collision\n* AABB to Circle collision\n* AABB and Circle 'immovable' property support\n* n-way collision, so an AABB/Circle could pass through a tile from below and land upon it.\n* QuadTree or spatial grid for faster Body vs. Tile Group look-ups.\n* Optimise the internal vector math and reduce the quantity of temporary vars created.\n* Expand Gravity and Bounce to allow for separate x/y axis values.\n* Support Bodies linked to Sprites that don't have anchor set to 0.5\n\nFeel free to attempt any of the above and submit a Pull Request with your code! Be sure to include test cases proving they work.",
        "Tile": {
          "!doc": "Ninja Physics Tile constructor.\nA Tile is defined by its width, height and type. It's type can include slope data, such as 45 degree slopes, or convex slopes.\nUnderstand that for any type including a slope (types 2 to 29) the Tile must be SQUARE, i.e. have an equal width and height.\nAlso note that as Tiles are primarily used for levels they have gravity disabled and world bounds collision disabled by default.\n\nNote: This class could be massively optimised and reduced in size. I leave that challenge up to you.",
          "!type": "fn(body: +Phaser.Physics.Ninja.Body, x: +Number, y: +Number, width: +Number, height: +Number, type: +Number)",
          "prototype": {
            "bottom": {
              "!doc": "The bottom value of this Body (same as Body.y + Body.height)",
              "!type": "+Number"
            },
            "oldpos": {
              "!doc": "The position of this object in the previous update.",
              "!type": "+Phaser.Point"
            },
            "clear": {
              "!doc": "Sets this tile to be empty.",
              "!type": "fn()"
            },
            "destroy": {
              "!doc": "Destroys this Tiles reference to Body and System.",
              "!type": "fn()"
            },
            "velocity": {
              "!doc": "The velocity of this object.",
              "!type": "+Phaser.Point"
            },
            "right": {
              "!doc": "The right value of this Body (same as Body.x + Body.width)",
              "!type": "+Number"
            },
            "setType": {
              "!doc": "Tiles cannot collide with the world bounds, it's up to you to keep them where you want them. But we need this API stub to satisfy the Body.",
              "!type": "fn(id: +Number)"
            },
            "type": {
              "!doc": "The type of this Tile.",
              "!type": "+Number"
            },
            "integrate": {
              "!doc": "Updates this objects position.",
              "!type": "fn()"
            },
            "reportCollisionVsWorld": {
              "!doc": "Process a world collision and apply the resulting forces.",
              "!type": "fn(px: +Number, py: +Number, dx: +Number, dy: +Number, obj: +Number)"
            },
            "system": {
              "!doc": "A reference to the body that owns this shape.",
              "!type": "+Phaser.Physics.Ninja.Body"
            },
            "pos": {
              "!doc": "The position of this object.",
              "!type": "+Phaser.Point"
            },
            "width": {
              "!doc": "The width.",
              "!type": "+Number"
            },
            "x": {
              "!doc": "The x position.",
              "!type": "+Number"
            },
            "y": {
              "!doc": "The y position.",
              "!type": "+Number"
            },
            "collideWorldBounds": {
              "!doc": "Tiles cannot collide with the world bounds, it's up to you to keep them where you want them. But we need this API stub to satisfy the Body.",
              "!type": "fn()"
            },
            "id": {
              "!doc": "The ID of this Tile.",
              "!type": "+Number"
            },
            "xw": {
              "!doc": "Half the width.",
              "!type": "+Number"
            },
            "height": {
              "!doc": "The height.",
              "!type": "+Number"
            }
          }
        },
        "!type": "fn(game: +Phaser.Game)",
        "Body": {
          "!doc": "The Physics Body is linked to a single Sprite. All physics operations should be performed against the body rather than\nthe Sprite itself. For example you can set the velocity, bounce values etc all on the Body.",
          "!type": "fn(system: +Phaser.Physics.Ninja, sprite: +Phaser.Sprite, type: +Number, id: +Number, radius: +Number, x: +Number, y: +Number, width: +Number, height: +Number)",
          "prototype": {
            "game": {
              "!doc": "Local reference to game.",
              "!type": "+Phaser.Game"
            },
            "gravityScale": {
              "!doc": "How much of the world gravity should be applied to this object? 1 = all of it, 0.5 = 50%, etc.",
              "!type": "+Number"
            },
            "bounce": {
              "!doc": "The bounciness of this object when it collides. A value between 0 and 1. We recommend setting it to 0.999 to avoid jittering.",
              "!type": "+Number"
            },
            "immovable": {
              "!doc": "An immovable Body will not receive any impacts from other bodies. Not fully implemented.",
              "!type": "+Boolean"
            },
            "deltaX": {
              "!doc": "Returns the delta x value. The difference between Body.x now and in the previous step.",
              "!type": "fn() -> +Number"
            },
            "deltaY": {
              "!doc": "Returns the delta y value. The difference between Body.y now and in the previous step.",
              "!type": "fn() -> +Number"
            },
            "facing": {
              "!doc": "A const reference to the direction the Body is traveling or facing.",
              "!type": "+Number"
            },
            "type": {
              "!doc": "The type of physics system this body belongs to.",
              "!type": "+Number"
            },
            "aabb": {
              "!doc": "The AABB object this body is using for collision.",
              "!type": "+Phaser.Physics.Ninja.AABB"
            },
            "speed": {
              "!doc": "The speed of this Body",
              "!type": "+Number"
            },
            "sprite": {
              "!doc": "Reference to the parent Sprite.",
              "!type": "+Phaser.Sprite"
            },
            "tile": {
              "!doc": "The Tile object this body is using for collision.",
              "!type": "+Phaser.Physics.Ninja.Tile"
            },
            "angle": {
              "!doc": "The angle of this Body",
              "!type": "+Number"
            },
            "collideWorldBounds": {
              "!doc": "Should the Body collide with the World bounds?",
              "!type": "+Boolean"
            },
            "drag": {
              "!doc": "The drag applied to this object as it moves.",
              "!type": "+Number"
            },
            "render": {
              "!doc": "Render Sprite's Body.",
              "!type": "fn(context: +Object, body: +Phaser.Physics.Ninja.Body, color: +String, filled: +Boolean)"
            },
            "height": {
              "!doc": "The height of this Body",
              "!type": "+Number"
            },
            "deltaAbsY": {
              "!doc": "Returns the absolute delta y value.",
              "!type": "fn() -> +Number"
            },
            "shape": {
              "!doc": "A local reference to the body shape.",
              "!type": "+Object"
            },
            "checkCollision": {
              "!doc": "An object containing allowed collision.",
              "!type": "+Object"
            },
            "postUpdate": {
              "!doc": "Internal method.",
              "!type": "fn()"
            },
            "deltaAbsX": {
              "!doc": "Returns the absolute delta x value.",
              "!type": "fn() -> +Number"
            },
            "touching": {
              "!doc": "An object containing touching results.",
              "!type": "+Object"
            },
            "bottom": {
              "!doc": "The bottom value of this Body (same as Body.y + Body.height)",
              "!type": "+Number"
            },
            "destroy": {
              "!doc": "Destroys this body's reference to the sprite and system, and destroys its shape.",
              "!type": "fn()"
            },
            "velocity": {
              "!doc": "The velocity in pixels per second sq. of the Body.",
              "!type": "+Phaser.Point"
            },
            "maxSpeed": {
              "!doc": "The maximum speed this body can travel at (taking drag and friction into account)",
              "!type": "+Number"
            },
            "right": {
              "!doc": "The right value of this Body (same as Body.x + Body.width)",
              "!type": "+Number"
            },
            "friction": {
              "!doc": "The friction applied to this object as it moves.",
              "!type": "+Number"
            },
            "wasTouching": {
              "!doc": "An object containing previous touching results.",
              "!type": "+Object"
            },
            "system": {
              "!doc": "The parent physics system.",
              "!type": "+Phaser.Physics.Ninja"
            },
            "setZeroVelocity": {
              "!doc": "Stops all movement of this body.",
              "!type": "fn()"
            },
            "x": {
              "!doc": "The x position.",
              "!type": "+Number"
            },
            "width": {
              "!doc": "The width of this Body",
              "!type": "+Number"
            },
            "reset": {
              "!doc": "Resets all Body values and repositions on the Sprite.",
              "!type": "fn()"
            },
            "y": {
              "!doc": "The y position.",
              "!type": "+Number"
            },
            "circle": {
              "!doc": "The Circle object this body is using for collision.",
              "!type": "+Phaser.Physics.Ninja.Circle"
            },
            "preUpdate": {
              "!doc": "Internal method.",
              "!type": "fn()"
            }
          }
        },
        "prototype": {
          "game": {
            "!doc": "Local reference to game.",
            "!type": "+Phaser.Game"
          },
          "separate": {
            "!doc": "The core separation function to separate two physics bodies.",
            "!type": "fn(body1: +Phaser.Physics.Ninja.Body, body2: +Phaser.Physics.Ninja.Body) -> +Boolean"
          },
          "maxLevels": {
            "!doc": "Used by the QuadTree to set the maximum number of iteration levels.",
            "!type": "+Number"
          },
          "quadTree": {
            "!doc": "The world QuadTree.",
            "!type": "+Phaser.QuadTree"
          },
          "enableTile": {
            "!doc": "This will create a Ninja Physics Tile body on the given game object. There are 34 different types of tile you can create, including 45 degree slopes,\nconvex and concave circles and more. The id parameter controls which Tile type is created, but you can also change it at run-time.\nNote that for all degree based tile types they need to have an equal width and height. If the given object doesn't have equal width and height it will use the width.\nA game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.",
            "!type": "fn(object: +Object, id: +Number, children: +Boolean)"
          },
          "collide": {
            "!doc": "Checks for collision between two game objects. You can perform Sprite vs. Sprite, Sprite vs. Group, Group vs. Group, Sprite vs. Tilemap Layer or Group vs. Tilemap Layer collisions.\nThe second parameter can be an array of objects, of differing types.\nThe objects are also automatically separated. If you don't require separation then use ArcadePhysics.overlap instead.\nAn optional processCallback can be provided. If given this function will be called when two sprites are found to be colliding. It is called before any separation takes place,\ngiving you the chance to perform additional checks. If the function returns true then the collision and separation is carried out. If it returns false it is skipped.\nThe collideCallback is an optional function that is only called if two sprites collide. If a processCallback has been set then it needs to return true for collideCallback to be called.",
            "!type": "fn(object1: +Phaser.Sprite, object2: +Phaser.Sprite, collideCallback: +Function, processCallback: +Function, callbackContext: +Object) -> +Boolean"
          },
          "enableAABB": {
            "!doc": "This will create a Ninja Physics AABB body on the given game object. Its dimensions will match the width and height of the object at the point it is created.\nA game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.",
            "!type": "fn(object: +Object, children: +Boolean)"
          },
          "setBounds": {
            "!doc": "Updates the size of this physics world.",
            "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number)"
          },
          "setBoundsToWorld": {
            "!doc": "Updates the size of this physics world to match the size of the game world.",
            "!type": "fn()"
          },
          "convertTilemap": {
            "!doc": "Goes through all tiles in the given Tilemap and TilemapLayer and converts those set to collide into physics tiles.\nOnly call this *after* you have specified all of the tiles you wish to collide with calls like Tilemap.setCollisionBetween, etc.\nEvery time you call this method it will destroy any previously created bodies and remove them from the world.\nTherefore understand it's a very expensive operation and not to be done in a core game update loop.\n\nIn Ninja the Tiles have an ID from 0 to 33, where 0 is 'empty', 1 is a full tile, 2 is a 45-degree slope, etc. You can find the ID\nlist either at the very bottom of `Tile.js`, or in a handy visual reference in the `resources/Ninja Physics Debug Tiles` folder in the repository.\nThe slopeMap parameter is an array that controls how the indexes of the tiles in your tilemap data will map to the Ninja Tile IDs.\nFor example if you had 6 tiles in your tileset: Imagine the first 4 should be converted into fully solid Tiles and the other 2 are 45-degree slopes.\nYour slopeMap array would look like this: `[ 1, 1, 1, 1, 2, 3 ]`.\nWhere each element of the array is a tile in your tilemap and the resulting Ninja Tile it should create.",
            "!type": "fn(map: +Phaser.Tilemap, layer: +Number, slopeMap: +Object) -> +Array"
          },
          "overlap": {
            "!doc": "Checks for overlaps between two game objects. The objects can be Sprites, Groups or Emitters.\nYou can perform Sprite vs. Sprite, Sprite vs. Group and Group vs. Group overlap checks.\nUnlike collide the objects are NOT automatically separated or have any physics applied, they merely test for overlap results.\nThe second parameter can be an array of objects, of differing types.",
            "!type": "fn(object1: +Phaser.Sprite, object2: +Phaser.Sprite, overlapCallback: +Function, processCallback: +Function, callbackContext: +Object) -> +Boolean"
          },
          "enableCircle": {
            "!doc": "This will create a Ninja Physics Circle body on the given game object.\nA game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.",
            "!type": "fn(object: +Object, radius: +Number, children: +Boolean)"
          },
          "enableBody": {
            "!doc": "Creates a Ninja Physics body on the given game object.\nA game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.",
            "!type": "fn(object: +Object)"
          },
          "enable": {
            "!doc": "This will create a Ninja Physics body on the given game object or array of game objects.\nA game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.",
            "!type": "fn(object: +Object, type: +Number, id: +Number, radius: +Number, children: +Boolean)"
          },
          "gravity": {
            "!doc": "The World gravity setting.",
            "!type": "+Number"
          },
          "bounds": {
            "!doc": "The bounds inside of which the physics world exists. Defaults to match the world bounds.",
            "!type": "+Phaser.Rectangle"
          },
          "time": {
            "!doc": "Local reference to game.time.",
            "!type": "+Phaser.Time"
          },
          "maxObjects": {
            "!doc": "Used by the QuadTree to set the maximum number of objects per quad.",
            "!type": "+Number"
          },
          "clearTilemapLayerBodies": {
            "!doc": "Clears all physics bodies from the given TilemapLayer that were created with `World.convertTilemap`.",
            "!type": "fn(map: +Phaser.Tilemap, layer: +Number)"
          }
        },
        "AABB": {
          "!doc": "Ninja Physics AABB constructor.\nNote: This class could be massively optimised and reduced in size. I leave that challenge up to you.",
          "!type": "fn(body: +Phaser.Physics.Ninja.Body, x: +Number, y: +Number, width: +Number, height: +Number)",
          "prototype": {
            "projAABB_22DegS": {
              "!doc": "Resolves 22 Degree tile collision.",
              "!type": "fn(x: +Number, y: +Number, obj: +Phaser.Physics.Ninja.AABB, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "aabbTileProjections": {
              "!doc": "All of the collision response handlers.",
              "!type": "+Object"
            },
            "projAABB_Concave": {
              "!doc": "Resolves Concave tile collision.",
              "!type": "fn(x: +Number, y: +Number, obj: +Phaser.Physics.Ninja.AABB, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "oldpos": {
              "!doc": "The position of this object in the previous update.",
              "!type": "+Phaser.Point"
            },
            "collideAABBVsAABB": {
              "!doc": "Collides this AABB against a AABB.",
              "!type": "fn(aabb: +Phaser.Physics.Ninja.AABB)"
            },
            "reportCollisionVsBody": {
              "!doc": "Process a body collision and apply the resulting forces. Still very much WIP and doesn't work fully. Feel free to fix!",
              "!type": "fn(px: +Number, py: +Number, dx: +Number, dy: +Number, obj: +Number)"
            },
            "collideAABBVsTile": {
              "!doc": "Collides this AABB against a Tile.",
              "!type": "fn(tile: +Phaser.Physics.Ninja.Tile)"
            },
            "projAABB_Full": {
              "!doc": "Resolves Full tile collision.",
              "!type": "fn(x: +Number, y: +Number, obj: +Phaser.Physics.Ninja.AABB, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "pos": {
              "!doc": "The position of this object.",
              "!type": "+Phaser.Point"
            },
            "projAABB_Convex": {
              "!doc": "Resolves Convex tile collision.",
              "!type": "fn(x: +Number, y: +Number, obj: +Phaser.Physics.Ninja.AABB, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "projAABB_67DegB": {
              "!doc": "Resolves 67 Degree tile collision.",
              "!type": "fn(x: +Number, y: +Number, obj: +Phaser.Physics.Ninja.AABB, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "projAABB_45Deg": {
              "!doc": "Resolves 45 Degree tile collision.",
              "!type": "fn(x: +Number, y: +Number, obj: +Phaser.Physics.Ninja.AABB, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "collideWorldBounds": {
              "!doc": "Collides this AABB against the world bounds.",
              "!type": "fn()"
            },
            "render": {
              "!doc": "Render this AABB for debugging purposes.",
              "!type": "fn(context: +Object, xOffset: +Number, yOffset: +Number, color: +String, filled: +Boolean)"
            },
            "resolveTile": {
              "!doc": "Resolves tile collision.",
              "!type": "fn(x: +Number, y: +Number, body: +Phaser.Physics.Ninja.AABB, tile: +Phaser.Physics.Ninja.Tile) -> +Boolean"
            },
            "height": {
              "!doc": "The height.",
              "!type": "+Number"
            },
            "destroy": {
              "!doc": "Destroys this AABB's reference to Body and System",
              "!type": "fn()"
            },
            "velocity": {
              "!doc": "The velocity of this object.",
              "!type": "+Phaser.Point"
            },
            "reverse": {
              "!doc": "",
              "!type": "fn()"
            },
            "integrate": {
              "!doc": "Updates this AABBs position.",
              "!type": "fn()"
            },
            "projAABB_Half": {
              "!doc": "Resolves Half tile collision.",
              "!type": "fn(x: +Number, y: +Number, obj: +Phaser.Physics.Ninja.AABB, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "reportCollisionVsWorld": {
              "!doc": "Process a world collision and apply the resulting forces.",
              "!type": "fn(px: +Number, py: +Number, dx: +Number, dy: +Number)"
            },
            "projAABB_22DegB": {
              "!doc": "Resolves 22 Degree tile collision.",
              "!type": "fn(x: +Number, y: +Number, obj: +Phaser.Physics.Ninja.AABB, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "system": {
              "!doc": "A reference to the body that owns this shape.",
              "!type": "+Phaser.Physics.Ninja.Body"
            },
            "projAABB_67DegS": {
              "!doc": "Resolves 67 Degree tile collision.",
              "!type": "fn(x: +Number, y: +Number, obj: +Phaser.Physics.Ninja.AABB, t: +Phaser.Physics.Ninja.Tile) -> +Number"
            },
            "width": {
              "!doc": "The width.",
              "!type": "+Number"
            },
            "reportCollision": {
              "!doc": "Process a collision partner-agnostic collision response and apply the resulting forces.",
              "!type": "fn(px: +Number, py: +Number, dx: +Number, dy: +Number)"
            },
            "xw": {
              "!doc": "Half the width.",
              "!type": "+Number"
            }
          }
        }
      },
      "!doc": "The Physics Manager is responsible for looking after all of the running physics systems.\nPhaser supports 4 physics systems: Arcade Physics, P2, Ninja Physics and Box2D via a commercial plugin.\n\nGame Objects (such as Sprites) can only belong to 1 physics system, but you can have multiple systems active in a single game.\n\nFor example you could have P2 managing a polygon-built terrain landscape that an vehicle drives over, while it could be firing bullets that use the\nfaster (due to being much simpler) Arcade Physics system.",
      "NINJA": "+Number",
      "BOX2D": "+Number",
      "!type": "fn(game: +Phaser.Game, physicsConfig: +Object)",
      "MATTERJS": "+Number",
      "ARCADE": "+Number",
      "CHIPMUNK": "+Number",
      "prototype": {
        "game": {
          "!doc": "Local reference to game.",
          "!type": "+Phaser.Game"
        },
        "p2": {
          "!doc": "The P2.JS Physics system.",
          "!type": "+Phaser.Physics.P2"
        },
        "box2d": {
          "!doc": "The Box2D Physics system.",
          "!type": "+Phaser.Physics.Box2D"
        },
        "clear": {
          "!doc": "Clears down all active physics systems. This doesn't destroy them, it just clears them of objects and is called when the State changes.",
          "!type": "fn()"
        },
        "update": {
          "!doc": "Updates all running physics systems.",
          "!type": "fn()"
        },
        "parseConfig": {
          "!doc": "Parses the Physics Configuration object passed to the Game constructor and starts any physics systems specified within.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Destroys all active physics systems. Usually only called on a Game Shutdown, not on a State swap.",
          "!type": "fn()"
        },
        "arcade": {
          "!doc": "The Arcade Physics system.",
          "!type": "+Phaser.Physics.Arcade"
        },
        "matter": {
          "!doc": "The MatterJS Physics system (coming soon).",
          "!type": "+Phaser.Physics.Matter"
        },
        "setBoundsToWorld": {
          "!doc": "Sets the bounds of the Physics world to match the Game.World dimensions.\nYou can optionally set which 'walls' to create: left, right, top or bottom.",
          "!type": "fn(left: +Boolean, right: +Boolean, top: +Boolean, bottom: +Boolean, setCollisionGroup: +Boolean)"
        },
        "ninja": {
          "!doc": "The N+ Ninja Physics system.",
          "!type": "+Phaser.Physics.Ninja"
        },
        "enable": {
          "!doc": "This will create a default physics body on the given game object or array of objects.\nA game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\nIt can be for any of the physics systems that have been started:\n\nPhaser.Physics.Arcade - A light weight AABB based collision system with basic separation.\nPhaser.Physics.P2JS - A full-body advanced physics system supporting multiple object shapes, polygon loading, contact materials, springs and constraints.\nPhaser.Physics.NINJA - A port of Metanet Softwares N+ physics system. Advanced AABB and Circle vs. Tile collision.\nPhaser.Physics.BOX2D - A port of https://code.google.com/p/box2d-html5\nPhaser.Physics.MATTER - A full-body and light-weight advanced physics system (still in development)\nPhaser.Physics.CHIPMUNK is still in development.\n\nIf you require more control over what type of body is created, for example to create a Ninja Physics Circle instead of the default AABB, then see the\nindividual physics systems `enable` methods instead of using this generic one.",
          "!type": "fn(object: +Object, system: +Number, debug: +Boolean)"
        },
        "setWorldMaterial": {
          "!doc": "Sets the given material against the 4 bounds of this World.",
          "!type": "fn(material: +Phaser.Physics.P2.Material, left: +Boolean, right: +Boolean, top: +Boolean, bottom: +Boolean)"
        },
        "chipmunk": {
          "!doc": "The Chipmunk Physics system (to be done).",
          "!type": "+Phaser.Physics.Chipmunk"
        },
        "reset": {
          "!doc": "Resets the active physics system. Called automatically on a Phaser.State swap.",
          "!type": "fn()"
        },
        "startSystem": {
          "!doc": "This will create an instance of the requested physics simulation.\nPhaser.Physics.Arcade is running by default, but all others need activating directly.\n\nYou can start the following physics systems:\n\nPhaser.Physics.P2JS - A full-body advanced physics system by Stefan Hedman.\nPhaser.Physics.NINJA - A port of Metanet Softwares N+ physics system.\nPhaser.Physics.BOX2D - A commercial Phaser Plugin (see http://phaser.io)\n\nBoth Ninja Physics and Box2D require their respective plugins to be loaded before you can start them.\nThey are not bundled into the core Phaser library.\n\nIf the physics world has already been created (i.e. in another state in your game) then \ncalling startSystem will reset the physics world, not re-create it. If you need to start them again from their constructors \nthen set Phaser.Physics.p2 (or whichever system you want to recreate) to `null` before calling `startSystem`.",
          "!type": "fn(system: +Number)"
        },
        "preUpdate": {
          "!doc": "preUpdate checks.",
          "!type": "fn()"
        },
        "config": {
          "!doc": "The physics configuration object as passed to the game on creation.",
          "!type": "+Object"
        }
      },
      "P2JS": "+Number",
      "Arcade": {
        "TOP_BOTTOM": "+Number",
        "BOTTOM_TOP": "+Number",
        "TilemapCollision": {
          "!doc": "The Arcade Physics Tile map collision methods.",
          "!type": "fn()",
          "prototype": {"TILE_BIAS": {
            "!doc": "A value added to the delta values during collision with tiles. Adjust this if you get tunneling.",
            "!type": "+Number"
          }}
        },
        "!doc": "The Arcade Physics world. Contains Arcade Physics related collision, overlap and motion methods.",
        "RIGHT_LEFT": "+Number",
        "SORT_NONE": "+Number",
        "LEFT_RIGHT": "+Number",
        "!type": "fn(game: +Phaser.Game)",
        "Body": {
          "!doc": "The Physics Body is linked to a single Sprite. All physics operations should be performed against the body rather than\nthe Sprite itself. For example you can set the velocity, acceleration, bounce values etc all on the Body.",
          "!type": "fn(sprite: +Phaser.Sprite)",
          "prototype": {
            "angularDrag": {
              "!doc": "The drag applied during the rotation of the Body.",
              "!type": "+Number"
            },
            "newVelocity": {
              "!doc": "The new velocity. Calculated during the Body.preUpdate and applied to its position.",
              "!type": "+Phaser.Point"
            },
            "bounce": {
              "!doc": "The elasticity of the Body when colliding. bounce.x/y = 1 means full rebound, bounce.x/y = 0.5 means 50% rebound velocity.",
              "!type": "+Phaser.Point"
            },
            "prev": {
              "!doc": "The previous position of the physics body.",
              "!type": "+Phaser.Point"
            },
            "type": {
              "!doc": "The type of physics system this body belongs to.",
              "!type": "+Number"
            },
            "acceleration": {
              "!doc": "The acceleration is the rate of change of the velocity. Measured in pixels per second squared.",
              "!type": "+Phaser.Point"
            },
            "angularAcceleration": {
              "!doc": "The angular acceleration is the rate of change of the angular velocity. Measured in radians per second squared.",
              "!type": "+Number"
            },
            "maxAngular": {
              "!doc": "The maximum angular velocity in radians per second that the Body can reach.",
              "!type": "+Number"
            },
            "sourceWidth": {
              "!doc": "The un-scaled original size.",
              "!type": "+Number"
            },
            "enable": {
              "!doc": "A disabled body won't be checked for any form of collision or overlap or have its pre/post updates run.",
              "!type": "+Boolean"
            },
            "halfWidth": {
              "!doc": "The calculated width / 2 of the physics body.",
              "!type": "+Number"
            },
            "collideWorldBounds": {
              "!doc": "Should the Body collide with the World bounds?",
              "!type": "+Boolean"
            },
            "drag": {
              "!doc": "The drag applied to the motion of the Body.",
              "!type": "+Phaser.Point"
            },
            "tilePadding": {
              "!doc": "Extra padding to be added to this sprite's dimensions when checking for tile collision.",
              "!type": "+Phaser.Point"
            },
            "customSeparateY": {
              "!doc": "Use a custom separation system or the built-in one?",
              "!type": "+Boolean"
            },
            "height": {
              "!doc": "The calculated height of the physics body.",
              "!type": "+Number"
            },
            "customSeparateX": {
              "!doc": "Use a custom separation system or the built-in one?",
              "!type": "+Boolean"
            },
            "syncBounds": {
              "!doc": "If true the Body will check itself against the Sprite.getBounds() dimensions and adjust its width and height accordingly.\nIf false it will compare its dimensions against the Sprite scale instead, and adjust its width height if the scale has changed.\nTypically you would need to enable syncBounds if your sprite is the child of a responsive display object such as a FlexLayer, \nor in any situation where the Sprite scale doesn't change, but its parents scale is effecting the dimensions regardless.",
              "!type": "+Boolean"
            },
            "offset": {
              "!doc": "The offset of the Physics Body from the Sprite x/y position.",
              "!type": "+Phaser.Point"
            },
            "checkCollision": {
              "!doc": "An object containing allowed collision.",
              "!type": "+Object"
            },
            "postUpdate": {
              "!doc": "Internal method.",
              "!type": "fn()"
            },
            "halfHeight": {
              "!doc": "The calculated height / 2 of the physics body.",
              "!type": "+Number"
            },
            "bottom": {
              "!doc": "The bottom value of this Body (same as Body.y + Body.height)",
              "!type": "+Number"
            },
            "destroy": {
              "!doc": "Destroys this Body.\n\nFirst it calls Group.removeFromHash if the Game Object this Body belongs to is part of a Group.\nThen it nulls the Game Objects body reference, and nulls this Body.sprite reference.",
              "!type": "fn()"
            },
            "sourceHeight": {
              "!doc": "The un-scaled original size.",
              "!type": "+Number"
            },
            "deltaMax": {
              "!doc": "The Sprite position is updated based on the delta x/y values. You can set a cap on those (both +-) using deltaMax.",
              "!type": "+Phaser.Point"
            },
            "wasTouching": {
              "!doc": "An object containing previous touching results.",
              "!type": "+Object"
            },
            "left": {
              "!doc": "The x position of the Body. The same as `Body.x`.",
              "!type": "+Number"
            },
            "reset": {
              "!doc": "Resets all Body values (velocity, acceleration, rotation, etc)",
              "!type": "fn(x: +Number, y: +Number)"
            },
            "maxVelocity": {
              "!doc": "The maximum velocity in pixels per second sq. that the Body can reach.",
              "!type": "+Phaser.Point"
            },
            "position": {
              "!doc": "The position of the physics body.",
              "!type": "+Phaser.Point"
            },
            "preUpdate": {
              "!doc": "Internal method.",
              "!type": "fn()"
            },
            "skipQuadTree": {
              "!doc": "If true and you collide this Sprite against a Group, it will disable the collision check from using a QuadTree.",
              "!type": "+Boolean"
            },
            "game": {
              "!doc": "Local reference to game.",
              "!type": "+Phaser.Game"
            },
            "renderBodyInfo": {
              "!doc": "Render Sprite Body Physics Data as text.",
              "!type": "fn(body: +Phaser.Physics.Arcade.Body, x: +Number, y: +Number, color: +String)"
            },
            "deltaZ": {
              "!doc": "Returns the delta z value. The difference between Body.rotation now and in the previous step.",
              "!type": "fn() -> +Number"
            },
            "immovable": {
              "!doc": "An immovable Body will not receive any impacts from other bodies.",
              "!type": "+Boolean"
            },
            "deltaX": {
              "!doc": "Returns the delta x value. The difference between Body.x now and in the previous step.",
              "!type": "fn() -> +Number"
            },
            "deltaY": {
              "!doc": "Returns the delta y value. The difference between Body.y now and in the previous step.",
              "!type": "fn() -> +Number"
            },
            "mass": {
              "!doc": "The mass of the Body. When two bodies collide their mass is used in the calculation to determine the exchange of velocity.",
              "!type": "+Number"
            },
            "facing": {
              "!doc": "A const reference to the direction the Body is traveling or facing.",
              "!type": "+Number"
            },
            "allowRotation": {
              "!doc": "Allow this Body to be rotated? (via angularVelocity, etc)",
              "!type": "+Boolean"
            },
            "allowGravity": {
              "!doc": "Allow this Body to be influenced by gravity? Either world or local.",
              "!type": "+Boolean"
            },
            "speed": {
              "!doc": "The speed of the Body as calculated by its velocity.",
              "!type": "+Number"
            },
            "setSize": {
              "!doc": "You can modify the size of the physics Body to be any dimension you need.\nSo it could be smaller or larger than the parent Sprite. You can also control the x and y offset, which\nis the position of the Body relative to the top-left of the Sprite.\n\nCalling `setSize` will have no effect if you have previously used `Body.setCircle`. To change a collision\ncircle use `setCircle` instead.",
              "!type": "fn(width: +Number, height: +Number, offsetX: +Number, offsetY: +Number)"
            },
            "blocked": {
              "!doc": "An object containing on which faces this Body is blocked from moving, if any.",
              "!type": "+Object"
            },
            "top": {
              "!doc": "The y position of the Body. The same as `Body.y`.",
              "!type": "+Number"
            },
            "sprite": {
              "!doc": "Reference to the parent Sprite.",
              "!type": "+Phaser.Sprite"
            },
            "angle": {
              "!doc": "The angle of the Body in radians, as calculated by its angularVelocity.",
              "!type": "+Number"
            },
            "checkWorldBounds": {
              "!doc": "Internal method.",
              "!type": "fn()"
            },
            "onCeiling": {
              "!doc": "Returns true if the top of this Body is in contact with either the world bounds or a tile.",
              "!type": "fn() -> +Boolean"
            },
            "render": {
              "!doc": "Render Sprite Body.",
              "!type": "fn(context: +Object, body: +Phaser.Physics.Arcade.Body, color: +String, filled: +Boolean)"
            },
            "embedded": {
              "!doc": "Body embed value.",
              "!type": "+Boolean"
            },
            "dirty": {
              "!doc": "If this Body in a preUpdate (true) or postUpdate (false) state?",
              "!type": "+Boolean"
            },
            "deltaAbsY": {
              "!doc": "Returns the absolute delta y value.",
              "!type": "fn() -> +Number"
            },
            "deltaAbsX": {
              "!doc": "Returns the absolute delta x value.",
              "!type": "fn() -> +Number"
            },
            "overlapX": {
              "!doc": "The amount of horizontal overlap during the collision.",
              "!type": "+Number"
            },
            "touching": {
              "!doc": "An object containing touching results.",
              "!type": "+Object"
            },
            "overlapY": {
              "!doc": "The amount of vertical overlap during the collision.",
              "!type": "+Number"
            },
            "rotation": {
              "!doc": "An Arcade Physics Body can have angularVelocity and angularAcceleration. Please understand that the collision Body\nitself never rotates, it is always axis-aligned. However these values are passed up to the parent Sprite and updates its rotation.",
              "!type": "+Number"
            },
            "center": {
              "!doc": "The center coordinate of the Physics Body.",
              "!type": "+Phaser.Point"
            },
            "onWall": {
              "!doc": "Returns true if either side of this Body is in contact with either the world bounds or a tile.",
              "!type": "fn() -> +Boolean"
            },
            "setCircle": {
              "!doc": "Sets this Body as using a circle, of the given radius, for all collision detection instead of a rectangle.\nThe radius is given in pixels and is the distance from the center of the circle to the edge.\n\nYou can also control the x and y offset, which is the position of the Body relative to the top-left of the Sprite.",
              "!type": "fn(radius: +Number, offsetX: +Number, offsetY: +Number)"
            },
            "velocity": {
              "!doc": "The velocity, or rate of change in speed of the Body. Measured in pixels per second.",
              "!type": "+Phaser.Point"
            },
            "right": {
              "!doc": "The right value of this Body (same as Body.x + Body.width)",
              "!type": "+Number"
            },
            "friction": {
              "!doc": "The amount of movement that will occur if another object 'rides' this one.",
              "!type": "+Phaser.Point"
            },
            "angularVelocity": {
              "!doc": "The angular velocity controls the rotation speed of the Body. It is measured in radians per second.",
              "!type": "+Number"
            },
            "updateBounds": {
              "!doc": "Internal method.",
              "!type": "fn()"
            },
            "preRotation": {
              "!doc": "The previous rotation of the physics body.",
              "!type": "+Number"
            },
            "gravity": {
              "!doc": "A local gravity applied to this Body. If non-zero this over rides any world gravity, unless Body.allowGravity is set to false.",
              "!type": "+Phaser.Point"
            },
            "moves": {
              "!doc": "Set to true to allow the Physics system to move this Body, otherwise false to move it manually.",
              "!type": "+Boolean"
            },
            "onFloor": {
              "!doc": "Returns true if the bottom of this Body is in contact with either the world bounds or a tile.",
              "!type": "fn() -> +Boolean"
            },
            "width": {
              "!doc": "The calculated width of the physics body.",
              "!type": "+Number"
            },
            "x": {
              "!doc": "The x position.",
              "!type": "+Number"
            },
            "y": {
              "!doc": "The y position.",
              "!type": "+Number"
            },
            "hitTest": {
              "!doc": "Tests if a world point lies within this Body.",
              "!type": "fn(x: +Number, y: +Number) -> +Boolean"
            }
          }
        },
        "prototype": {
          "getObjectsAtLocation": {
            "!doc": "Given a Group and a location this will check to see which Group children overlap with the coordinates.\nEach child will be sent to the given callback for further processing.\nNote that the children are not checked for depth order, but simply if they overlap the coordinate or not.",
            "!type": "fn(x: +Number, y: +Number, group: +Phaser.Group, callback: +Function, callbackContext: +Object, callbackArg: +Object) -> +Array._PIXI.DisplayObject_"
          },
          "game": {
            "!doc": "Local reference to game.",
            "!type": "+Phaser.Game"
          },
          "intersects": {
            "!doc": "Check for intersection against two bodies.",
            "!type": "fn(body1: +Phaser.Physics.Arcade.Body, body2: +Phaser.Physics.Arcade.Body) -> +Boolean"
          },
          "getOverlapY": {
            "!doc": "Calculates the vertical overlap between two Bodies and sets their properties accordingly, including:\n`touching.up`, `touching.down` and `overlapY`.",
            "!type": "fn(body1: +Phaser.Physics.Arcade.Body, body2: +Phaser.Physics.Arcade.Body) -> +float"
          },
          "distanceBetween": {
            "!doc": "Find the distance between two display objects (like Sprites).",
            "!type": "fn(source: +Object, target: +Object) -> +Number"
          },
          "quadTree": {
            "!doc": "The world QuadTree.",
            "!type": "+Phaser.QuadTree"
          },
          "getOverlapX": {
            "!doc": "Calculates the horizontal overlap between two Bodies and sets their properties accordingly, including:\n`touching.left`, `touching.right` and `overlapX`.",
            "!type": "fn(body1: +Phaser.Physics.Arcade.Body, body2: +Phaser.Physics.Arcade.Body) -> +float"
          },
          "moveToObject": {
            "!doc": "Move the given display object towards the destination object at a steady velocity.\nIf you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\nTimings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\nNote: The display object doesn't stop moving once it reaches the destination coordinates.\nNote: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)",
            "!type": "fn(displayObject: +Object, destination: +Object, speed: +Number, maxTime: +Number) -> +Number"
          },
          "distanceToXY": {
            "!doc": "Find the distance between a display object (like a Sprite) and the given x/y coordinates.\nThe calculation is made from the display objects x/y coordinate. This may be the top-left if its anchor hasn't been changed.\nIf you need to calculate from the center of a display object instead use the method distanceBetweenCenters()",
            "!type": "fn(displayObject: +Object, x: +Number, y: +Number) -> +Number"
          },
          "getObjectsUnderPointer": {
            "!doc": "Given a Group and a Pointer this will check to see which Group children overlap with the Pointer coordinates.\nEach child will be sent to the given callback for further processing.\nNote that the children are not checked for depth order, but simply if they overlap the Pointer or not.",
            "!type": "fn(pointer: +Phaser.Pointer, group: +Phaser.Group, callback: +Function, callbackContext: +Object) -> +Array._PIXI.DisplayObject_"
          },
          "accelerateToObject": {
            "!doc": "Sets the acceleration.x/y property on the display object so it will move towards the target at the given speed (in pixels per second sq.)\nYou must give a maximum speed value, beyond which the display object won't go any faster.\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\nNote: The display object doesn't stop moving once it reaches the destination coordinates.",
            "!type": "fn(displayObject: +Object, destination: +Object, speed: +Number, xSpeedMax: +Number, ySpeedMax: +Number) -> +Number"
          },
          "angleBetween": {
            "!doc": "Find the angle in radians between two display objects (like Sprites).",
            "!type": "fn(source: +Object, target: +Object) -> +Number"
          },
          "computeVelocity": {
            "!doc": "A tween-like function that takes a starting velocity and some other factors and returns an altered velocity.\nBased on a function in Flixel by @ADAMATOMIC",
            "!type": "fn(axis: +Number, body: +Phaser.Physics.Arcade.Body, velocity: +Number, acceleration: +Number, drag: +Number, max: +Number) -> +Number"
          },
          "moveToPointer": {
            "!doc": "Move the given display object towards the pointer at a steady velocity. If no pointer is given it will use Phaser.Input.activePointer.\nIf you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\nTimings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\nNote: The display object doesn't stop moving once it reaches the destination coordinates.",
            "!type": "fn(displayObject: +Object, speed: +Number, pointer: +Phaser.Pointer, maxTime: +Number) -> +Number"
          },
          "forceX": {
            "!doc": "If true World.separate will always separate on the X axis before Y. Otherwise it will check gravity totals first.",
            "!type": "+Boolean"
          },
          "sortDirection": {
            "!doc": "Used when colliding a Sprite vs. a Group, or a Group vs. a Group, this defines the direction the sort is based on. Default is Phaser.Physics.Arcade.LEFT_RIGHT.",
            "!type": "+Number"
          },
          "enableBody": {
            "!doc": "Creates an Arcade Physics body on the given game object.\n\nA game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.\n\nWhen you add an Arcade Physics body to an object it will automatically add the object into its parent Groups hash array.",
            "!type": "fn(object: +Object)"
          },
          "enable": {
            "!doc": "This will create an Arcade Physics body on the given game object or array of game objects.\nA game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.",
            "!type": "fn(object: +Object, children: +Boolean)"
          },
          "OVERLAP_BIAS": {
            "!doc": "A value added to the delta values during collision checks.",
            "!type": "+Number"
          },
          "angleToPointer": {
            "!doc": "Find the angle in radians between a display object (like a Sprite) and a Pointer, taking their x/y and center into account.",
            "!type": "fn(displayObject: +Object, pointer: +Phaser.Pointer) -> +Number"
          },
          "sortLeftRight": {
            "!doc": "A Sort function for sorting two bodies based on a LEFT to RIGHT sort direction.\n\nThis is called automatically by World.sort",
            "!type": "fn(a: +Phaser.Sprite, b: +Phaser.Sprite) -> +Number"
          },
          "maxObjects": {
            "!doc": "Used by the QuadTree to set the maximum number of objects per quad.",
            "!type": "+Number"
          },
          "accelerateToPointer": {
            "!doc": "Sets the acceleration.x/y property on the display object so it will move towards the target at the given speed (in pixels per second sq.)\nYou must give a maximum speed value, beyond which the display object won't go any faster.\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\nNote: The display object doesn't stop moving once it reaches the destination coordinates.",
            "!type": "fn(displayObject: +Object, pointer: +Phaser.Pointer, speed: +Number, xSpeedMax: +Number, ySpeedMax: +Number) -> +Number"
          },
          "distanceToPointer": {
            "!doc": "Find the distance between a display object (like a Sprite) and a Pointer. If no Pointer is given the Input.activePointer is used.\nThe calculation is made from the display objects x/y coordinate. This may be the top-left if its anchor hasn't been changed.\nIf you need to calculate from the center of a display object instead use the method distanceBetweenCenters()\nThe distance to the Pointer is returned in screen space, not world space.",
            "!type": "fn(displayObject: +Object, pointer: +Phaser.Pointer) -> +Number"
          },
          "isPaused": {
            "!doc": "If `true` the `Body.preUpdate` method will be skipped, halting all motion for all bodies. Note that other methods such as `collide` will still work, so be careful not to call them on paused bodies.",
            "!type": "+Boolean"
          },
          "checkCollision": {
            "!doc": "An object containing allowed collision flags.",
            "!type": "+Object"
          },
          "maxLevels": {
            "!doc": "Used by the QuadTree to set the maximum number of iteration levels.",
            "!type": "+Number"
          },
          "sortTopBottom": {
            "!doc": "A Sort function for sorting two bodies based on a TOP to BOTTOM sort direction.\n\nThis is called automatically by World.sort",
            "!type": "fn(a: +Phaser.Sprite, b: +Phaser.Sprite) -> +Number"
          },
          "velocityFromAngle": {
            "!doc": "Given the angle (in degrees) and speed calculate the velocity and return it as a Point object, or set it to the given point object.\nOne way to use this is: velocityFromAngle(angle, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.",
            "!type": "fn(angle: +Number, speed: +Number, point: +Phaser.Point) -> +Phaser.Point"
          },
          "collide": {
            "!doc": "Checks for collision between two game objects. You can perform Sprite vs. Sprite, Sprite vs. Group, Group vs. Group, Sprite vs. Tilemap Layer or Group vs. Tilemap Layer collisions.\nBoth the first and second parameter can be arrays of objects, of differing types.\nIf two arrays are passed, the contents of the first parameter will be tested against all contents of the 2nd parameter.\nThe objects are also automatically separated. If you don't require separation then use ArcadePhysics.overlap instead.\nAn optional processCallback can be provided. If given this function will be called when two sprites are found to be colliding. It is called before any separation takes place,\ngiving you the chance to perform additional checks. If the function returns true then the collision and separation is carried out. If it returns false it is skipped.\nThe collideCallback is an optional function that is only called if two sprites collide. If a processCallback has been set then it needs to return true for collideCallback to be called.\nNOTE: This function is not recursive, and will not test against children of objects passed (i.e. Groups or Tilemaps within other Groups).",
            "!type": "fn(object1: +Phaser.Sprite, object2: +Phaser.Sprite, collideCallback: +Function, processCallback: +Function, callbackContext: +Object) -> +Boolean"
          },
          "sort": {
            "!doc": "This method will sort a Groups hash array.\n\nIf the Group has `physicsSortDirection` set it will use the sort direction defined.\n\nOtherwise if the sortDirection parameter is undefined, or Group.physicsSortDirection is null, it will use Phaser.Physics.Arcade.sortDirection.\n\nBy changing Group.physicsSortDirection you can customise each Group to sort in a different order.",
            "!type": "fn(group: +Phaser.Group, sortDirection: +Number)"
          },
          "moveToXY": {
            "!doc": "Move the given display object towards the x/y coordinates at a steady velocity.\nIf you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\nTimings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\nNote: The display object doesn't stop moving once it reaches the destination coordinates.\nNote: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)",
            "!type": "fn(displayObject: +Object, x: +Number, y: +Number, speed: +Number, maxTime: +Number) -> +Number"
          },
          "sortRightLeft": {
            "!doc": "A Sort function for sorting two bodies based on a RIGHT to LEFT sort direction.\n\nThis is called automatically by World.sort",
            "!type": "fn(a: +Phaser.Sprite, b: +Phaser.Sprite) -> +Number"
          },
          "updateMotion": {
            "!doc": "Called automatically by a Physics body, it updates all motion related values on the Body unless `World.isPaused` is `true`.",
            "!type": "fn(The: +Phaser.Physics.Arcade.Body)"
          },
          "setBounds": {
            "!doc": "Updates the size of this physics world.",
            "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number)"
          },
          "setBoundsToWorld": {
            "!doc": "Updates the size of this physics world to match the size of the game world.",
            "!type": "fn()"
          },
          "sortBottomTop": {
            "!doc": "A Sort function for sorting two bodies based on a BOTTOM to TOP sort direction.\n\nThis is called automatically by World.sort",
            "!type": "fn(a: +Phaser.Sprite, b: +Phaser.Sprite) -> +Number"
          },
          "accelerateToXY": {
            "!doc": "Sets the acceleration.x/y property on the display object so it will move towards the x/y coordinates at the given speed (in pixels per second sq.)\nYou must give a maximum speed value, beyond which the display object won't go any faster.\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\nNote: The display object doesn't stop moving once it reaches the destination coordinates.",
            "!type": "fn(displayObject: +Object, x: +Number, y: +Number, speed: +Number, xSpeedMax: +Number, ySpeedMax: +Number) -> +Number"
          },
          "overlap": {
            "!doc": "Checks for overlaps between two game objects. The objects can be Sprites, Groups or Emitters.\nYou can perform Sprite vs. Sprite, Sprite vs. Group and Group vs. Group overlap checks.\nUnlike collide the objects are NOT automatically separated or have any physics applied, they merely test for overlap results.\nBoth the first and second parameter can be arrays of objects, of differing types.\nIf two arrays are passed, the contents of the first parameter will be tested against all contents of the 2nd parameter.\nNOTE: This function is not recursive, and will not test against children of objects passed (i.e. Groups within Groups).",
            "!type": "fn(object1: +Phaser.Sprite, object2: +Phaser.Sprite, overlapCallback: +Function, processCallback: +Function, callbackContext: +Object) -> +Boolean"
          },
          "worldAngleToPointer": {
            "!doc": "Find the angle in radians between a display object (like a Sprite) and a Pointer, \ntaking their x/y and center into account relative to the world.",
            "!type": "fn(displayObject: +Object, pointer: +Phaser.Pointer) -> +Number"
          },
          "gravity": {
            "!doc": "The World gravity setting. Defaults to x: 0, y: 0, or no gravity.",
            "!type": "+Phaser.Point"
          },
          "velocityFromRotation": {
            "!doc": "Given the rotation (in radians) and speed calculate the velocity and return it as a Point object, or set it to the given point object.\nOne way to use this is: velocityFromRotation(rotation, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.",
            "!type": "fn(rotation: +Number, speed: +Number, point: +Phaser.Point) -> +Phaser.Point"
          },
          "accelerationFromRotation": {
            "!doc": "Given the rotation (in radians) and speed calculate the acceleration and return it as a Point object, or set it to the given point object.\nOne way to use this is: accelerationFromRotation(rotation, 200, sprite.acceleration) which will set the values directly to the sprites acceleration and not create a new Point object.",
            "!type": "fn(rotation: +Number, speed: +Number, point: +Phaser.Point) -> +Phaser.Point"
          },
          "bounds": {
            "!doc": "The bounds inside of which the physics world exists. Defaults to match the world bounds.",
            "!type": "+Phaser.Rectangle"
          },
          "angleToXY": {
            "!doc": "Find the angle in radians between a display object (like a Sprite) and the given x/y coordinate.",
            "!type": "fn(displayObject: +Object, x: +Number, y: +Number) -> +Number"
          },
          "skipQuadTree": {
            "!doc": "If true the QuadTree will not be used for any collision. QuadTrees are great if objects are well spread out in your game, otherwise they are a performance hit. If you enable this you can disable on a per body basis via `Body.skipQuadTree`.",
            "!type": "+Boolean"
          }
        }
      }
    },
    "Graphics": {
      "init": {
        "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
        "!type": "fn()"
      },
      "install": {
        "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
        "!type": "fn()"
      },
      "!doc": "Creates a new `Graphics` object.",
      "!type": "fn(game: +Phaser.Game, x: +Number, y: +Number)",
      "prototype": {
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "components": {
          "!doc": "The components this Game Object has installed.",
          "!type": "+Object"
        },
        "alive": {
          "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
          "!type": "+Boolean"
        },
        "lifespan": {
          "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
          "!type": "+Number"
        },
        "outOfBoundsKill": {
          "!doc": "If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.",
          "!type": "+Boolean"
        },
        "update": {
          "!doc": "Override this method in your own custom objects to handle any update requirements.\nIt is called immediately after `preUpdate` and before `postUpdate`.\nRemember if this Game Object has any children you should call update on those too.",
          "!type": "fn()"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "body": {
          "!doc": "`body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated \nproperties and methods via it.\n\nBy default Game Objects won't add themselves to any physics system and their `body` property will be `null`.\n\nTo enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object\nand `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.\n\nYou can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.\n\nImportant: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5, \nso the physics body is centered on the Game Object.\n\nIf you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.",
          "!type": "+Phaser.Physics.Arcade.Body"
        },
        "inWorld": {
          "!doc": "Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.",
          "!type": "+Boolean"
        },
        "inCamera": {
          "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
          "!type": "+Boolean"
        },
        "inputEnabled": {
          "!doc": "By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created\nfor this Game Object and it will then start to process click / touch events and more.\n\nYou can then access the Input Handler via `this.input`.\n\nNote that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.\n\nIf you set this property to false it will stop the Input Handler from processing any more input events.",
          "!type": "+Boolean"
        },
        "offsetX": {
          "!doc": "The amount the Game Object is visually offset from its x coordinate.\nThis is the same as `width * anchor.x`.\nIt will only be > 0 if anchor.x is not equal to zero.",
          "!type": "+Number"
        },
        "offsetY": {
          "!doc": "The amount the Game Object is visually offset from its y coordinate.\nThis is the same as `height * anchor.y`.\nIt will only be > 0 if anchor.y is not equal to zero.",
          "!type": "+Number"
        },
        "world": {
          "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
          "!type": "+Phaser.Point"
        },
        "top": {
          "!doc": "The y coordinate of the Game Object.\nThis is the same as `y - offsetY`.",
          "!type": "+Number"
        },
        "animations": {
          "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
          "!type": "+Phaser.AnimationManager"
        },
        "angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        },
        "revive": {
          "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
          "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
        },
        "fixedToCamera": {
          "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
          "!type": "+Boolean"
        },
        "renderOrderID": {
          "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
          "!type": "+Number"
        },
        "checkWorldBounds": {
          "!doc": "If this is set to `true` the Game Object checks if it is within the World bounds each frame. \n\nWhen it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.\n\nIf it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.\n\nIt also optionally kills the Game Object if `outOfBoundsKill` is `true`.\n\nWhen `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "events": {
          "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
          "!type": "+Phaser.Events"
        },
        "key": {
          "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
          "!type": "+String"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "previousRotation": {
          "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
          "!type": "+Number"
        },
        "debug": {
          "!doc": "A debug flag designed for use with `Game.enableStep`.",
          "!type": "+Boolean"
        },
        "postUpdate": {
          "!doc": "Internal method called by the World postUpdate cycle.",
          "!type": "fn()"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.\nThis is the same as `y + height - offsetY`.",
          "!type": "+Number"
        },
        "cameraOffset": {
          "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
          "!type": "+Phaser.Point"
        },
        "destroy": {
          "!doc": "Destroy this Graphics instance.",
          "!type": "fn(destroyChildren: +Boolean)"
        },
        "outOfCameraBoundsKill": {
          "!doc": "If this and the `autoCull` property are both set to `true`, then the `kill` method\nis called as soon as the Game Object leaves the camera bounds.",
          "!type": "+Boolean"
        },
        "destroyPhase": {
          "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
          "!type": "+Boolean"
        },
        "right": {
          "!doc": "The right coordinate of the Game Object.\nThis is the same as `x + width - offsetX`.",
          "!type": "+Number"
        },
        "kill": {
          "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousPosition": {
          "!doc": "The position the Game Object was located in the previous frame.",
          "!type": "+Phaser.Point"
        },
        "input": {
          "!doc": "The Input Handler for this Game Object.\n\nBy default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.\n\nAfter you have done this, this property will be a reference to the Phaser InputHandler.",
          "!type": "+Phaser.InputHandler"
        },
        "pendingDestroy": {
          "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
          "!type": "+Boolean"
        },
        "left": {
          "!doc": "The left coordinate of the Game Object.\nThis is the same as `x - offsetX`.",
          "!type": "+Number"
        },
        "name": {
          "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
          "!type": "+String"
        },
        "autoCull": {
          "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The position of the Game Object on the x axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "reset": {
          "!doc": "Resets the Game Object.\n\nThis moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`, \n`visible` and `renderable` to true.\n\nIf this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.\n\nIf this Game Object has a Physics Body it will reset the Body.",
          "!type": "fn(x: +Number, y: +Number, health: +Number) -> +PIXI.DisplayObject"
        },
        "exists": {
          "!doc": "Controls if this Game Object is processed by the core game loop.\nIf this Game Object has a physics body it also controls if its physics body is updated or not.\nWhen `exists` is set to `false` it will remove its physics body from the physics world if it has one.\nIt also toggles the `visible` property to false as well.\n\nSetting `exists` to true will add its physics body back in to the physics world, if it has one.\nIt will also set the `visible` property to `true`.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The position of the Game Object on the y axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
          "!type": "+Number"
        },
        "fresh": {
          "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
          "!type": "+Boolean"
        },
        "preUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn()"
        }
      }
    },
    "Utils": {
      "extend": {
        "!doc": "This is a slightly modified version of http://api.jquery.com/jQuery.extend/",
        "!type": "fn(deep: +Boolean, target: +Object) -> +Object"
      },
      "mixin": {
        "!doc": "Mixes the source object into the destination object, returning the newly modified destination object.\nBased on original code by @mudcube",
        "!type": "fn(from: +Object, to: +Object) -> +Object"
      },
      "pad": {
        "!doc": "JavaScript string pad http://www.webtoolkit.info/.",
        "!type": "fn(str: +String, len: +Number, pad: +String, dir: +Number) -> +String"
      },
      "getProperty": {
        "!doc": "Gets an objects property by string.",
        "!type": "fn(obj: +Object, prop: +String) -> +any"
      },
      "isPlainObject": {
        "!doc": "This is a slightly modified version of jQuery.isPlainObject.\nA plain object is an object whose internal class property is [object Object].",
        "!type": "fn(obj: +Object) -> +Boolean"
      },
      "!doc": "",
      "setProperty": {
        "!doc": "Sets an objects property by string.",
        "!type": "fn(obj: +Object, prop: +String) -> +Object"
      },
      "!type": "fn()",
      "prototype": {
        "chanceRoll": {
          "!doc": "Generate a random bool result based on the chance value.\n\nReturns true or false based on the chance value (default 50%). For example if you wanted a player to have a 30% chance\nof getting a bonus, call chanceRoll(30) - true means the chance passed, false means it failed.",
          "!type": "fn(chance: +Number) -> +Boolean"
        },
        "randomChoice": {
          "!doc": "Choose between one of two values randomly.",
          "!type": "fn(choice1: +Object, choice2: +Object) -> +Object"
        }
      },
      "Debug": {
        "!doc": "A collection of methods for displaying debug information about game objects.\nIf your game is running in WebGL then Debug will create a Sprite that is placed at the top of the Stage display list and bind a canvas texture\nto it, which must be uploaded every frame. Be advised: this is very expensive, especially in browsers like Firefox. So please only enable Debug\nin WebGL mode if you really need it (or your desktop can cope with it well) and disable it for production!\nIf your game is using a Canvas renderer then the debug information is literally drawn on the top of the active game canvas and no Sprite is used.",
        "!type": "fn(game: +Phaser.Game)",
        "prototype": {
          "ropeSegments": {
            "!doc": "Renders the Rope's segments. Note: This is really expensive as it has to calculate new segments every time you call it",
            "!type": "fn(rope: +Phaser.Rope, color: +String, filled: +Boolean)"
          },
          "game": {
            "!doc": "A reference to the currently running Game.",
            "!type": "+Phaser.Game"
          },
          "line": {
            "!doc": "Internal method that outputs a single line of text split over as many columns as needed, one per parameter.",
            "!type": "fn()"
          },
          "currentAlpha": {
            "!doc": "The alpha of the Debug context, set before all debug information is rendered to it.",
            "!type": "+Number"
          },
          "spriteInputInfo": {
            "!doc": "Render Sprite Input Debug information.",
            "!type": "fn(sprite: +Phaser.Sprite, x: +Number, y: +Number, color: +String)"
          },
          "bodyInfo": {
            "!doc": "Render a Sprites Physic Body information.",
            "!type": "fn(sprite: +Phaser.Sprite, x: +Number, y: +Number, color: +String)"
          },
          "quadTree": {
            "!doc": "Visually renders a QuadTree to the display.",
            "!type": "fn(quadtree: +Phaser.QuadTree, color: +String)"
          },
          "currentY": {
            "!doc": "The current Y position the debug information will be rendered at.",
            "!type": "+Number"
          },
          "geom": {
            "!doc": "Renders a Phaser geometry object including Rectangle, Circle, Point or Line.",
            "!type": "fn(object: +Phaser.Rectangle, color: +String, filled: +Boolean, forceType: +Number)"
          },
          "body": {
            "!doc": "Render a Sprites Physics body if it has one set. The body is rendered as a filled or stroked rectangle.\nThis only works for Arcade Physics, Ninja Physics (AABB and Circle only) and Box2D Physics bodies.\nTo display a P2 Physics body you should enable debug mode on the body when creating it.",
            "!type": "fn(sprite: +Phaser.Sprite, color: +String, filled: +Boolean)"
          },
          "box2dBody": {
            "!doc": "Renders 'debug draw' data for the given Box2D body.\nThis uses the standard debug drawing feature of Box2D, so colors will be decided by the Box2D engine.",
            "!type": "fn(sprite: +Phaser.Sprite, color: +String)"
          },
          "renderShadow": {
            "!doc": "Should the text be rendered with a slight shadow? Makes it easier to read on different types of background.",
            "!type": "+Boolean"
          },
          "timer": {
            "!doc": "Render Timer information.",
            "!type": "fn(timer: +Phaser.Timer, x: +Number, y: +Number, color: +String)"
          },
          "spriteInfo": {
            "!doc": "Render debug infos (including name, bounds info, position and some other properties) about the Sprite.",
            "!type": "fn(sprite: +Phaser.Sprite, x: +Number, y: +Number, color: +String)"
          },
          "lineInfo": {
            "!doc": "Renders Line information in the given color.",
            "!type": "fn(line: +Phaser.Line, x: +Number, y: +Number, color: +String)"
          },
          "sprite": {
            "!doc": "If debugging in WebGL mode we need this.",
            "!type": "+Phaser.Image"
          },
          "context": {
            "!doc": "The 2d context of the canvas.",
            "!type": "+CanvasRenderingContext2D"
          },
          "columnWidth": {
            "!doc": "The spacing between columns.",
            "!type": "+Number"
          },
          "text": {
            "!doc": "Render a string of text.",
            "!type": "fn(text: +String, x: +Number, y: +Number, color: +String, font: +String)"
          },
          "boot": {
            "!doc": "Internal method that boots the debug displayer.",
            "!type": "fn()"
          },
          "pixel": {
            "!doc": "Renders a single pixel at the given size.",
            "!type": "fn(x: +Number, y: +Number, color: +String, size: +Number)"
          },
          "key": {
            "!doc": "Renders Phaser.Key object information.",
            "!type": "fn(key: +Phaser.Key, x: +Number, y: +Number, color: +String)"
          },
          "dirty": {
            "!doc": "Does the canvas need re-rendering?",
            "!type": "+Boolean"
          },
          "inputInfo": {
            "!doc": "Render debug information about the Input object.",
            "!type": "fn(x: +Number, y: +Number, color: +String)"
          },
          "pointer": {
            "!doc": "Renders the Pointer.circle object onto the stage in green if down or red if up along with debug text.",
            "!type": "fn(pointer: +Phaser.Pointer, hideIfUp: +Boolean, downColor: +String, upColor: +String, color: +String)"
          },
          "canvas": {
            "!doc": "The canvas to which Debug calls draws.",
            "!type": "+HTMLCanvasElement"
          },
          "box2dWorld": {
            "!doc": "Renders 'debug draw' data for the Box2D world if it exists.\nThis uses the standard debug drawing feature of Box2D, so colors will be decided by\nthe Box2D engine.",
            "!type": "fn()"
          },
          "spriteCoords": {
            "!doc": "Renders the sprite coordinates in local, positional and world space.",
            "!type": "fn(sprite: +Phaser.Sprite, x: +Number, y: +Number, color: +String)"
          },
          "start": {
            "!doc": "Internal method that resets and starts the debug output values.",
            "!type": "fn(x: +Number, y: +Number, color: +String, columnWidth: +Number)"
          },
          "destroy": {
            "!doc": "Destroy this object.",
            "!type": "fn()"
          },
          "spriteBounds": {
            "!doc": "Renders the Sprites bounds. Note: This is really expensive as it has to calculate the bounds every time you call it!",
            "!type": "fn(sprite: +Phaser.Sprite, color: +String, filled: +Boolean)"
          },
          "soundInfo": {
            "!doc": "Render Sound information, including decoded state, duration, volume and more.",
            "!type": "fn(sound: +Phaser.Sound, x: +Number, y: +Number, color: +String)"
          },
          "stop": {
            "!doc": "Internal method that stops the debug output.",
            "!type": "fn()"
          },
          "currentX": {
            "!doc": "The current X position the debug information will be rendered at.",
            "!type": "+Number"
          },
          "bmd": {
            "!doc": "In WebGL mode this BitmapData contains a copy of the debug canvas.",
            "!type": "+Phaser.BitmapData"
          },
          "resize": {
            "!doc": "Internal method that resizes the BitmapData and Canvas.\nCalled by ScaleManager.onSizeChange only in WebGL mode.",
            "!type": "fn(scaleManager: +Phaser.ScaleManager, width: +Number, height: +Number)"
          },
          "reset": {
            "!doc": "Clears the Debug canvas.",
            "!type": "fn()"
          },
          "lineHeight": {
            "!doc": "The line height between the debug text.",
            "!type": "+Number"
          },
          "preUpdate": {
            "!doc": "Internal method that clears the canvas (if a Sprite) ready for a new debug session.",
            "!type": "fn()"
          },
          "cameraInfo": {
            "!doc": "Render camera information including dimensions and location.",
            "!type": "fn(camera: +Phaser.Camera, x: +Number, y: +Number, color: +String)"
          },
          "font": {
            "!doc": "The font that the debug information is rendered in.",
            "!type": "+String"
          }
        }
      },
      "mixinPrototype": {
        "!doc": "Mixes in an existing mixin object with the target.\n\nValues in the mixin that have either `get` or `set` functions are created as properties via `defineProperty`\n_except_ if they also define a `clone` method - if a clone method is defined that is called instead and\nthe result is assigned directly.",
        "!type": "fn(target: +Object, mixin: +Object, replace: +Boolean)"
      },
      "parseDimension": {
        "!doc": "Get a unit dimension from a string.",
        "!type": "fn(size: +String, dimension: +Number) -> +Number"
      }
    },
    "PENDING_ATLAS": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "BitmapData": {
      "!doc": "A BitmapData object contains a Canvas element to which you can draw anything you like via normal Canvas context operations.\nA single BitmapData can be used as the texture for one or many Images / Sprites. \nSo if you need to dynamically create a Sprite texture then they are a good choice.\n\nImportant note: Every BitmapData creates its own Canvas element. Because BitmapData's are now Game Objects themselves, and don't\nlive on the display list, they are NOT automatically cleared when you change State. Therefore you _must_ call BitmapData.destroy\nin your State's shutdown method if you wish to free-up the resources the BitmapData used, it will not happen for you.",
      "!type": "fn(game: +Phaser.Game, key: +String, width: +Number, height: +Number)",
      "prototype": {
        "generateTexture": {
          "!doc": "Creates a new Image element by converting this BitmapDatas canvas into a dataURL.\n\nThe image is then stored in the image Cache using the key given.\n\nFinally a PIXI.Texture is created based on the image and returned.\n\nYou can apply the texture to a sprite or any other supporting object by using either the\nkey or the texture. First call generateTexture:\n\n`var texture = bitmapdata.generateTexture('ball');`\n\nThen you can either apply the texture to a sprite:\n\n`game.add.sprite(0, 0, texture);`\n\nor by using the string based key:\n\n`game.add.sprite(0, 0, 'ball');`",
          "!type": "fn(key: +String) -> +PIXI.Texture"
        },
        "blendSaturation": {
          "!doc": "Sets the blend mode to 'saturation'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "shadow": {
          "!doc": "Sets the shadow properties of this BitmapDatas context which will affect all draw operations made to it.\nYou can cancel an existing shadow by calling this method and passing no parameters.\nNote: At the time of writing (October 2014) Chrome still doesn't support shadowBlur used with drawImage.",
          "!type": "fn(color: +String, blur: +Number, x: +Number, y: +Number) -> +Phaser.BitmapData"
        },
        "textureLine": {
          "!doc": "Takes the given Line object and image and renders it to this BitmapData as a repeating texture line.",
          "!type": "fn(line: +Phaser.Line, image: +String, repeat: +String) -> +Phaser.BitmapData"
        },
        "data": {
          "!doc": "A Uint8ClampedArray view into BitmapData.buffer.\nNote that this is unavailable in some browsers (such as Epic Browser due to its security restrictions)",
          "!type": "+Uint8ClampedArray"
        },
        "imageData": {
          "!doc": "The context image data.\nPlease note that a call to BitmapData.draw() or BitmapData.copy() does not update immediately this property for performance reason. Use BitmapData.update() to do so.\nThis property is updated automatically after the first game loop, according to the dirty flag property.",
          "!type": "+ImageData"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "blendSourceOut": {
          "!doc": "Sets the blend mode to 'source-out'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "blendHue": {
          "!doc": "Sets the blend mode to 'hue'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "getPixelRGB": {
          "!doc": "Get the color of a specific pixel including its alpha value as a color object containing r,g,b,a and rgba properties.\nIf you have drawn anything to the BitmapData since it was created you must call BitmapData.update to refresh the array buffer,\notherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.",
          "!type": "fn(x: +Number, y: +Number, out: +Object, hsl: +Boolean, hsv: +Boolean) -> +Object"
        },
        "getBounds": {
          "!doc": "Scans the BitmapData and calculates the bounds. This is a rectangle that defines the extent of all non-transparent pixels.\nThe rectangle returned will extend from the top-left of the image to the bottom-right, excluding transparent pixels.",
          "!type": "fn(rect: +Phaser.Rectangle) -> +Phaser.Rectangle"
        },
        "addToWorld": {
          "!doc": "Creates a new Phaser.Image object, assigns this BitmapData to be its texture, adds it to the world then returns it.",
          "!type": "fn(x: +Number, y: +Number, anchorX: +Number, anchorY: +Number, scaleX: +Number, scaleY: +Number) -> +Phaser.Image"
        },
        "moveV": {
          "!doc": "Shifts the contents of this BitmapData vertically.\n\nThe image will wrap-around the sides if the wrap argument is true (the default).",
          "!type": "fn(distance: +Number, wrap: +Boolean) -> +Phaser.BitmapData"
        },
        "textureFrame": {
          "!doc": "The Frame this BitmapData uses for rendering.",
          "!type": "+Phaser.Frame"
        },
        "getPixels": {
          "!doc": "Gets all the pixels from the region specified by the given Rectangle object.",
          "!type": "fn(rect: +Phaser.Rectangle) -> +ImageData"
        },
        "blendLighten": {
          "!doc": "Sets the blend mode to 'lighten'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "context": {
          "!doc": "The 2d context of the canvas.",
          "!type": "+CanvasRenderingContext2D"
        },
        "text": {
          "!doc": "Draws text to the BitmapData in the given font and color.\nThe default font is 14px Courier, so useful for quickly drawing debug text.\nIf you need to do a lot of font work to this BitmapData we'd recommend implementing your own text draw method.",
          "!type": "fn(text: +String, x: +Number, y: +Number, font: +String, color: +String, shadow: +Boolean) -> +Phaser.BitmapData"
        },
        "blendSourceIn": {
          "!doc": "Sets the blend mode to 'source-in'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "blendScreen": {
          "!doc": "Sets the blend mode to 'screen'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "blendDarken": {
          "!doc": "Sets the blend mode to 'darken'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "height": {
          "!doc": "The height of the BitmapData in pixels.",
          "!type": "+Number"
        },
        "add": {
          "!doc": "Updates the given objects so that they use this BitmapData as their texture.\nThis will replace any texture they will currently have set.",
          "!type": "fn(object: +Phaser.Sprite) -> +Phaser.BitmapData"
        },
        "blendXor": {
          "!doc": "Sets the blend mode to 'xor'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "baseTexture": {
          "!doc": "The PIXI.BaseTexture.",
          "!type": "+PIXI.BaseTexture"
        },
        "blendSoftLight": {
          "!doc": "Sets the blend mode to 'soft-light'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "canvas": {
          "!doc": "The canvas to which this BitmapData draws.",
          "!type": "+HTMLCanvasElement"
        },
        "moveH": {
          "!doc": "Shifts the contents of this BitmapData horizontally.\n\nThe image will wrap-around the sides if the wrap argument is true (the default).",
          "!type": "fn(distance: +Number, wrap: +Boolean) -> +Phaser.BitmapData"
        },
        "blendLuminosity": {
          "!doc": "Sets the blend mode to 'luminosity'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "blendDestinationAtop": {
          "!doc": "Sets the blend mode to 'destination-atop'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "ctx": {
          "!doc": "A reference to BitmapData.context.",
          "!type": "+CanvasRenderingContext2D"
        },
        "getPixel": {
          "!doc": "Get the color of a specific pixel in the context into a color object.\nIf you have drawn anything to the BitmapData since it was created you must call BitmapData.update to refresh the array buffer,\notherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.",
          "!type": "fn(x: +Number, y: +Number, out: +Object) -> +Object"
        },
        "destroy": {
          "!doc": "Destroys this BitmapData and puts the canvas it was using back into the canvas pool for re-use.",
          "!type": "fn()"
        },
        "cls": {
          "!doc": "Clears the BitmapData context using a clearRect.",
          "!type": "fn()"
        },
        "fill": {
          "!doc": "Fills the BitmapData with the given color.",
          "!type": "fn(r: +Number, g: +Number, b: +Number, a: +Number) -> +Phaser.BitmapData"
        },
        "blendDestinationOver": {
          "!doc": "Sets the blend mode to 'destination-over'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "blendDifference": {
          "!doc": "Sets the blend mode to 'difference'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "processPixel": {
          "!doc": "Scans through the area specified in this BitmapData and sends the color for every pixel to the given callback along with its x and y coordinates.\nWhatever value the callback returns is set as the new color for that pixel, unless it returns the same color, in which case it's skipped.\nNote that the format of the color received will be different depending on if the system is big or little endian.\nIt is expected that your callback will deal with endianess. If you'd rather Phaser did it then use processPixelRGB instead.\nThe callback will also be sent the pixels x and y coordinates respectively.",
          "!type": "fn(callback: +Function, callbackContext: +Object, x: +Number, y: +Number, width: +Number, height: +Number) -> +Phaser.BitmapData"
        },
        "copyRect": {
          "!doc": "Copies the area defined by the Rectangle parameter from the source image to this BitmapData at the given location.",
          "!type": "fn(source: +Phaser.Sprite, area: +Phaser.Rectangle, x: +Number, y: +Number, alpha: +Number, blendMode: +String, roundPx: +Boolean) -> +Phaser.BitmapData"
        },
        "extract": {
          "!doc": "Scans this BitmapData for all pixels matching the given r,g,b values and then draws them into the given destination BitmapData.\nThe original BitmapData remains unchanged.\nThe destination BitmapData must be large enough to receive all of the pixels that are scanned unless the 'resize' parameter is true.\nAlthough the destination BitmapData is returned from this method, it's actually modified directly in place, meaning this call is perfectly valid:\n`picture.extract(mask, r, g, b)`\nYou can specify optional r2, g2, b2 color values. If given the pixel written to the destination bitmap will be of the r2, g2, b2 color.\nIf not given it will be written as the same color it was extracted. You can provide one or more alternative colors, allowing you to tint\nthe color during extraction.",
          "!type": "fn(destination: +Phaser.BitmapData, r: +Number, g: +Number, b: +Number, a: +Number, resize: +Boolean, r2: +Number, g2: +Number, b2: +Number) -> +Phaser.BitmapData"
        },
        "pixels": {
          "!doc": "An Uint32Array view into BitmapData.buffer.",
          "!type": "+Uint32Array"
        },
        "blendColorBurn": {
          "!doc": "Sets the blend mode to 'color-burn'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "blendSourceAtop": {
          "!doc": "Sets the blend mode to 'source-atop'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "disableTextureUpload": {
          "!doc": "If disableTextureUpload is true this BitmapData will never send its image data to the GPU when its dirty flag is true.",
          "!type": "+Boolean"
        },
        "circle": {
          "!doc": "Draws a filled Circle to the BitmapData at the given x, y coordinates and radius in size.",
          "!type": "fn(x: +Number, y: +Number, radius: +Number, fillStyle: +String) -> +Phaser.BitmapData"
        },
        "blendSourceOver": {
          "!doc": "Sets the blend mode to 'source-over'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "blendOverlay": {
          "!doc": "Sets the blend mode to 'overlay'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "frameData": {
          "!doc": "The FrameData container this BitmapData uses for rendering.",
          "!type": "+Phaser.FrameData"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "setPixel": {
          "!doc": "Sets the color of the given pixel to the specified red, green and blue values.",
          "!type": "fn(x: +Number, y: +Number, red: +Number, green: +Number, blue: +Number, immediate: +Boolean) -> +Phaser.BitmapData"
        },
        "drawFull": {
          "!doc": "Draws the Game Object or Group to this BitmapData and then recursively iterates through all of its children.\n\nIf a child has an `exists` property then it (and its children) will be only be drawn if exists is `true`.\n\nThe children will be drawn at their `x` and `y` world space coordinates. If this is outside the bounds of the BitmapData \nthey won't be drawn. Depending on your requirements you may need to resize the BitmapData in advance to match the \nbounds of the top-level Game Object.\n\nWhen drawing it will take into account the child's world rotation, scale and alpha values.\n\nIt's perfectly valid to pass in `game.world` as the parent object, and it will iterate through the entire display list.\n\nNote: If you are trying to grab your entire game at the start of a State then you should ensure that at least 1 full update\nhas taken place before doing so, otherwise all of the objects will render with incorrect positions and scales. You can \ntrigger an update yourself by calling `stage.updateTransform()` before calling `drawFull`.",
          "!type": "fn(parent: +Phaser.World, blendMode: +String, roundPx: +Boolean) -> +Phaser.BitmapData"
        },
        "line": {
          "!doc": "Draws a line between the coordinates given in the color and thickness specified.",
          "!type": "fn(x1: +Number, y1: +Number, x2: +Number, y2: +Number, color: +String, width: +Number) -> +Phaser.BitmapData"
        },
        "update": {
          "!doc": "This re-creates the BitmapData.imageData from the current context.\nIt then re-builds the ArrayBuffer, the data Uint8ClampedArray reference and the pixels Int32Array.\nIf not given the dimensions defaults to the full size of the context.\n\nWarning: This is a very expensive operation, so use it sparingly.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number) -> +Phaser.BitmapData"
        },
        "setPixel32": {
          "!doc": "Sets the color of the given pixel to the specified red, green, blue and alpha values.",
          "!type": "fn(x: +Number, y: +Number, red: +Number, green: +Number, blue: +Number, alpha: +Number, immediate: +Boolean) -> +Phaser.BitmapData"
        },
        "blendDestinationOut": {
          "!doc": "Sets the blend mode to 'destination-out'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "blendExclusion": {
          "!doc": "Sets the blend mode to 'exclusion'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "blendHardLight": {
          "!doc": "Sets the blend mode to 'hard-light'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "getPixel32": {
          "!doc": "Get the color of a specific pixel including its alpha value.\nIf you have drawn anything to the BitmapData since it was created you must call BitmapData.update to refresh the array buffer,\notherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\nNote that on little-endian systems the format is 0xAABBGGRR and on big-endian the format is 0xRRGGBBAA.",
          "!type": "fn(x: +Number, y: +Number) -> +Number"
        },
        "rect": {
          "!doc": "Draws a filled Rectangle to the BitmapData at the given x, y coordinates and width / height in size.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, fillStyle: +String) -> +Phaser.BitmapData"
        },
        "load": {
          "!doc": "Takes the given Game Object, resizes this BitmapData to match it and then draws it into this BitmapDatas canvas, ready for further processing.\nThe source game object is not modified by this operation.\nIf the source object uses a texture as part of a Texture Atlas or Sprite Sheet, only the current frame will be used for sizing.\nIf a string is given it will assume it's a cache key and look in Phaser.Cache for an image key matching the string.",
          "!type": "fn(source: +Phaser.Sprite) -> +Phaser.BitmapData"
        },
        "copy": {
          "!doc": "Copies a rectangular area from the source object to this BitmapData. If you give `null` as the source it will copy from itself.\nYou can optionally resize, translate, rotate, scale, alpha or blend as it's drawn.\nAll rotation, scaling and drawing takes place around the regions center point by default, but can be changed with the anchor parameters.\nNote that the source image can also be this BitmapData, which can create some interesting effects.\n\nThis method has a lot of parameters for maximum control.\nYou can use the more friendly methods like `copyRect` and `draw` to avoid having to remember them all.",
          "!type": "fn(source: +Phaser.Sprite, x: +Number, y: +Number, width: +Number, height: +Number, tx: +Number, ty: +Number, newWidth: +Number, newHeight: +Number, rotate: +Number, anchorX: +Number, anchorY: +Number, scaleX: +Number, scaleY: +Number, alpha: +Number, blendMode: +String, roundPx: +Boolean) -> +Phaser.BitmapData"
        },
        "blendColor": {
          "!doc": "Sets the blend mode to 'color'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "render": {
          "!doc": "If the game is running in WebGL this will push the texture up to the GPU if it's dirty.\nThis is called automatically if the BitmapData is being used by a Sprite, otherwise you need to remember to call it in your render function.\nIf you wish to suppress this functionality set BitmapData.disableTextureUpload to `true`.",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "key": {
          "!doc": "The key of the BitmapData in the Cache, if stored there.",
          "!type": "+String"
        },
        "blendDestinationIn": {
          "!doc": "Sets the blend mode to 'destination-in'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "dirty": {
          "!doc": "If dirty this BitmapData will be re-rendered.",
          "!type": "+Boolean"
        },
        "move": {
          "!doc": "Shifts the contents of this BitmapData by the distances given.\n\nThe image will wrap-around the edges on all sides if the wrap argument is true (the default).",
          "!type": "fn(x: +Number, y: +Number, wrap: +Boolean) -> +Phaser.BitmapData"
        },
        "blendMultiply": {
          "!doc": "Sets the blend mode to 'multiply'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "blendReset": {
          "!doc": "Resets the blend mode (effectively sets it to 'source-over')",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "texture": {
          "!doc": "The PIXI.Texture.",
          "!type": "+PIXI.Texture"
        },
        "clear": {
          "!doc": "Clears the BitmapData context using a clearRect.\n\nYou can optionally define the area to clear.\nIf the arguments are left empty it will clear the entire canvas.\n\nYou may need to call BitmapData.update after this in order to clear out the pixel data, \nbut Phaser will not do this automatically for you.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number) -> +Phaser.BitmapData"
        },
        "draw": {
          "!doc": "Draws the given Phaser.Sprite, Phaser.Image or Phaser.Text to this BitmapData at the coordinates specified.\nYou can use the optional width and height values to 'stretch' the sprite as it is drawn. This uses drawImage stretching, not scaling.\nWhen drawing it will take into account the Sprites rotation, scale and alpha values.",
          "!type": "fn(source: +Phaser.Sprite, x: +Number, y: +Number, width: +Number, height: +Number, blendMode: +String, roundPx: +Boolean) -> +Phaser.BitmapData"
        },
        "shiftHSL": {
          "!doc": "Shifts any or all of the hue, saturation and lightness values on every pixel in the given region, or the whole BitmapData if no region was specified.\nShifting will add the given value onto the current h, s and l values, not replace them.\nThe hue is wrapped to keep it within the range 0 to 1. Saturation and lightness are clamped to not exceed 1.",
          "!type": "fn(h: +Number, s: +Number, l: +Number, region: +Phaser.Rectangle) -> +Phaser.BitmapData"
        },
        "alphaMask": {
          "!doc": "Draws the image onto this BitmapData using an image as an alpha mask.",
          "!type": "fn(source: +Phaser.Sprite, mask: +Phaser.Sprite, sourceRect: +Phaser.Rectangle, maskRect: +Phaser.Rectangle) -> +Phaser.BitmapData"
        },
        "drawGroup": {
          "!doc": "Draws the immediate children of a Phaser.Group to this BitmapData.\nChildren are only drawn if they have their `exists` property set to `true` and have image based Textures.\nThe children will be drawn at their `x` and `y` world space coordinates. If this is outside the bounds of the BitmapData they won't be drawn.\nWhen drawing it will take into account the child's rotation, scale and alpha values.\nNo iteration takes place. Groups nested inside other Groups will not be iterated through.",
          "!type": "fn(group: +Phaser.Group, blendMode: +String, roundPx: +Boolean) -> +Phaser.BitmapData"
        },
        "processPixelRGB": {
          "!doc": "Scans through the area specified in this BitmapData and sends a color object for every pixel to the given callback.\nThe callback will be sent a color object with 6 properties: `{ r: number, g: number, b: number, a: number, color: number, rgba: string }`.\nWhere r, g, b and a are integers between 0 and 255 representing the color component values for red, green, blue and alpha.\nThe `color` property is an Int32 of the full color. Note the endianess of this will change per system.\nThe `rgba` property is a CSS style rgba() string which can be used with context.fillStyle calls, among others.\nThe callback will also be sent the pixels x and y coordinates respectively.\nThe callback must return either `false`, in which case no change will be made to the pixel, or a new color object.\nIf a new color object is returned the pixel will be set to the r, g, b and a color values given within it.",
          "!type": "fn(callback: +Function, callbackContext: +Object, x: +Number, y: +Number, width: +Number, height: +Number) -> +Phaser.BitmapData"
        },
        "replaceRGB": {
          "!doc": "Replaces all pixels matching one color with another. The color values are given as two sets of RGBA values.\nAn optional region parameter controls if the replacement happens in just a specific area of the BitmapData or the entire thing.",
          "!type": "fn(r1: +Number, g1: +Number, b1: +Number, a1: +Number, r2: +Number, g2: +Number, b2: +Number, a2: +Number, region: +Phaser.Rectangle) -> +Phaser.BitmapData"
        },
        "width": {
          "!doc": "The width of the BitmapData in pixels.",
          "!type": "+Number"
        },
        "resize": {
          "!doc": "Resizes the BitmapData. This changes the size of the underlying canvas and refreshes the buffer.",
          "!type": "fn(width: +Number, height: +Number) -> +Phaser.BitmapData"
        },
        "blendAdd": {
          "!doc": "Sets the blend mode to 'lighter'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "blendColorDodge": {
          "!doc": "Sets the blend mode to 'color-dodge'",
          "!type": "fn() -> +Phaser.BitmapData"
        },
        "setHSL": {
          "!doc": "Sets the hue, saturation and lightness values on every pixel in the given region, or the whole BitmapData if no region was specified.",
          "!type": "fn(h: +Number, s: +Number, l: +Number, region: +Phaser.Rectangle) -> +Phaser.BitmapData"
        },
        "getFirstPixel": {
          "!doc": "Scans the BitmapData, pixel by pixel, until it encounters a pixel that isn't transparent (i.e. has an alpha value > 0).\nIt then stops scanning and returns an object containing the color of the pixel in r, g and b properties and the location in the x and y properties.\n\nThe direction parameter controls from which direction it should start the scan:\n\n0 = top to bottom\n1 = bottom to top\n2 = left to right\n3 = right to left",
          "!type": "fn(direction: +Number) -> +Object"
        }
      },
      "getTransform": {
        "!doc": "Gets a JavaScript object that has 6 properties set that are used by BitmapData in a transform.",
        "!type": "fn(translateX: +Number, translateY: +Number, scaleX: +Number, scaleY: +Number, skewX: +Number, skewY: +Number) -> +Object"
      }
    },
    "VERSION": {
      "!doc": "The Phaser version number.",
      "!type": "+String"
    },
    "Animation": {
      "generateFrameNames": {
        "!doc": "Really handy function for when you are creating arrays of animation data but it's using frame names and not numbers.\nFor example imagine you've got 30 frames named: 'explosion_0001-large' to 'explosion_0030-large'\nYou could use this function to generate those by doing: Phaser.Animation.generateFrameNames('explosion_', 1, 30, '-large', 4);",
        "!type": "fn(prefix: +String, start: +Number, stop: +Number, suffix: +String, zeroPad: +Number) -> +Array._string_"
      },
      "!doc": "An Animation instance contains a single animation and the controls to play it.\n\nIt is created by the AnimationManager, consists of Animation.Frame objects and belongs to a single Game Object such as a Sprite.",
      "!type": "fn(game: +Phaser.Game, parent: +Phaser.Sprite, name: +String, frameData: +Phaser.FrameData, frames: +Array._number_, frameRate: +Number, loop: +Boolean)",
      "prototype": {
        "play": {
          "!doc": "Plays this animation.",
          "!type": "fn(frameRate: +Number, loop: +Boolean, killOnComplete: +Boolean) -> +Phaser.Animation"
        },
        "next": {
          "!doc": "Advances by the given number of frames in the Animation, taking the loop value into consideration.",
          "!type": "fn(quantity: +Number)"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "paused": {
          "!doc": "Gets and sets the paused state of this Animation.",
          "!type": "+Boolean"
        },
        "update": {
          "!doc": "Updates this animation. Called automatically by the AnimationManager.",
          "!type": "fn()"
        },
        "onPause": {
          "!doc": "Called when the Game enters a paused state.",
          "!type": "fn()"
        },
        "speed": {
          "!doc": "Gets or sets the current speed of the animation in frames per second. Changing this in a playing animation will take effect from the next frame. Minimum value is 1.",
          "!type": "+Number"
        },
        "loopCount": {
          "!doc": "The number of times the animation has looped since it was last started.",
          "!type": "+Number"
        },
        "onStart": {
          "!doc": "This event is dispatched when this Animation starts playback.",
          "!type": "+Phaser.Signal"
        },
        "frameTotal": {
          "!doc": "The total number of frames in the currently loaded FrameData, or -1 if no FrameData is loaded.",
          "!type": "+Number"
        },
        "setFrame": {
          "!doc": "Sets this animations playback to a given frame with the given ID.",
          "!type": "fn(frameId: +String, useLocalFrameIndex: +Boolean)"
        },
        "loop": {
          "!doc": "The loop state of the Animation.",
          "!type": "+Boolean"
        },
        "currentFrame": {
          "!doc": "The currently displayed frame of the Animation.",
          "!type": "+Phaser.Frame"
        },
        "isPaused": {
          "!doc": "The paused state of the Animation.",
          "!type": "+Boolean"
        },
        "isPlaying": {
          "!doc": "The playing state of the Animation. Set to false once playback completes, true during playback.",
          "!type": "+Boolean"
        },
        "previous": {
          "!doc": "Moves backwards the given number of frames in the Animation, taking the loop value into consideration.",
          "!type": "fn(quantity: +Number)"
        },
        "restart": {
          "!doc": "Sets this animation back to the first frame and restarts the animation.",
          "!type": "fn()"
        },
        "onComplete": {
          "!doc": "This event is dispatched when this Animation completes playback. If the animation is set to loop this is never fired, listen for onLoop instead.",
          "!type": "+Phaser.Signal"
        },
        "destroy": {
          "!doc": "Cleans up this animation ready for deletion. Nulls all values and references.",
          "!type": "fn()"
        },
        "isFinished": {
          "!doc": "The finished state of the Animation. Set to true once playback completes, false during playback.",
          "!type": "+Boolean"
        },
        "onResume": {
          "!doc": "Called when the Game resumes from a paused state.",
          "!type": "fn()"
        },
        "delay": {
          "!doc": "The delay in ms between each frame of the Animation, based on the given frameRate.",
          "!type": "+Number"
        },
        "stop": {
          "!doc": "Stops playback of this animation and set it to a finished state. If a resetFrame is provided it will stop playback and set frame to the first in the animation.\nIf `dispatchComplete` is true it will dispatch the complete events, otherwise they'll be ignored.",
          "!type": "fn(resetFrame: +Boolean, dispatchComplete: +Boolean)"
        },
        "enableUpdate": {
          "!doc": "Gets or sets if this animation will dispatch the onUpdate events upon changing frame.",
          "!type": "+Boolean"
        },
        "name": {
          "!doc": "The user defined name given to this Animation.",
          "!type": "+String"
        },
        "killOnComplete": {
          "!doc": "Should the parent of this Animation be killed when the animation completes?",
          "!type": "+Boolean"
        },
        "complete": {
          "!doc": "Called internally when the animation finishes playback.\nSets the isPlaying and isFinished states and dispatches the onAnimationComplete event if it exists on the parent and local onComplete event.",
          "!type": "fn()"
        },
        "onUpdate": {
          "!doc": "This event is dispatched when the Animation changes frame. \nBy default this event is disabled due to its intensive nature. Enable it with: `Animation.enableUpdate = true`.\nNote that the event is only dispatched with the current frame. In a low-FPS environment Animations\nwill automatically frame-skip to try and claw back time, so do not base your code on expecting to \nreceive a perfectly sequential set of frames from this event.",
          "!type": "+Phaser.Signal"
        },
        "updateFrameData": {
          "!doc": "Changes the FrameData object this Animation is using.",
          "!type": "fn(frameData: +Phaser.FrameData)"
        },
        "onLoop": {
          "!doc": "This event is dispatched when this Animation loops.",
          "!type": "+Phaser.Signal"
        },
        "frame": {
          "!doc": "Gets or sets the current frame index and updates the Texture Cache for display.",
          "!type": "+Number"
        }
      }
    },
    "RenderTexture": {
      "!doc": "A RenderTexture is a special texture that allows any displayObject to be rendered to it. It allows you to take many complex objects and\nrender them down into a single quad (on WebGL) which can then be used to texture other display objects with. A way of generating textures at run-time.",
      "!type": "fn(game: +Phaser.Game, key: +String, width: +Number, height: +Number, key: +String, scaleMode: +Number, resolution: +Number)",
      "prototype": {
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "renderXY": {
          "!doc": "This function will draw the display object to the RenderTexture at the given coordinates.\n\nWhen the display object is drawn it takes into account scale and rotation.\n\nIf you don't want those then use RenderTexture.renderRawXY instead.",
          "!type": "fn(displayObject: +Phaser.Sprite, x: +Number, y: +Number, clear: +Boolean)"
        },
        "type": {
          "!doc": "Base Phaser object type.",
          "!type": "+Number"
        },
        "render": {
          "!doc": "This function will draw the display object to the RenderTexture.\n\nIn versions of Phaser prior to 2.4.0 the second parameter was a Phaser.Point object. \nThis is now a Matrix allowing you much more control over how the Display Object is rendered.\nIf you need to replicate the earlier behavior please use Phaser.RenderTexture.renderXY instead.\n\nIf you wish for the displayObject to be rendered taking its current scale, rotation and translation into account then either\npass `null`, leave it undefined or pass `displayObject.worldTransform` as the matrix value.",
          "!type": "fn(displayObject: +Phaser.Sprite, matrix: +Phaser.Matrix, clear: +Boolean)"
        },
        "renderRawXY": {
          "!doc": "This function will draw the display object to the RenderTexture at the given coordinates.\n\nWhen the display object is drawn it doesn't take into account scale, rotation or translation.\n\nIf you need those then use RenderTexture.renderXY instead.",
          "!type": "fn(displayObject: +Phaser.Sprite, x: +Number, y: +Number, clear: +Boolean)"
        },
        "key": {
          "!doc": "The key of the RenderTexture in the Cache, if stored there.",
          "!type": "+String"
        }
      }
    },
    "Net": {
      "!doc": "Phaser.Net handles browser URL related tasks such as checking host names, domain names and query string manipulation.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "getHostName": {
          "!doc": "Returns the hostname given by the browser.",
          "!type": "fn() -> +String"
        },
        "updateQueryString": {
          "!doc": "Updates a value on the Query String and returns it in full.\nIf the value doesn't already exist it is set.\nIf the value exists it is replaced with the new value given. If you don't provide a new value it is removed from the query string.\nOptionally you can redirect to the new url, or just return it as a string.",
          "!type": "fn(key: +String, value: +String, redirect: +Boolean, url: +String) -> +String"
        },
        "getQueryString": {
          "!doc": "Returns the Query String as an object.\nIf you specify a parameter it will return just the value of that parameter, should it exist.",
          "!type": "fn(parameter: +String) -> +String"
        },
        "decodeURI": {
          "!doc": "Takes a Uniform Resource Identifier (URI) component (previously created by encodeURIComponent or by a similar routine) and\ndecodes it, replacing \\ with spaces in the return. Used internally by the Net classes.",
          "!type": "fn(value: +String) -> +String"
        },
        "checkDomainName": {
          "!doc": "Compares the given domain name against the hostname of the browser containing the game.\nIf the domain name is found it returns true.\nYou can specify a part of a domain, for example 'google' would match 'google.com', 'google.co.uk', etc.\nDo not include 'http://' at the start.",
          "!type": "fn(domain: +String) -> +Boolean"
        }
      }
    },
    "FrameData": {
      "!doc": "FrameData is a container for Frame objects, which are the internal representation of animation data in Phaser.",
      "!type": "fn()",
      "prototype": {
        "getFrameByName": {
          "!doc": "Get a Frame by its frame name.",
          "!type": "fn(name: +String) -> +Phaser.Frame"
        },
        "total": {
          "!doc": "The total number of frames in this FrameData set.",
          "!type": "+Number"
        },
        "getFrames": {
          "!doc": "Returns all of the Frames in this FrameData set where the frame index is found in the input array.\nThe frames are returned in the output array, or if none is provided in a new Array object.",
          "!type": "fn(frames: +Array, useNumericIndex: +Boolean, output: +Array) -> +Array"
        },
        "getFrameIndexes": {
          "!doc": "Returns all of the Frame indexes in this FrameData set.\nThe frames indexes are returned in the output array, or if none is provided in a new Array object.",
          "!type": "fn(frames: +Array, useNumericIndex: +Boolean, output: +Array) -> +Array"
        },
        "checkFrameName": {
          "!doc": "Check if there is a Frame with the given name.",
          "!type": "fn(name: +String) -> +Boolean"
        },
        "getFrame": {
          "!doc": "Get a Frame by its numerical index.",
          "!type": "fn(index: +Number) -> +Phaser.Frame"
        },
        "getFrameRange": {
          "!doc": "Returns a range of frames based on the given start and end frame indexes and returns them in an Array.",
          "!type": "fn(start: +Number, end: +Number, output: +Array) -> +Array"
        },
        "clone": {
          "!doc": "Makes a copy of this FrameData including copies (not references) to all of the Frames it contains.",
          "!type": "fn() -> +Phaser.FrameData"
        },
        "addFrame": {
          "!doc": "Adds a new Frame to this FrameData collection. Typically called by the Animation.Parser and not directly.",
          "!type": "fn(frame: +Phaser.Frame) -> +Phaser.Frame"
        },
        "destroy": {
          "!doc": "Destroys this FrameData collection by nulling the _frames and _frameNames arrays.",
          "!type": "fn()"
        }
      }
    },
    "RoundedRectangle": {
      "!doc": "The Rounded Rectangle object is an area defined by its position and has nice rounded corners, \nas indicated by its top-left corner point (x, y) and by its width and its height.",
      "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, radius: +Number)",
      "prototype": {
        "contains": {
          "!doc": "Determines whether the specified coordinates are contained within the region defined by this Rounded Rectangle object.",
          "!type": "fn(x: +Number, y: +Number) -> +Boolean"
        },
        "clone": {
          "!doc": "Returns a new RoundedRectangle object with the same values for the x, y, width, height and\nradius properties as this RoundedRectangle object.",
          "!type": "fn() -> +Phaser.RoundedRectangle"
        },
        "x": {
          "!doc": "The x coordinate of the top-left corner of the Rectangle.",
          "!type": "+Number"
        },
        "width": {
          "!doc": "The width of the Rectangle. This value should never be set to a negative.",
          "!type": "+Number"
        },
        "y": {
          "!doc": "The y coordinate of the top-left corner of the Rectangle.",
          "!type": "+Number"
        },
        "radius": {
          "!doc": "The radius of the rounded corners.",
          "!type": "+Number"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "height": {
          "!doc": "The height of the Rectangle. This value should never be set to a negative.",
          "!type": "+Number"
        }
      }
    },
    "DOWN": {
      "!doc": "Direction constant.",
      "!type": "+Number"
    },
    "VIDEO": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "TilemapLayer": {
      "init": {
        "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
        "!type": "fn()"
      },
      "install": {
        "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
        "!type": "fn()"
      },
      "!doc": "A TilemapLayer is a Phaser.Image/Sprite that renders a specific TileLayer of a Tilemap.\n\nSince a TilemapLayer is a Sprite it can be moved around the display, added to other groups or display objects, etc.\n\nBy default TilemapLayers have fixedToCamera set to `true`. Changing this will break Camera follow and scrolling behavior.",
      "!type": "fn(game: +Phaser.Game, tilemap: +Phaser.Tilemap, index: +Number, width: +Number, height: +Number)",
      "prototype": {
        "play": {
          "!doc": "Plays an Animation.\n\nThe animation should have previously been created via `animations.add`.\n\nIf the animation is already playing calling this again won't do anything.\nIf you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.",
          "!type": "fn(name: +String, frameRate: +Number, loop: +Boolean, killOnComplete: +Boolean) -> +Phaser.Animation"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "lifespan": {
          "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
          "!type": "+Number"
        },
        "outOfBoundsKill": {
          "!doc": "If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.",
          "!type": "+Boolean"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "resizeFrame": {
          "!doc": "Resizes the Frame dimensions that the Game Object uses for rendering.\n\nYou shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData\nit can be useful to adjust the dimensions directly in this way.",
          "!type": "fn(parent: +Object, width: +Number, height: +Number)"
        },
        "rayStepRate": {
          "!doc": "When ray-casting against tiles this is the number of steps it will jump. For larger tile sizes you can increase this to improve performance.",
          "!type": "+Number"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "maxHealth": {
          "!doc": "The Game Objects maximum health value. This works in combination with the `heal` method to ensure\nthe health value never exceeds the maximum.",
          "!type": "+Number"
        },
        "revive": {
          "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
          "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
        },
        "scrollFactorX": {
          "!doc": "Speed at which this layer scrolls horizontally, relative to the camera (e.g. scrollFactorX of 0.5 scrolls half as quickly as the 'normal' camera-locked layers do).",
          "!type": "+Number"
        },
        "scrollFactorY": {
          "!doc": "Speed at which this layer scrolls vertically, relative to the camera (e.g. scrollFactorY of 0.5 scrolls half as quickly as the 'normal' camera-locked layers do)",
          "!type": "+Number"
        },
        "bringToTop": {
          "!doc": "Brings this Game Object to the top of its parents display list.\nVisually this means it will render over the top of any old child in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "events": {
          "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
          "!type": "+Phaser.Events"
        },
        "moveUp": {
          "!doc": "Moves this Game Object up one place in its parents display list.\nThis call has no effect if the Game Object is already at the top of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "canvas": {
          "!doc": "The canvas to which this TilemapLayer draws.",
          "!type": "+HTMLCanvasElement"
        },
        "postUpdate": {
          "!doc": "Automatically called by World.postUpdate. Handles cache updates.",
          "!type": "fn()"
        },
        "getRayCastTiles": {
          "!doc": "Gets all tiles that intersect with the given line.",
          "!type": "fn(line: +Phaser.Line, stepRate: +Number, collides: +Boolean, interestingFace: +Boolean) -> +Array._Phaser.Tile_"
        },
        "getTileXY": {
          "!doc": "Convert a pixel coordinate to a tile coordinate.",
          "!type": "fn(x: +Number, y: +Number, point: +Phaser.Point) -> +Phaser.Point"
        },
        "smoothed": {
          "!doc": "Enable or disable texture smoothing for this Game Object.\n\nIt only takes effect if the Game Object is using an image based texture.\n\nSmoothing is enabled by default.",
          "!type": "+Boolean"
        },
        "destroy": {
          "!doc": "Destroys this TilemapLayer.",
          "!type": "fn()"
        },
        "index": {
          "!doc": "The index of this layer within the Tilemap.",
          "!type": "+Number"
        },
        "renderSettings": {
          "!doc": "Settings that control standard (non-diagnostic) rendering.",
          "!type": "+Object"
        },
        "input": {
          "!doc": "The Input Handler for this Game Object.\n\nBy default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.\n\nAfter you have done this, this property will be a reference to the Phaser InputHandler.",
          "!type": "+Phaser.InputHandler"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "left": {
          "!doc": "The left coordinate of the Game Object.\nThis is the same as `x - offsetX`.",
          "!type": "+Number"
        },
        "reset": {
          "!doc": "Resets the Game Object.\n\nThis moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`, \n`visible` and `renderable` to true.\n\nIf this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.\n\nIf this Game Object has a Physics Body it will reset the Body.",
          "!type": "fn(x: +Number, y: +Number, health: +Number) -> +PIXI.DisplayObject"
        },
        "preUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn()"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "damage": {
          "!doc": "Damages the Game Object. This removes the given amount of health from the `health` property.\n\nIf health is taken below or is equal to zero then the `kill` method is called.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "components": {
          "!doc": "The components this Game Object has installed.",
          "!type": "+Object"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
          "!type": "+Boolean"
        },
        "transformCallback": {
          "!doc": "The callback that will apply any scale limiting to the worldTransform.",
          "!type": "+Function"
        },
        "inWorld": {
          "!doc": "Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.",
          "!type": "+Boolean"
        },
        "layer": {
          "!doc": "The layer object within the Tilemap that this layer represents.",
          "!type": "+Object"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "world": {
          "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
          "!type": "+Phaser.Point"
        },
        "top": {
          "!doc": "The y coordinate of the Game Object.\nThis is the same as `y - offsetY`.",
          "!type": "+Number"
        },
        "angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        },
        "setScaleMinMax": {
          "!doc": "Sets the scaleMin and scaleMax values. These values are used to limit how far this Game Object will scale based on its parent.\n\nFor example if this Game Object has a `minScale` value of 1 and its parent has a `scale` value of 0.5, the 0.5 will be ignored \nand the scale value of 1 will be used, as the parents scale is lower than the minimum scale this Game Object should adhere to.\n\nBy setting these values you can carefully control how Game Objects deal with responsive scaling.\n\nIf only one parameter is given then that value will be used for both scaleMin and scaleMax:\n`setScaleMinMax(1)` = scaleMin.x, scaleMin.y, scaleMax.x and scaleMax.y all = 1\n\nIf only two parameters are given the first is set as scaleMin.x and y and the second as scaleMax.x and y:\n`setScaleMinMax(0.5, 2)` = scaleMin.x and y = 0.5 and scaleMax.x and y = 2\n\nIf you wish to set `scaleMin` with different values for x and y then either modify Game Object.scaleMin directly, \nor pass `null` for the `maxX` and `maxY` parameters.\n\nCall `setScaleMinMax(null)` to clear all previously set values.",
          "!type": "fn(minX: +Number, minY: +Number, maxX: +Number, maxY: +Number)"
        },
        "resetTilesetCache": {
          "!doc": "The TilemapLayer caches tileset look-ups.\n\nCall this method of clear the cache if tilesets have been added or updated after the layer has been rendered.",
          "!type": "fn()"
        },
        "checkWorldBounds": {
          "!doc": "If this is set to `true` the Game Object checks if it is within the World bounds each frame. \n\nWhen it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.\n\nIf it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.\n\nIt also optionally kills the Game Object if `outOfBoundsKill` is `true`.\n\nWhen `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "map": {
          "!doc": "The Tilemap to which this layer is bound.",
          "!type": "+Phaser.Tilemap"
        },
        "key": {
          "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
          "!type": "+String"
        },
        "dirty": {
          "!doc": "If true tiles will be force rendered, even if such is not believed to be required.",
          "!type": "+Boolean"
        },
        "texture": {
          "!doc": "The texture that the sprite is using",
          "!type": "+Texture"
        },
        "health": {
          "!doc": "The Game Objects health value. This is a handy property for setting and manipulating health on a Game Object.\n\nIt can be used in combination with the `damage` method or modified directly.",
          "!type": "+Number"
        },
        "outOfCameraBoundsKill": {
          "!doc": "If this and the `autoCull` property are both set to `true`, then the `kill` method\nis called as soon as the Game Object leaves the camera bounds.",
          "!type": "+Boolean"
        },
        "destroyPhase": {
          "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
          "!type": "+Boolean"
        },
        "right": {
          "!doc": "The right coordinate of the Game Object.\nThis is the same as `x + width - offsetX`.",
          "!type": "+Number"
        },
        "kill": {
          "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousPosition": {
          "!doc": "The position the Game Object was located in the previous frame.",
          "!type": "+Phaser.Point"
        },
        "scaleMax": {
          "!doc": "The maximum scale this Game Object will scale up to. \n\nIt allows you to prevent a parent from scaling this Game Object higher than the given value.\n\nSet it to `null` to remove the limit.",
          "!type": "+Phaser.Point"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "anchor": {
          "!doc": "The anchor sets the origin point of the texture.\nThe default is 0,0 this means the texture's origin is the top left\nSetting than anchor to 0.5,0.5 means the textures origin is centered\nSetting the anchor to 1,1 would mean the textures origin points will be the bottom right corner",
          "!type": "+Phaser.Point"
        },
        "autoCull": {
          "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The position of the Game Object on the x axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "Controls if the core game loop and physics update this game object or not.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The position of the Game Object on the y axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
          "!type": "+Number"
        },
        "scaleMin": {
          "!doc": "The minimum scale this Game Object will scale down to.\n\nIt allows you to prevent a parent from scaling this Game Object lower than the given value.\n\nSet it to `null` to remove the limit.",
          "!type": "+Phaser.Point"
        },
        "getTileY": {
          "!doc": "Convert a pixel value to a tile coordinate.",
          "!type": "fn(y: +Number) -> +Number"
        },
        "getTileX": {
          "!doc": "Convert a pixel value to a tile coordinate.",
          "!type": "fn(x: +Number) -> +Number"
        },
        "body": {
          "!doc": "`body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated \nproperties and methods via it.\n\nBy default Game Objects won't add themselves to any physics system and their `body` property will be `null`.\n\nTo enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object\nand `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.\n\nYou can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.\n\nImportant: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5, \nso the physics body is centered on the Game Object.\n\nIf you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.",
          "!type": "+Phaser.Physics.Arcade.Body"
        },
        "inCamera": {
          "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
          "!type": "+Boolean"
        },
        "ensureSharedCopyCanvas": {
          "!doc": "Create if needed (and return) a shared copy canvas that is shared across all TilemapLayers.\n\nCode that uses the canvas is responsible to ensure the dimensions and save/restore state as appropriate.",
          "!type": "fn()"
        },
        "offsetX": {
          "!doc": "The amount the Game Object is visually offset from its x coordinate.\nThis is the same as `width * anchor.x`.\nIt will only be > 0 if anchor.x is not equal to zero.",
          "!type": "+Number"
        },
        "tintedTexture": {
          "!doc": "A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)",
          "!type": "+Phaser.Canvas"
        },
        "offsetY": {
          "!doc": "The amount the Game Object is visually offset from its y coordinate.\nThis is the same as `height * anchor.y`.\nIt will only be > 0 if anchor.y is not equal to zero.",
          "!type": "+Number"
        },
        "fixedToCamera": {
          "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
          "!type": "+Boolean"
        },
        "renderOrderID": {
          "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
          "!type": "+Number"
        },
        "previousRotation": {
          "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
          "!type": "+Number"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "setScale": {
          "!doc": "This method will set the scale of the tilemap as well as update the underlying block data of this layer.",
          "!type": "fn(xScale: +Number, yScale: +Number)"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.\nThis is the same as `y + height - offsetY`.",
          "!type": "+Number"
        },
        "cameraOffset": {
          "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
          "!type": "+Phaser.Point"
        },
        "moveDown": {
          "!doc": "Moves this Game Object down one place in its parents display list.\nThis call has no effect if the Game Object is already at the bottom of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "updateCrop": {
          "!doc": "If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,\nor the rectangle it references, then you need to update the crop frame by calling this method.",
          "!type": "fn()"
        },
        "overlap": {
          "!doc": "Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object, \nwhich can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.\n\nThis check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.\n\nTherefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.\nIt should be fine for low-volume testing where physics isn't required.",
          "!type": "fn(displayObject: +Phaser.Sprite) -> +Boolean"
        },
        "loadTexture": {
          "!doc": "Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.\n\nIf your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.\n\nYou should only use `loadTexture` if you want to replace the base texture entirely.\n\nCalling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.\n\nYou can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite. \nDoing this then sets the key to be the `frame` argument (the frame is set to zero). \n\nThis allows you to create sprites using `load.image` during development, and then change them \nto use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS' \nand swapping it to be the key of the atlas data.\n\nNote: You cannot use a RenderTexture as a texture for a TileSprite.",
          "!type": "fn(key: +String, frame: +String, stopAnimation: +Boolean)"
        },
        "name": {
          "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
          "!type": "+String"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "crop": {
          "!doc": "Crop allows you to crop the texture being used to display this Game Object.\nSetting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.\n\nCropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,\nor by modifying `cropRect` property directly and then calling `updateCrop`.\n\nThe rectangle object given to this method can be either a `Phaser.Rectangle` or any other object \nso long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.\n\nA reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`, \nin which case the values are duplicated to a local object.",
          "!type": "fn(rect: +Phaser.Rectangle, copy: +Boolean)"
        },
        "frame": {
          "!doc": "Gets or sets the current frame index of the texture being used to render this Game Object.\n\nTo change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,\nfor example: `player.frame = 4`.\n\nIf the frame index given doesn't exist it will revert to the first frame found in the texture.\n\nIf you are using a texture atlas then you should use the `frameName` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+Number"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "shader": {
          "!doc": "The shader that will be used to render the texture to the stage. Set to null to remove a current shader.",
          "!type": "+PIXI.AbstractFilter"
        },
        "cropRect": {
          "!doc": "The Rectangle used to crop the texture this Game Object uses.\nSet this property via `crop`. \nIf you modify this property directly you must call `updateCrop` in order to have the change take effect.",
          "!type": "+Phaser.Rectangle"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "resizeWorld": {
          "!doc": "Sets the world size to match the size of this layer.",
          "!type": "fn()"
        },
        "deltaZ": {
          "!doc": "The delta value.",
          "!type": "+Number"
        },
        "transformCallbackContext": {
          "!doc": "The context under which `transformCallback` is called.",
          "!type": "+Object"
        },
        "deltaX": {
          "!doc": "Returns the delta x value. The difference between world.x now and in the previous frame.\n\nThe value will be positive if the Game Object has moved to the right or negative if to the left.",
          "!type": "+Number"
        },
        "deltaY": {
          "!doc": "Returns the delta y value. The difference between world.y now and in the previous frame.\n\nThe value will be positive if the Game Object has moved down or negative if up.",
          "!type": "+Number"
        },
        "update": {
          "!doc": "Override this method in your own custom objects to handle any update requirements.\nIt is called immediately after `preUpdate` and before `postUpdate`.\nRemember if this Game Object has any children you should call update on those too.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "tint": {
          "!doc": "The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.",
          "!type": "+Number"
        },
        "inputEnabled": {
          "!doc": "By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created\nfor this Game Object and it will then start to process click / touch events and more.\n\nYou can then access the Input Handler via `this.input`.\n\nNote that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.\n\nIf you set this property to false it will stop the Input Handler from processing any more input events.",
          "!type": "+Boolean"
        },
        "debugSettings": {
          "!doc": "Settings used for debugging and diagnostics.",
          "!type": "+Object"
        },
        "setFrame": {
          "!doc": "Sets the texture frame the Game Object uses for rendering.\n\nThis is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.",
          "!type": "fn(frame: +Phaser.Frame)"
        },
        "animations": {
          "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
          "!type": "+Phaser.AnimationManager"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "heal": {
          "!doc": "Heal the Game Object. This adds the given amount of health to the `health` property.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "render": {
          "!doc": "Renders the tiles to the layer canvas and pushes to the display.",
          "!type": "fn()"
        },
        "setHealth": {
          "!doc": "Sets the health property of the Game Object to the given amount.\nWill never exceed the `maxHealth` value.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "debug": {
          "!doc": "Enable an additional \"debug rendering\" pass to display collision information.",
          "!type": "+Boolean"
        },
        "frameName": {
          "!doc": "Gets or sets the current frame name of the texture being used to render this Game Object.\n\nTo change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use, \nfor example: `player.frameName = \"idle\"`.\n\nIf the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.\n\nIf you are using a sprite sheet then you should use the `frame` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+String"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends this Game Object to the bottom of its parents display list.\nVisually this means it will render below all other children in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "resetFrame": {
          "!doc": "Resets the texture frame dimensions that the Game Object uses for rendering.",
          "!type": "fn()"
        },
        "pendingDestroy": {
          "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
          "!type": "+Boolean"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.\n\nWarning: You cannot have a blend mode and a filter active on the same Sprite. Doing so will render the sprite invisible.",
          "!type": "+Number"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "resize": {
          "!doc": "Resizes the internal canvas and texture frame used by this TilemapLayer.\n\nThis is an expensive call, so don't bind it to a window resize event! But instead call it at carefully\nselected times.\n\nBe aware that no validation of the new sizes takes place and the current map scroll coordinates are not\nmodified either. You will have to handle both of these things from your game code if required.",
          "!type": "fn(width: +Number, height: +Number)"
        },
        "fresh": {
          "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
          "!type": "+Boolean"
        },
        "getTiles": {
          "!doc": "Get all tiles that exist within the given area, defined by the top-left corner, width and height. Values given are in pixels, not tiles.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, collides: +Boolean, interestingFace: +Boolean) -> +array._Phaser.Tile_"
        }
      }
    },
    "blendModes": {
      "!doc": "Various blend modes supported by Pixi.\n\nIMPORTANT: The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.",
      "!type": "+Object"
    },
    "GameObjectCreator": {
      "!doc": "The GameObjectCreator is a quick way to create common game objects _without_ adding them to the game world.\nThe object creator can be accessed with {@linkcode Phaser.Game#make `game.make`}.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "image": {
          "!doc": "Create a new Image object.\n\nAn Image is a light-weight object you can use to display anything that doesn't need physics or animation.\nIt can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.",
          "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String) -> +Phaser.Image"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "retroFont": {
          "!doc": "Create a new RetroFont object.\n\nA RetroFont can be used as a texture for an Image or Sprite and optionally add it to the Cache.\nA RetroFont uses a bitmap which contains fixed with characters for the font set. You use character spacing to define the set.\nIf you need variable width character support then use a BitmapText object instead. The main difference between a RetroFont and a BitmapText\nis that a RetroFont creates a single texture that you can apply to a game object, where-as a BitmapText creates one Sprite object per letter of text.\nThe texture can be asssigned or one or multiple images/sprites, but note that the text the RetroFont uses will be shared across them all,\ni.e. if you need each Image to have different text in it, then you need to create multiple RetroFont objects.",
          "!type": "fn(font: +String, characterWidth: +Number, characterHeight: +Number, chars: +String, charsPerRow: +Number, xSpacing: +Number, ySpacing: +Number, xOffset: +Number, yOffset: +Number) -> +Phaser.RetroFont"
        },
        "renderTexture": {
          "!doc": "A dynamic initially blank canvas to which images can be drawn.",
          "!type": "fn(width: +Number, height: +Number, key: +String, addToCache: +Boolean) -> +Phaser.RenderTexture"
        },
        "sound": {
          "!doc": "Creates a new Sound object.",
          "!type": "fn(key: +String, volume: +Number, loop: +Boolean, connect: +Boolean) -> +Phaser.Sound"
        },
        "rope": {
          "!doc": "Creates a new Rope object.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, key: +String, frame: +String) -> +Phaser.Rope"
        },
        "bitmapText": {
          "!doc": "Create a new BitmapText object.\n\nBitmapText objects work by taking a texture file and an XML file that describes the font structure.\nIt then generates a new Sprite object for each letter of the text, proportionally spaced out and aligned to \nmatch the font structure.\n\nBitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability \nto use Web Fonts. However you trade this flexibility for pure rendering speed. You can also create visually compelling BitmapTexts by \nprocessing the font texture in an image editor first, applying fills and any other effects required.\n\nTo create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\n\nTo create a BitmapText data files you can use:\n\nBMFont (Windows, free): http://www.angelcode.com/products/bmfont/\nGlyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner\nLittera (Web-based, free): http://kvazars.com/littera/",
          "!type": "fn(x: +Number, y: +Number, font: +String, text: +String, size: +Number, align: +String) -> +Phaser.BitmapText"
        },
        "graphics": {
          "!doc": "Creates a new Graphics object.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Graphics"
        },
        "tilemap": {
          "!doc": "Creates a new Phaser.Tilemap object.\n\nThe map can either be populated with data from a Tiled JSON file or from a CSV file.\nTo do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.\nWhen using CSV data you must provide the key and the tileWidth and tileHeight parameters.\nIf creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.\nNote that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.",
          "!type": "fn(key: +String, tileWidth: +Number, tileHeight: +Number, width: +Number, height: +Number)"
        },
        "button": {
          "!doc": "Creates a new Button object.",
          "!type": "fn(x: +Number, y: +Number, key: +String, callback: +Function, callbackContext: +Object, overFrame: +String, outFrame: +String, downFrame: +String, upFrame: +String) -> +Phaser.Button"
        },
        "filter": {
          "!doc": "A WebGL shader/filter that can be applied to Sprites.",
          "!type": "fn(filter: +String, _any: +Object) -> +Phaser.Filter"
        },
        "tween": {
          "!doc": "Create a tween object for a specific object.\n\nThe object can be any JavaScript object or Phaser object such as Sprite.",
          "!type": "fn(obj: +Object) -> +Phaser.Tween"
        },
        "world": {
          "!doc": "A reference to the game world.",
          "!type": "+Phaser.World"
        },
        "bitmapData": {
          "!doc": "Create a BitmpaData object.\n\nA BitmapData object can be manipulated and drawn to like a traditional Canvas object and used to texture Sprites.",
          "!type": "fn(width: +Number, height: +Number, key: +String, addToCache: +Boolean) -> +Phaser.BitmapData"
        },
        "sprite": {
          "!doc": "Create a new Sprite with specific position and sprite sheet key.",
          "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String) -> +Phaser.Sprite"
        },
        "spriteBatch": {
          "!doc": "Create a new SpriteBatch.",
          "!type": "fn(parent: +Object, name: +String, addToStage: +Boolean) -> +Phaser.SpriteBatch"
        },
        "audio": {
          "!doc": "Creates a new Sound object.",
          "!type": "fn(key: +String, volume: +Number, loop: +Boolean, connect: +Boolean) -> +Phaser.Sound"
        },
        "text": {
          "!doc": "Creates a new Text object.",
          "!type": "fn(x: +Number, y: +Number, text: +String, style: +Object) -> +Phaser.Text"
        },
        "tileSprite": {
          "!doc": "Creates a new TileSprite object.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, key: +String, frame: +String) -> +Phaser.TileSprite"
        },
        "emitter": {
          "!doc": "Creat a new Emitter.\n\nAn Emitter is a lightweight particle emitter. It can be used for one-time explosions or for\ncontinuous effects like rain and fire. All it really does is launch Particle objects out\nat set intervals, and fixes their positions and velocities accorindgly.",
          "!type": "fn(x: +Number, y: +Number, maxParticles: +Number) -> +Phaser.Emitter"
        },
        "group": {
          "!doc": "A Group is a container for display objects that allows for fast pooling, recycling and collision checks.",
          "!type": "fn(parent: +Object, name: +String, addToStage: +Boolean, enableBody: +Boolean, physicsBodyType: +Number) -> +Phaser.Group"
        },
        "audioSprite": {
          "!doc": "Creates a new AudioSprite object.",
          "!type": "fn(key: +String) -> +Phaser.AudioSprite"
        }
      }
    },
    "World": {
      "SORT_ASCENDING": "+Number",
      "RETURN_TOTAL": "+Number",
      "!doc": "\"This world is but a canvas to our imagination.\" - Henry David Thoreau\n\nA game has only one world. The world is an abstract place in which all game objects live. It is not bound\nby stage limits and can be any size. You look into the world via cameras. All game objects live within\nthe world at world-based coordinates. By default a world is created the same size as your Stage.",
      "RETURN_NONE": "+Number",
      "!type": "fn(game: +Phaser.Game)",
      "SORT_DESCENDING": "+Number",
      "RETURN_CHILD": "+Number",
      "prototype": {
        "xy": {
          "!doc": "Positions the child found at the given index within this group to the given x and y coordinates.",
          "!type": "fn(index: +Number, x: +Number, y: +Number)"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "descendingSortHandler": {
          "!doc": "An internal helper function for the sort process.",
          "!type": "fn(a: +Object, b: +Object)"
        },
        "centerY": {
          "!doc": "Gets the Y position corresponding to the center point of the world.",
          "!type": "+Number"
        },
        "centerX": {
          "!doc": "Gets the X position corresponding to the center point of the world.",
          "!type": "+Number"
        },
        "type": {
          "!doc": "Internal Phaser Type value.",
          "!type": "+Number"
        },
        "moveAll": {
          "!doc": "Moves all children from this Group to the Group given.",
          "!type": "fn(group: +Phaser.Group, silent: +Boolean) -> +Phaser.Group"
        },
        "removeAll": {
          "!doc": "Removes all children from this group, but does not remove the group from its parent.",
          "!type": "fn(destroy: +Boolean, silent: +Boolean)"
        },
        "enableBody": {
          "!doc": "If true all Sprites created by, or added to this group, will have a physics body enabled on them.\n\nThe default body type is controlled with {@link #physicsBodyType}.",
          "!type": "+Boolean"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "customSort": {
          "!doc": "Sort the children in the group according to custom sort function.\n\nThe `sortHandler` is provided the two parameters: the two children involved in the comparison (a and b).\nIt should return -1 if `a > b`, 1 if `a < b` or 0 if `a === b`.",
          "!type": "fn(sortHandler: +Function, context: +Object)"
        },
        "enableBodyDebug": {
          "!doc": "If true when a physics body is created (via {@link #enableBody}) it will create a physics debug object as well.\n\nThis only works for P2 bodies.",
          "!type": "+Boolean"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "bringToTop": {
          "!doc": "Brings the given child to the top of this group so it renders above all other children.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "moveUp": {
          "!doc": "Moves the given child up one place in this group unless it's already at the top.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "height": {
          "!doc": "The defined height of the World. Sometimes the bounds needs to grow larger than this (if you resize the game) but this retains the original requested dimension.",
          "!type": "+Number"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "_definedSize": {
          "!doc": "True if the World has been given a specifically defined size (i.e. from a Tilemap or direct in code) or false if it's just matched to the Game dimensions.",
          "!type": "+Boolean"
        },
        "postUpdate": {
          "!doc": "The core postUpdate - as called by World.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Destroys this group.\n\nRemoves all children, then removes this group from its parent and nulls references.",
          "!type": "fn(destroyChildren: +Boolean, soft: +Boolean)"
        },
        "cursorIndex": {
          "!doc": "The current index of the Group cursor. Advance it with Group.next.",
          "!type": "+Number"
        },
        "getFirstDead": {
          "!doc": "Get the first child that is dead (`child.alive === false`).\n\nThis is handy for checking if everything has been wiped out and adding to the pool as needed.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no dead ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "physicsSortDirection": {
          "!doc": "If this Group contains Arcade Physics Sprites you can set a custom sort direction via this property.\n\nIt should be set to one of the Phaser.Physics.Arcade sort direction constants: \n\nPhaser.Physics.Arcade.SORT_NONE\nPhaser.Physics.Arcade.LEFT_RIGHT\nPhaser.Physics.Arcade.RIGHT_LEFT\nPhaser.Physics.Arcade.TOP_BOTTOM\nPhaser.Physics.Arcade.BOTTOM_TOP\n\nIf set to `null` the Group will use whatever Phaser.Physics.Arcade.sortDirection is set to. This is the default behavior.",
          "!type": "+Number"
        },
        "addAt": {
          "!doc": "Adds an existing object to this group.\n\nThe child is added to the group at the location specified by the index value, this allows you to control child ordering.",
          "!type": "fn(child: +DisplayObject, index: +Number, silent: +Boolean) -> +PIXI.DisplayObject"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "forEachAlive": {
          "!doc": "Call a function on each alive child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "resetCursor": {
          "!doc": "Sets the group cursor to the first child in the group.\n\nIf the optional index parameter is given it sets the cursor to the object at that index instead.",
          "!type": "fn(index: +Number) -> +Object"
        },
        "addMultiple": {
          "!doc": "Adds an array of existing Display Objects to this Group.\n\nThe Display Objects are automatically added to the top of this Group, and will render on-top of everything already in this Group.\n\nAs well as an array you can also pass another Group as the first argument. In this case all of the children from that\nGroup will be removed from it and added into this Group.",
          "!type": "fn(children: +Array._DisplayObject_, silent: +Boolean) -> +Array._DisplayObject_"
        },
        "setProperty": {
          "!doc": "Sets a property to the given value on the child. The operation parameter controls how the value is set.\n\nThe operations are:\n- 0: set the existing value to the given value; if force is `true` a new property will be created if needed\n- 1: will add the given value to the value already present.\n- 2: will subtract the given value from the value already present.\n- 3: will multiply the value already present by the given value.\n- 4: will divide the value already present by the given value.",
          "!type": "fn(child: +Object, key: +Array, value: +Object, operation: +Number, force: +Boolean) -> +Boolean"
        },
        "bounds": {
          "!doc": "Bound of this world that objects can not escape from.",
          "!type": "+Phaser.Rectangle"
        },
        "preUpdate": {
          "!doc": "The core preUpdate - as called by World.",
          "!type": "fn()"
        },
        "hash": {
          "!doc": "The hash array is an array belonging to this Group into which you can add any of its children via Group.addToHash and Group.removeFromHash.\n\nOnly children of this Group can be added to and removed from the hash.\n\nThis hash is used automatically by Phaser Arcade Physics in order to perform non z-index based destructive sorting.\nHowever if you don't use Arcade Physics, or this isn't a physics enabled Group, then you can use the hash to perform your own\nsorting and filtering of Group children without touching their z-index (and therefore display draw order)",
          "!type": "+Array"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "addToHash": {
          "!doc": "Adds a child of this Group into the hash array.\nThis call will return false if the child is not a child of this Group, or is already in the hash.",
          "!type": "fn(child: +DisplayObject) -> +Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "The alive property is useful for Groups that are children of other Groups and need to be included/excluded in checks like forEachAlive.",
          "!type": "+Boolean"
        },
        "checkProperty": {
          "!doc": "Checks a property for the given value on the child.",
          "!type": "fn(child: +Object, key: +Array, value: +Object, force: +Boolean) -> +Boolean"
        },
        "callbackFromArray": {
          "!doc": "Returns a reference to a function that exists on a child of the group based on the given callback array.",
          "!type": "fn(child: +Object, callback: +Array, length: +Number)"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "multiplyAll": {
          "!doc": "Multiplies the given property by the amount on all children in this group.\n\n`Group.multiplyAll('x', 2)` will x2 the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "getByName": {
          "!doc": "Searches the Group for the first instance of a child with the `name`\nproperty matching the given argument. Should more than one child have\nthe same name only the first instance is returned.",
          "!type": "fn(name: +String) -> +Object"
        },
        "angle": {
          "!doc": "The angle of rotation of the group container, in degrees.\n\nThis adjusts the group itself by modifying its local rotation transform.\n\nThis has no impact on the rotation/angle properties of the children, but it will update their worldTransform\nand on-screen orientation and position.",
          "!type": "+Number"
        },
        "camera": {
          "!doc": "Camera instance.",
          "!type": "+Phaser.Camera"
        },
        "iterate": {
          "!doc": "Iterates over the children of the group performing one of several actions for matched children.\n\nA child is considered a match when it has a property, named `key`, whose value is equal to `value`\naccording to a strict equality comparison.\n\nThe result depends on the `returnType`:\n\n- {@link Phaser.Group.RETURN_TOTAL RETURN_TOTAL}:\n    The callback, if any, is applied to all matching children. The number of matched children is returned.\n- {@link Phaser.Group.RETURN_NONE RETURN_NONE}:\n    The callback, if any, is applied to all matching children. No value is returned.\n- {@link Phaser.Group.RETURN_CHILD RETURN_CHILD}:\n    The callback, if any, is applied to the *first* matching child and the *first* matched child is returned.\n    If there is no matching child then null is returned.\n\nIf `args` is specified it must be an array. The matched child will be assigned to the first\nelement and the entire array will be applied to the callback function.",
          "!type": "fn(key: +String, value: +Object, returnType: +Number, callback: +Function, callbackContext: +Object, args: +Array._any_) -> +Object"
        },
        "onDestroy": {
          "!doc": "This signal is dispatched when the group is destroyed.",
          "!type": "+Phaser.Signal"
        },
        "set": {
          "!doc": "Quickly set a property on a single child of this group to a new value.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(child: +Phaser.Sprite, key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean) -> +Boolean"
        },
        "getFirstExists": {
          "!doc": "Get the first display object that exists, or doesn't exist.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if none matching your exists argument were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(exists: +Boolean, createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "reverse": {
          "!doc": "Reverses all children in this group.\n\nThis operation applies only to immediate children and does not propagate to subgroups.",
          "!type": "fn()"
        },
        "setBounds": {
          "!doc": "Updates the size of this world and sets World.x/y to the given values\nThe Camera bounds and Physics bounds (if set) are also updated to match the new World bounds.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number)"
        },
        "filter": {
          "!doc": "Find children matching a certain predicate.\n\nFor example:\n\n    var healthyList = Group.filter(function(child, index, children) {\n        return child.health > 10 ? true : false;\n    }, true);\n    healthyList.callAll('attack');\n\nNote: Currently this will skip any children which are Groups themselves.",
          "!type": "fn(predicate: +Function, checkExists: +Boolean) -> +Phaser.ArraySet"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "addAll": {
          "!doc": "Adds the amount to the given property on all children in this group.\n\n`Group.addAll('x', 10)` will add 10 to the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "width": {
          "!doc": "The defined width of the World. Sometimes the bounds needs to grow larger than this (if you resize the game) but this retains the original requested dimension.",
          "!type": "+Number"
        },
        "ignoreDestroy": {
          "!doc": "A group with `ignoreDestroy` set to `true` ignores all calls to its `destroy` method.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The x coordinate of the group container.\n\nYou can adjust the group container itself by modifying its coordinates.\nThis will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "If exists is true the group is updated, otherwise it is skipped.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The y coordinate of the group container.\n\nYou can adjust the group container itself by modifying its coordinates.\nThis will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z-depth value of this object within its parent container/Group - the World is a Group as well.\nThis value must be unique for each child in a Group.",
          "!type": "+Number"
        },
        "divideAll": {
          "!doc": "Divides the given property by the amount on all children in this group.\n\n`Group.divideAll('x', 2)` will half the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "setAllChildren": {
          "!doc": "Quickly set the same property across all children of this group, and any child Groups, to a new value.\n\nIf this group contains other Groups then the same property is set across their children as well, iterating down until it reaches the bottom.\nUnlike with `setAll` the property is NOT set on child Groups itself.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
        },
        "wrap": {
          "!doc": "This will take the given game object and check if its x/y coordinates fall outside of the world bounds.\nIf they do it will reposition the object to the opposite side of the world, creating a wrap-around effect.\nIf sprite has a P2 body then the body (sprite.body) should be passed as first parameter to the function.\n\nPlease understand there are limitations to this method. For example if you have scaled the World\nthen objects won't always be re-positioned correctly, and you'll need to employ your own wrapping function.",
          "!type": "fn(sprite: +Phaser.Sprite, padding: +Number, useBounds: +Boolean, horizontal: +Boolean, vertical: +Boolean)"
        },
        "physicsBodyType": {
          "!doc": "If {@link #enableBody} is true this is the type of physics body that is created on new Sprites.\n\nThe valid values are {@link Phaser.Physics.ARCADE}, {@link Phaser.Physics.P2JS}, {@link Phaser.Physics.NINJA}, etc.",
          "!type": "+Number"
        },
        "getIndex": {
          "!doc": "Get the index position of the given child in this group, which should match the child's `z` property.",
          "!type": "fn(child: +Object) -> +Number"
        },
        "getBottom": {
          "!doc": "Returns the child at the bottom of this group.\n\nThe bottom child the child being displayed (rendered) below every other child.",
          "!type": "fn() -> +Object"
        },
        "replace": {
          "!doc": "Replaces a child of this group with the given newChild. The newChild cannot be a member of this group.",
          "!type": "fn(oldChild: +Object, newChild: +Object) -> +Object"
        },
        "resetChild": {
          "!doc": "Takes a child and if the `x` and `y` arguments are given it calls `child.reset(x, y)` on it.\n\nIf the `key` and optionally the `frame` arguments are given, it calls `child.loadTexture(key, frame)` on it.\n\nThe two operations are separate. For example if you just wish to load a new texture then pass `null` as the x and y values.",
          "!type": "fn(child: +DisplayObject, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "getRandom": {
          "!doc": "Returns a random child from the group.",
          "!type": "fn(startIndex: +Number, length: +Number) -> +Object"
        },
        "forEachExists": {
          "!doc": "Call a function on each existing child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "getTop": {
          "!doc": "Return the child at the top of this group.\n\nThe top child is the child displayed (rendered) above every other child.",
          "!type": "fn() -> +Object"
        },
        "create": {
          "!doc": "Creates a new Phaser.Sprite object and adds it to the top of this group.\n\nUse {@link #classType} to change the type of object created.",
          "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String, exists: +Boolean) -> +PIXI.DisplayObject"
        },
        "countDead": {
          "!doc": "Get the number of dead children in this group.",
          "!type": "fn() -> +Number"
        },
        "subAll": {
          "!doc": "Subtracts the amount from the given property on all children in this group.\n\n`Group.subAll('x', 10)` will minus 10 from the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "fixedToCamera": {
          "!doc": "A Group that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Group.cameraOffset.\n\nNote that the cameraOffset values are in addition to any parent in the display list.\nSo if this Group was in a Group that has x: 200, then this will be added to the cameraOffset.x",
          "!type": "+Boolean"
        },
        "add": {
          "!doc": "Adds an existing object as the top child in this group.\n\nThe child is automatically added to the top of the group and is displayed on top of every previous child.\n\nIf Group.enableBody is set then a physics body will be created on the object, so long as one does not already exist.\n\nUse {@link #addAt} to control where a child is added. Use {@link #create} to create and add a new child.",
          "!type": "fn(child: +DisplayObject, silent: +Boolean) -> +PIXI.DisplayObject"
        },
        "visible": {
          "!doc": "The visible state of the group. Non-visible Groups and all of their children are not rendered.",
          "!type": "+Boolean"
        },
        "swap": {
          "!doc": "Swaps the position of two children in this group.\n\nBoth children must be in this group, a child cannot be swapped with itself, and unparented children cannot be swapped.",
          "!type": "fn(child1: +Object, child2: +Object)"
        },
        "cameraOffset": {
          "!doc": "If this object is {@link #fixedToCamera} then this stores the x/y position offset relative to the top-left of the camera view.\nIf the parent of this Group is also `fixedToCamera` then the offset here is in addition to that and should typically be disabled.",
          "!type": "+Phaser.Point"
        },
        "stateChange": {
          "!doc": "Called whenever the State changes or resets.\n\nIt resets the world.x and world.y coordinates back to zero,\nthen resets the Camera.",
          "!type": "fn()"
        },
        "sort": {
          "!doc": "Sort the children in the group according to a particular key and ordering.\n\nCall this function to sort the group according to a particular key value and order.\n\nFor example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.\n\nInternally this uses a standard JavaScript Array sort, so everything that applies there also applies here, including\nalphabetical sorting, mixing strings and numbers, and Unicode sorting. See MDN for more details.",
          "!type": "fn(key: +String, order: +Number)"
        },
        "moveDown": {
          "!doc": "Moves the given child down one place in this group unless it's already at the bottom.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "hasProperty": {
          "!doc": "Checks if the child has the given property.\n\nWill scan up to 4 levels deep only.",
          "!type": "fn(child: +Object, key: +Array._string_) -> +Boolean"
        },
        "updateZ": {
          "!doc": "Internal method that re-applies all of the children's Z values.\n\nThis must be called whenever children ordering is altered so that their `z` indices are correctly updated.",
          "!type": "fn()"
        },
        "name": {
          "!doc": "A name for this group. Not used internally but useful for debugging.",
          "!type": "+String"
        },
        "ascendingSortHandler": {
          "!doc": "An internal helper function for the sort process.",
          "!type": "fn(a: +Object, b: +Object)"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "removeBetween": {
          "!doc": "Removes all children from this group whose index falls beteen the given startIndex and endIndex values.",
          "!type": "fn(startIndex: +Number, endIndex: +Number, destroy: +Boolean, silent: +Boolean)"
        },
        "randomX": {
          "!doc": "Gets a random integer which is lesser than or equal to the current width of the game world.",
          "!type": "+Number"
        },
        "removeFromHash": {
          "!doc": "Removes a child of this Group from the hash array.\nThis call will return false if the child is not in the hash.",
          "!type": "fn(child: +DisplayObject) -> +Boolean"
        },
        "shutdown": {
          "!doc": "Destroyer of worlds.",
          "!type": "fn()"
        },
        "classType": {
          "!doc": "The type of objects that will be created when using {@link #create} or {@link #createMultiple}.\n\nAny object may be used but it should extend either Sprite or Image and accept the same constructor arguments:\nwhen a new object is created it is passed the following parameters to its constructor: `(game, x, y, key, frame)`.",
          "!type": "+Object"
        },
        "randomY": {
          "!doc": "Gets a random integer which is lesser than or equal to the current height of the game world.",
          "!type": "+Number"
        },
        "next": {
          "!doc": "Advances the group cursor to the next (higher) object in the group.\n\nIf the cursor is at the end of the group (top child) it is moved the start of the group (bottom child).",
          "!type": "fn() -> +Object"
        },
        "cursor": {
          "!doc": "The current display object that the group cursor is pointing to, if any. (Can be set manually.)\n\nThe cursor is a way to iterate through the children in a Group using {@link #next} and {@link #previous}.",
          "!type": "+PIXI.DisplayObject"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "forEachDead": {
          "!doc": "Call a function on each dead child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "update": {
          "!doc": "The core update - as called by World.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "countLiving": {
          "!doc": "Get the number of living children in this group.",
          "!type": "fn() -> +Number"
        },
        "remove": {
          "!doc": "Removes the given child from this group.\n\nThis will dispatch an `onRemovedFromGroup` event from the child (if it has one), and optionally destroy the child.\n\nIf the group cursor was referring to the removed child it is updated to refer to the next child.",
          "!type": "fn(child: +Object, destroy: +Boolean, silent: +Boolean) -> +Boolean"
        },
        "callAll": {
          "!doc": "Calls a function, specified by name, on all on children.\n\nThe function is called for all children regardless if they are dead or alive (see callAllExists for different options).\nAfter the method parameter and context you can add as many extra parameters as you like, which will all be passed to the child.",
          "!type": "fn(method: +String, context: +String, args: +Object)"
        },
        "total": {
          "!doc": "Total number of existing children in the group.",
          "!type": "+Number"
        },
        "alpha": {
          "!doc": "The alpha value of the group container.",
          "!type": "+Number"
        },
        "createMultiple": {
          "!doc": "Creates multiple Phaser.Sprite objects and adds them to the top of this group.\n\nUseful if you need to quickly generate a pool of identical sprites, such as bullets.\n\nBy default the sprites will be set to not exist and will be positioned at 0, 0 (relative to the group.x/y).\nUse {@link #classType} to change the type of object created.",
          "!type": "fn(quantity: +Number, key: +String, frame: +Number, exists: +Boolean)"
        },
        "boot": {
          "!doc": "Initialises the game world.",
          "!type": "fn()"
        },
        "setAll": {
          "!doc": "Quickly set the same property across all children of this group to a new value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be set on the group but not its children.\nIf you need that ability please see `Group.setAllChildren`.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
        },
        "callAllExists": {
          "!doc": "Calls a function, specified by name, on all children in the group who exist (or do not exist).\n\nAfter the existsValue parameter you can add as many parameters as you like, which will all be passed to the child callback.",
          "!type": "fn(callback: +String, existsValue: +Boolean, parameter: +Object)"
        },
        "checkAll": {
          "!doc": "Quickly check that the same property across all children of this group is equal to the given value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be checked on the group but not its children.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, force: +Boolean)"
        },
        "previous": {
          "!doc": "Moves the group cursor to the previous (lower) child in the group.\n\nIf the cursor is at the start of the group (bottom child) it is moved to the end (top child).",
          "!type": "fn() -> +Object"
        },
        "forEach": {
          "!doc": "Call a function on each child in this group.\n\nAdditional arguments for the callback can be specified after the `checkExists` parameter. For example,\n\n    Group.forEach(awardBonusGold, this, true, 100, 500)\n\nwould invoke `awardBonusGold` function with the parameters `(child, 100, 500)`.\n\nNote: This check will skip any children which are Groups themselves.",
          "!type": "fn(callback: +Function, callbackContext: +Object, checkExists: +Boolean, args: +Object)"
        },
        "rotation": {
          "!doc": "The angle of rotation of the group container, in radians.\n\nThis will adjust the group container itself by modifying its rotation.\nThis will have no impact on the rotation value of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "length": {
          "!doc": "Total number of children in this group, regardless of exists/alive status.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends the given child to the bottom of this group so it renders below all other children.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "getAt": {
          "!doc": "Returns the child found at the given index within this group.",
          "!type": "fn(index: +Number) -> +PIXI.DisplayObject"
        },
        "pendingDestroy": {
          "!doc": "A Group is that has `pendingDestroy` set to `true` is flagged to have its destroy method \ncalled on the next logic update.\nYou can set it directly to flag the Group to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy a Group from within one of its own callbacks \nor a callback of one of its children.",
          "!type": "+Boolean"
        },
        "getFirstAlive": {
          "!doc": "Get the first child that is alive (`child.alive === true`).\n\nThis is handy for choosing a squad leader, etc.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no alive ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "resize": {
          "!doc": "Updates the size of this world. Note that this doesn't modify the world x/y coordinates, just the width and height.",
          "!type": "fn(width: +Number, height: +Number)"
        }
      }
    },
    "WEBGL_FILTER": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Input": {
      "TOUCH_OVERRIDES_MOUSE": "+Number",
      "MAX_POINTERS": "+Number",
      "!doc": "Phaser.Input is the Input Manager for all types of Input across Phaser, including mouse, keyboard, touch and MSPointer.\nThe Input manager is updated automatically by the core game loop.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "addPointer": {
          "!doc": "Add a new Pointer object to the Input Manager.\nBy default Input creates 3 pointer objects: `mousePointer` (not include in part of general pointer pool), `pointer1` and `pointer2`.\nThis method adds an additional pointer, up to a maximum of Phaser.Input.MAX_POINTERS (default of 10).",
          "!type": "fn() -> +Phaser.Pointer"
        },
        "pollRate": {
          "!doc": "How often should the input pointers be checked for updates? A value of 0 means every single frame (60fps); a value of 1 means every other frame (30fps) and so on.",
          "!type": "+Number"
        },
        "recordPointerHistory": {
          "!doc": "Sets if the Pointer objects should record a history of x/y coordinates they have passed through.\nThe history is cleared each time the Pointer is pressed down.\nThe history is updated at the rate specified in Input.pollRate",
          "!type": "+Boolean"
        },
        "activePointer": {
          "!doc": "The most recently active Pointer object.\n\nWhen you've limited max pointers to 1 this will accurately be either the first finger touched or mouse.",
          "!type": "+Phaser.Pointer"
        },
        "addMoveCallback": {
          "!doc": "Adds a callback that is fired every time the activePointer receives a DOM move event such as a mousemove or touchmove.\n\nThe callback will be sent 4 parameters: The Pointer that moved, the x position of the pointer, the y position and the down state.\n\nIt will be called every time the activePointer moves, which in a multi-touch game can be a lot of times, so this is best\nto only use if you've limited input to a single pointer (i.e. mouse or touch).\n\nThe callback is added to the Phaser.Input.moveCallbacks array and should be removed with Phaser.Input.deleteMoveCallback.",
          "!type": "fn(callback: +Function, context: +Object)"
        },
        "tapRate": {
          "!doc": "The number of milliseconds that the Pointer has to be pressed down and then released to be considered a tap or click.",
          "!type": "+Number"
        },
        "resetLocked": {
          "!doc": "If the Input Manager has been reset locked then all calls made to InputManager.reset, \nsuch as from a State change, are ignored.",
          "!type": "+Boolean"
        },
        "onTap": {
          "!doc": "A Signal that is dispatched each time a pointer is tapped.",
          "!type": "+Phaser.Signal"
        },
        "multiInputOverride": {
          "!doc": "Controls the expected behavior when using a mouse and touch together on a multi-input device.",
          "!type": "+Number"
        },
        "hitCanvas": {
          "!doc": "The canvas to which single pixels are drawn in order to perform pixel-perfect hit detection.",
          "!type": "+HTMLCanvasElement"
        },
        "mouse": {
          "!doc": "The Mouse Input manager.\n\nYou should not usually access this manager directly, but instead use Input.mousePointer or Input.activePointer \nwhich normalizes all the input values for you, regardless of browser.",
          "!type": "+Phaser.Mouse"
        },
        "mousePointer": {
          "!doc": "The mouse has its own unique Phaser.Pointer object which you can use if making a desktop specific game.",
          "!type": "+Phaser.Pointer"
        },
        "moveCallbacks": {
          "!doc": "An array of callbacks that will be fired every time the activePointer receives a move event from the DOM.\nTo add a callback to this array please use `Input.addMoveCallback`.",
          "!type": "+Array"
        },
        "getPointerFromIdentifier": {
          "!doc": "Get the Pointer object whos `identifier` property matches the given identifier value.\n\nThe identifier property is not set until the Pointer has been used at least once, as its populated by the DOM event.\nAlso it can change every time you press the pointer down, and is not fixed once set.\nNote: Not all browsers set the identifier property and it's not part of the W3C spec, so you may need getPointerFromId instead.",
          "!type": "fn(identifier: +Number) -> +Phaser.Pointer"
        },
        "recordRate": {
          "!doc": "The rate in milliseconds at which the Pointer objects should update their tracking history.",
          "!type": "+Number"
        },
        "pointers": {
          "!doc": "An array of non-mouse pointers that have been added to the game.\nThe properties `pointer1..N` are aliases for `pointers[0..N-1]`.",
          "!type": "+Array._Phaser.Pointer_"
        },
        "recordLimit": {
          "!doc": "The total number of entries that can be recorded into the Pointer objects tracking history.\nIf the Pointer is tracking one event every 100ms; then a trackLimit of 100 would store the last 10 seconds worth of history.",
          "!type": "+Number"
        },
        "onHold": {
          "!doc": "A Signal that is dispatched each time a pointer is held down.",
          "!type": "+Phaser.Signal"
        },
        "destroy": {
          "!doc": "Stops all of the Input Managers from running.",
          "!type": "fn()"
        },
        "touch": {
          "!doc": "The Touch Input manager.\n\nYou should not usually access this manager directly, but instead use Input.activePointer \nwhich normalizes all the input values for you, regardless of browser.",
          "!type": "+Phaser.Touch"
        },
        "getPointerFromId": {
          "!doc": "Get the Pointer object whos `pointerId` property matches the given value.\n\nThe pointerId property is not set until the Pointer has been used at least once, as its populated by the DOM event.\nAlso it can change every time you press the pointer down if the browser recycles it.",
          "!type": "fn(pointerId: +Number) -> +Phaser.Pointer"
        },
        "maxPointers": {
          "!doc": "The maximum number of Pointers allowed to be active at any one time. A value of -1 is only limited by the total number of pointers. For lots of games it's useful to set this to 1.",
          "!type": "+Number"
        },
        "gamepad": {
          "!doc": "The Gamepad Input manager.",
          "!type": "+Phaser.Gamepad"
        },
        "totalInactivePointers": {
          "!doc": "The total number of inactive Pointers.",
          "!type": "+Number"
        },
        "reset": {
          "!doc": "Reset all of the Pointers and Input states.\n\nThe optional `hard` parameter will reset any events or callbacks that may be bound.\nInput.reset is called automatically during a State change or if a game loses focus / visibility.\nTo control control the reset manually set {@link Phaser.InputManager.resetLocked} to `true`.",
          "!type": "fn(hard: +Boolean)"
        },
        "onDown": {
          "!doc": "A Signal that is dispatched each time a pointer is pressed down.",
          "!type": "+Phaser.Signal"
        },
        "position": {
          "!doc": "A point object representing the current position of the Pointer.",
          "!type": "+Phaser.Point"
        },
        "circle": {
          "!doc": "A Circle object centered on the x/y screen coordinates of the Input.\nDefault size of 44px (Apples recommended \"finger tip\" size) but can be changed to anything.",
          "!type": "+Phaser.Circle"
        },
        "minPriorityID": {
          "!doc": "You can tell all Pointers to ignore any Game Object with a `priorityID` lower than this value.\nThis is useful when stacking UI layers. Set to zero to disable.",
          "!type": "+Number"
        },
        "mspointer": {
          "!doc": "The MSPointer Input manager.\n\nYou should not usually access this manager directly, but instead use Input.activePointer \nwhich normalizes all the input values for you, regardless of browser.",
          "!type": "+Phaser.MSPointer"
        },
        "updatePointer": {
          "!doc": "Updates the matching Pointer object, passing in the event data.\nThis is called automatically and should not normally need to be invoked.",
          "!type": "fn(event: +Object) -> +Phaser.Pointer"
        },
        "pollLocked": {
          "!doc": "True if the Input is currently poll rate locked.",
          "!type": "+Boolean"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "getLocalPosition": {
          "!doc": "This will return the local coordinates of the specified displayObject based on the given Pointer.",
          "!type": "fn(displayObject: +Phaser.Sprite, pointer: +Phaser.Pointer) -> +Phaser.Point"
        },
        "hitContext": {
          "!doc": "The context of the pixel perfect hit canvas.",
          "!type": "+CanvasRenderingContext2D"
        },
        "justReleasedRate": {
          "!doc": "The number of milliseconds below which the Pointer is considered justReleased .",
          "!type": "+Number"
        },
        "justPressedRate": {
          "!doc": "The number of milliseconds below which the Pointer is considered justPressed.",
          "!type": "+Number"
        },
        "update": {
          "!doc": "Updates the Input Manager. Called by the core Game loop.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale by which all input coordinates are multiplied; calculated by the ScaleManager. In an un-scaled game the values will be x = 1 and y = 1.",
          "!type": "+Phaser.Point"
        },
        "enabled": {
          "!doc": "When enabled, input (eg. Keyboard, Mouse, Touch) will be processed - as long as the individual sources are enabled themselves.\n\nWhen not enabled, _all_ input sources are ignored. To disable just one type of input; for example, the Mouse, use `input.mouse.enabled = false`.",
          "!type": "+Boolean"
        },
        "speed": {
          "!doc": "A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.",
          "!type": "+Phaser.Point"
        },
        "resetSpeed": {
          "!doc": "Resets the speed and old position properties.",
          "!type": "fn(x: +Number, y: +Number)"
        },
        "stopPointer": {
          "!doc": "Stops the matching Pointer object, passing in the event data.",
          "!type": "fn(event: +Object) -> +Phaser.Pointer"
        },
        "pointer5": {
          "!doc": "A Pointer object.",
          "!type": "+Phaser.Pointer"
        },
        "pointer6": {
          "!doc": "A Pointer object.",
          "!type": "+Phaser.Pointer"
        },
        "pointer7": {
          "!doc": "A Pointer object.",
          "!type": "+Phaser.Pointer"
        },
        "pointer8": {
          "!doc": "A Pointer object.",
          "!type": "+Phaser.Pointer"
        },
        "deleteMoveCallback": {
          "!doc": "Removes the callback from the Phaser.Input.moveCallbacks array.",
          "!type": "fn(callback: +Function, context: +Object)"
        },
        "pointer9": {
          "!doc": "A Pointer object.",
          "!type": "+Phaser.Pointer"
        },
        "pointer10": {
          "!doc": "A Pointer object.",
          "!type": "+Phaser.Pointer"
        },
        "boot": {
          "!doc": "Starts the Input Manager running.",
          "!type": "fn()"
        },
        "pointer1": {
          "!doc": "A Pointer object.",
          "!type": "+Phaser.Pointer"
        },
        "pointer2": {
          "!doc": "A Pointer object.",
          "!type": "+Phaser.Pointer"
        },
        "pointer3": {
          "!doc": "A Pointer object.",
          "!type": "+Phaser.Pointer"
        },
        "pointer4": {
          "!doc": "A Pointer object.",
          "!type": "+Phaser.Pointer"
        },
        "startPointer": {
          "!doc": "Find the first free Pointer object and start it, passing in the event data.\nThis is called automatically by Phaser.Touch and Phaser.MSPointer.",
          "!type": "fn(event: +Object) -> +Phaser.Pointer"
        },
        "keyboard": {
          "!doc": "The Keyboard Input manager.",
          "!type": "+Phaser.Keyboard"
        },
        "doubleTapRate": {
          "!doc": "The number of milliseconds between taps of the same Pointer for it to be considered a double tap / click.",
          "!type": "+Number"
        },
        "worldX": {
          "!doc": "The world X coordinate of the most recently active pointer.",
          "!type": "+Number"
        },
        "worldY": {
          "!doc": "The world Y coordinate of the most recently active pointer.",
          "!type": "+Number"
        },
        "totalActivePointers": {
          "!doc": "The total number of active Pointers, not counting the mouse pointer.",
          "!type": "+integers"
        },
        "getPointer": {
          "!doc": "Get the first Pointer with the given active state.",
          "!type": "fn(isActive: +Boolean) -> +Phaser.Pointer"
        },
        "onUp": {
          "!doc": "A Signal that is dispatched each time a pointer is released.",
          "!type": "+Phaser.Signal"
        },
        "interactiveItems": {
          "!doc": "A list of interactive objects. The InputHandler components add and remove themselves from this list.",
          "!type": "+Phaser.ArraySet"
        },
        "x": {
          "!doc": "The X coordinate of the most recently active pointer.\nThis value takes game scaling into account automatically. See Pointer.screenX/clientX for source values.",
          "!type": "+Number"
        },
        "y": {
          "!doc": "The Y coordinate of the most recently active pointer.\nThis value takes game scaling into account automatically. See Pointer.screenY/clientY for source values.",
          "!type": "+Number"
        },
        "hitTest": {
          "!doc": "Tests if the pointer hits the given object.",
          "!type": "fn(displayObject: +DisplayObject, pointer: +Phaser.Pointer, localPoint: +Phaser.Point)"
        },
        "holdRate": {
          "!doc": "The number of milliseconds that the Pointer has to be pressed down for it to fire a onHold event.",
          "!type": "+Number"
        }
      },
      "MOUSE_TOUCH_COMBINE": "+Number",
      "MOUSE_OVERRIDES_TOUCH": "+Number"
    },
    "AudioSprite": {
      "!doc": "Audio Sprites are a combination of audio files and a JSON configuration.\nThe JSON follows the format of that created by https://github.com/tonistiigi/audiosprite",
      "!type": "fn(game: +Phaser.Game, key: +String)",
      "prototype": {
        "play": {
          "!doc": "Play a sound with the given name.",
          "!type": "fn(marker: +String, volume: +Number) -> +Phaser.Sound"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "stop": {
          "!doc": "Stop a sound with the given name.",
          "!type": "fn(marker: +String)"
        },
        "sounds": {
          "!doc": "An object containing the Phaser.Sound objects for the Audio Sprite.",
          "!type": "+Object"
        },
        "get": {
          "!doc": "Get a sound with the given name.",
          "!type": "fn(marker: +String) -> +Phaser.Sound"
        },
        "config": {
          "!doc": "JSON audio atlas object.",
          "!type": "+Object"
        },
        "autoplayKey": {
          "!doc": "If a sound is set to auto play, this holds the marker key of it.",
          "!type": "+String"
        },
        "key": {
          "!doc": "Asset key for the Audio Sprite.",
          "!type": "+String"
        },
        "autoplay": {
          "!doc": "Is a sound set to autoplay or not?",
          "!type": "+Boolean"
        }
      }
    },
    "Camera": {
      "FOLLOW_PLATFORMER": "+Number",
      "!doc": "A Camera is your view into the game world. It has a position and size and renders only those objects within its field of view.\nThe game automatically creates a single Stage sized camera on boot. Move the camera around the world with Phaser.Camera.x/y",
      "FOLLOW_TOPDOWN": "+Number",
      "!type": "fn(game: +Phaser.Game, id: +Number, x: +Number, y: +Number, width: +Number, height: +Number)",
      "SHAKE_BOTH": "+Number",
      "ENABLE_FX": "+Boolean",
      "prototype": {
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "shake": {
          "!doc": "This creates a camera shake effect. It works by applying a random amount of additional\nspacing on the x and y axis each frame. You can control the intensity and duration\nof the effect, and if it should effect both axis or just one.\n\nWhen the shake effect ends the signal Camera.onShakeComplete is dispatched.",
          "!type": "fn(intensity: +float, duration: +Number, force: +Boolean, direction: +Number, shakeBounds: +Boolean) -> +Boolean"
        },
        "resetFX": {
          "!doc": "Resets any active FX, such as a fade or flash and immediately clears it.\nUseful to calling after a fade in order to remove the fade from the Stage.",
          "!type": "fn()"
        },
        "lerp": {
          "!doc": "The linear interpolation value to use when following a target.\nThe default values of 1 means the camera will instantly snap to the target coordinates.\nA lower value, such as 0.1 means the camera will more slowly track the target, giving\na smooth transition. You can set the horizontal and vertical values independently, and also\nadjust this value in real-time during your game.",
          "!type": "+Phaser.Point"
        },
        "atLimit": {
          "!doc": "Whether this camera is flush with the World Bounds or not.",
          "!type": "+Boolean"
        },
        "focusOnXY": {
          "!doc": "Move the camera focus on a location instantly.",
          "!type": "fn(x: +Number, y: +Number)"
        },
        "update": {
          "!doc": "The camera update loop. This is called automatically by the core game loop.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale of the display object to which all game objects are added. Set by World.boot.",
          "!type": "+Phaser.Point"
        },
        "setPosition": {
          "!doc": "A helper function to set both the X and Y properties of the camera at once\nwithout having to use game.camera.x and game.camera.y.",
          "!type": "fn(x: +Number, y: +Number)"
        },
        "onShakeComplete": {
          "!doc": "This signal is dispatched when the camera shake effect completes.",
          "!type": "+Phaser.Signal"
        },
        "view": {
          "!doc": "Camera view.\nThe view into the world we wish to render (by default the game dimensions).\nThe x/y values are in world coordinates, not screen coordinates, the width/height is how many pixels to render.\nSprites outside of this view are not rendered if Sprite.autoCull is set to `true`. Otherwise they are always rendered.",
          "!type": "+Phaser.Rectangle"
        },
        "fx": {
          "!doc": "The Graphics object used to handle camera fx such as fade and flash.",
          "!type": "+Phaser.Graphics"
        },
        "fade": {
          "!doc": "This creates a camera fade effect. It works by filling the game with the \ncolor specified, over the duration given, ending with a solid fill.\n\nYou can use this for things such as transitioning to a new scene.\n\nThe game will be left 'filled' at the end of this effect, likely obscuring\neverything. In order to reset it you can call `Camera.resetFX` and it will clear the\nfade. Or you can call `Camera.flash` with the same color as the fade, and it will\nreverse the process, bringing the game back into view again.\n\nWhen the effect ends the signal Camera.onFadeComplete is dispatched.",
          "!type": "fn(color: +numer, duration: +Number, force: +Boolean) -> +Boolean"
        },
        "setSize": {
          "!doc": "Sets the size of the view rectangle given the width and height in parameters.",
          "!type": "fn(width: +Number, height: +Number)"
        },
        "world": {
          "!doc": "A reference to the game world.",
          "!type": "+Phaser.World"
        },
        "checkBounds": {
          "!doc": "Method called to ensure the camera doesn't venture outside of the game world.\nCalled automatically by Camera.update.",
          "!type": "fn()"
        },
        "onFadeComplete": {
          "!doc": "This signal is dispatched when the camera fade effect completes.\nWhen the fade effect completes you will be left with the screen black (or whatever\ncolor you faded to). In order to reset this call `Camera.resetFX`. This is called\nautomatically when you change State.",
          "!type": "+Phaser.Signal"
        },
        "focusOn": {
          "!doc": "Move the camera focus on a display object instantly.",
          "!type": "fn(displayObject: +Object)"
        },
        "id": {
          "!doc": "Reserved for future multiple camera set-ups.",
          "!type": "+Number"
        },
        "deadzone": {
          "!doc": "Moving inside this Rectangle will not cause the camera to move.",
          "!type": "+Phaser.Rectangle"
        },
        "height": {
          "!doc": "Gets or sets the cameras height.",
          "!type": "+Number"
        },
        "roundPx": {
          "!doc": "If a Camera has roundPx set to `true` it will call `view.floor` as part of its update loop, keeping its boundary to integer values. Set this to `false` to disable this from happening.",
          "!type": "+Boolean"
        },
        "visible": {
          "!doc": "Whether this camera is visible or not.",
          "!type": "+Boolean"
        },
        "follow": {
          "!doc": "Tell the camera which sprite to follow.\n\nYou can set the follow type and a linear interpolation value.\nUse low lerp values (such as 0.1) to automatically smooth the camera motion.\n\nIf you find you're getting a slight \"jitter\" effect when following a Sprite it's probably to do with sub-pixel rendering of the Sprite position.\nThis can be disabled by setting `game.renderer.renderSession.roundPixels = true` to force full pixel rendering.",
          "!type": "fn(target: +Phaser.Sprite, style: +Number, lerpX: +float, lerpY: +float)"
        },
        "onFlashComplete": {
          "!doc": "This signal is dispatched when the camera flash effect completes.",
          "!type": "+Phaser.Signal"
        },
        "setBoundsToWorld": {
          "!doc": "Update the Camera bounds to match the game world.",
          "!type": "fn()"
        },
        "target": {
          "!doc": "If the camera is tracking a Sprite, this is a reference to it, otherwise null.",
          "!type": "+Phaser.Sprite"
        },
        "displayObject": {
          "!doc": "The display object to which all game objects are added. Set by World.boot.",
          "!type": "+PIXI.DisplayObject"
        },
        "bounds": {
          "!doc": "The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.",
          "!type": "+Phaser.Rectangle"
        },
        "totalInView": {
          "!doc": "The total number of Sprites with `autoCull` set to `true` that are visible by this Camera.",
          "!type": "+Number"
        },
        "x": {
          "!doc": "Gets or sets the cameras x position.",
          "!type": "+Number"
        },
        "width": {
          "!doc": "Gets or sets the cameras width.",
          "!type": "+Number"
        },
        "reset": {
          "!doc": "Resets the camera back to 0,0 and un-follows any object it may have been tracking.\nAlso immediately resets any camera effects that may have been running such as\nshake, flash or fade.",
          "!type": "fn()"
        },
        "y": {
          "!doc": "Gets or sets the cameras y position.",
          "!type": "+Number"
        },
        "position": {
          "!doc": "Gets or sets the cameras xy position using Phaser.Point object.",
          "!type": "+Phaser.Point"
        },
        "preUpdate": {
          "!doc": "Camera preUpdate. Sets the total view counter to zero.",
          "!type": "fn()"
        },
        "unfollow": {
          "!doc": "Sets the Camera follow target to null, stopping it from following an object if it's doing so.",
          "!type": "fn()"
        },
        "flash": {
          "!doc": "This creates a camera flash effect. It works by filling the game with the solid fill\ncolor specified, and then fading it away to alpha 0 over the duration given.\n\nYou can use this for things such as hit feedback effects.\n\nWhen the effect ends the signal Camera.onFlashComplete is dispatched.",
          "!type": "fn(color: +numer, duration: +Number, force: +Boolean) -> +Boolean"
        }
      },
      "FOLLOW_LOCKON": "+Number",
      "SHAKE_HORIZONTAL": "+Number",
      "SHAKE_VERTICAL": "+Number",
      "FOLLOW_TOPDOWN_TIGHT": "+Number"
    },
    "UP": {
      "!doc": "Direction constant.",
      "!type": "+Number"
    },
    "Tween": {
      "!doc": "A Tween allows you to alter one or more properties of a target object over a defined period of time.\nThis can be used for things such as alpha fading Sprites, scaling them or motion.\nUse `Tween.to` or `Tween.from` to set-up the tween values. You can create multiple tweens on the same object\nby calling Tween.to multiple times on the same Tween. Additional tweens specified in this way become \"child\" tweens and\nare played through in sequence. You can use Tween.timeScale and Tween.reverse to control the playback of this Tween and all of its children.",
      "!type": "fn(target: +Object, game: +Phaser.Game, manager: +Phaser.TweenManager)",
      "prototype": {
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "timeScale": {
          "!doc": "The speed at which the tweens will run. A value of 1 means it will match the game frame rate. 0.5 will run at half the frame rate. 2 at double the frame rate, etc.\nIf a tweens duration is 1 second but timeScale is 0.5 then it will take 2 seconds to complete.",
          "!type": "+Number"
        },
        "update": {
          "!doc": "Core tween update function called by the TweenManager. Does not need to be invoked directly.",
          "!type": "fn(time: +Number) -> +Boolean"
        },
        "updateTweenData": {
          "!doc": "Updates either a single TweenData or all TweenData objects properties to the given value.\nUsed internally by methods like Tween.delay, Tween.yoyo, etc. but can also be called directly if you know which property you want to tweak.\nThe property is not checked, so if you pass an invalid one you'll generate a run-time error.",
          "!type": "fn(property: +String, value: +Number, index: +Number) -> +Phaser.Tween"
        },
        "onUpdateCallback": {
          "!doc": "Sets a callback to be fired each time this tween updates.",
          "!type": "fn(callback: +Function, callbackContext: +Object) -> +Phaser.Tween"
        },
        "easing": {
          "!doc": "Set easing function this tween will use, i.e. Phaser.Easing.Linear.None.\nThe ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as \"Circ\".\n\".easeIn\", \".easeOut\" and \"easeInOut\" variants are all supported for all ease types.\nIf you have child tweens and pass -1 as the index value it sets the easing function defined here across all of them.",
          "!type": "fn(ease: +Function, index: +Number) -> +Phaser.Tween"
        },
        "current": {
          "!doc": "The current Tween child being run.",
          "!type": "+Number"
        },
        "yoyoDelay": {
          "!doc": "Sets the delay in milliseconds before this tween will run a yoyo (only applies if yoyo is enabled).\nThe repeatDelay is invoked as soon as you call `Tween.start`. If the tween is already running this method doesn't do anything for the current active tween.\nIf you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to set repeatDelay on.\nIf you have child tweens and pass -1 as the index value it sets the repeatDelay across all of them.",
          "!type": "fn(duration: +Number, index: +Number) -> +Phaser.Tween"
        },
        "onStart": {
          "!doc": "The onStart event is fired when the Tween begins. If there is a delay before the tween starts then onStart fires after the delay is finished.\nIt will be sent 2 parameters: the target object and this tween.",
          "!type": "+Phaser.Signal"
        },
        "yoyo": {
          "!doc": "A Tween that has yoyo set to true will run through from its starting values to its end values and then play back in reverse from end to start.\nUsed in combination with repeat you can create endless loops.\nIf you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to yoyo.\nIf you have child tweens and pass -1 as the index value it sets the yoyo property across all of them.\nIf you wish to yoyo this Tween and all of its children then see Tween.yoyoAll.",
          "!type": "fn(enable: +Boolean, yoyoDelay: +Number, index: +Number) -> +Phaser.Tween"
        },
        "isRunning": {
          "!doc": "If the tween is running this is set to true, otherwise false. Tweens that are in a delayed state or waiting to start are considered as being running.",
          "!type": "+Boolean"
        },
        "loop": {
          "!doc": "Enables the looping of this tween. The tween will loop forever, and onComplete will never fire.\n\nIf `value` is `true` then this is the same as setting `Tween.repeatAll(-1)`.\nIf `value` is `false` it is the same as setting `Tween.repeatAll(0)` and will reset the `repeatCounter` to zero.\n\nUsage:\ngame.add.tween(p).to({ x: 700 }, 1000, Phaser.Easing.Linear.None, true)\n.to({ y: 300 }, 1000, Phaser.Easing.Linear.None)\n.to({ x: 0 }, 1000, Phaser.Easing.Linear.None)\n.to({ y: 0 }, 1000, Phaser.Easing.Linear.None)\n.loop();",
          "!type": "fn(value: +Boolean) -> +Phaser.Tween"
        },
        "repeat": {
          "!doc": "Sets the number of times this tween will repeat.\nIf you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to repeat.\nIf you have child tweens and pass -1 as the index value it sets the number of times they'll repeat across all of them.\nIf you wish to define how many times this Tween and all children will repeat see Tween.repeatAll.",
          "!type": "fn(total: +Number, repeat: +Number, index: +Number) -> +Phaser.Tween"
        },
        "generateData": {
          "!doc": "This will generate an array populated with the tweened object values from start to end.\nIt works by running the tween simulation at the given frame rate based on the values set-up in Tween.to and Tween.from.\nIt ignores delay and repeat counts and any chained tweens, but does include child tweens.\nJust one play through of the tween data is returned, including yoyo if set.",
          "!type": "fn(frameRate: +Number, data: +Array) -> +Array"
        },
        "from": {
          "!doc": "Sets this tween to be a `from` tween on the properties given. A `from` tween sets the target to the destination value and tweens to its current value.\nFor example a Sprite with an `x` coordinate of 100 tweened from `x` 500 would be set to `x` 500 and then tweened to `x` 100 by giving a properties object of `{ x: 500 }`.\nThe ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as \"Circ\".\n\".easeIn\", \".easeOut\" and \"easeInOut\" variants are all supported for all ease types.",
          "!type": "fn(properties: +Object, duration: +Number, ease: +Function, autoStart: +Boolean, delay: +Number, repeat: +Number, yoyo: +Boolean) -> +Phaser.Tween"
        },
        "onRepeat": {
          "!doc": "The onRepeat event is fired if the Tween and all of its children repeats. If this tween has no children this will never be fired.\nIt will be sent 2 parameters: the target object and this tween.",
          "!type": "+Phaser.Signal"
        },
        "repeatDelay": {
          "!doc": "Sets the delay in milliseconds before this tween will repeat itself.\nThe repeatDelay is invoked as soon as you call `Tween.start`. If the tween is already running this method doesn't do anything for the current active tween.\nIf you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to set repeatDelay on.\nIf you have child tweens and pass -1 as the index value it sets the repeatDelay across all of them.",
          "!type": "fn(duration: +Number, index: +Number) -> +Phaser.Tween"
        },
        "repeatCounter": {
          "!doc": "If the Tween and any child tweens are set to repeat this contains the current repeat count.",
          "!type": "+Number"
        },
        "onChildComplete": {
          "!doc": "The onChildComplete event is fired when the Tween or any of its children completes.\nFires every time a child completes unless a child is set to repeat forever.\nIt will be sent 2 parameters: the target object and this tween.",
          "!type": "+Phaser.Signal"
        },
        "resume": {
          "!doc": "Resumes a paused tween.",
          "!type": "fn()"
        },
        "totalDuration": {
          "!doc": "Gets the total duration of this Tween, including all child tweens, in milliseconds.",
          "!type": "+Phaser.TweenData"
        },
        "isPaused": {
          "!doc": "Is this Tween paused or not?",
          "!type": "+Boolean"
        },
        "chain": {
          "!doc": "This method allows you to chain tweens together. Any tween chained to this tween will have its `Tween.start` method called\nas soon as this tween completes. If this tween never completes (i.e. repeatAll or loop is set) then the chain will never progress.\nNote that `Tween.onComplete` will fire when *this* tween completes, not when the whole chain completes.\nFor that you should listen to `onComplete` on the final tween in your chain.\n\nIf you pass multiple tweens to this method they will be joined into a single long chain.\nFor example if this is Tween A and you pass in B, C and D then B will be chained to A, C will be chained to B and D will be chained to C.\nAny previously chained tweens that may have been set will be overwritten.",
          "!type": "fn(tweens: +Phaser.Tween) -> +Phaser.Tween"
        },
        "manager": {
          "!doc": "Reference to the TweenManager responsible for updating this Tween.",
          "!type": "+Phaser.TweenManager"
        },
        "onComplete": {
          "!doc": "The onComplete event is fired when the Tween and all of its children completes. Does not fire if the Tween is set to loop or repeatAll(-1).\nIt will be sent 2 parameters: the target object and this tween.",
          "!type": "+Phaser.Signal"
        },
        "start": {
          "!doc": "Starts the tween running. Can also be called by the autoStart parameter of `Tween.to` or `Tween.from`.\nThis sets the `Tween.isRunning` property to `true` and dispatches a `Tween.onStart` signal.\nIf the Tween has a delay set then nothing will start tweening until the delay has expired.",
          "!type": "fn(index: +Number) -> +Phaser.Tween"
        },
        "reverse": {
          "!doc": "If set to `true` the current tween will play in reverse.\nIf the tween hasn't yet started this has no effect.\nIf there are child tweens then all child tweens will play in reverse from the current point.",
          "!type": "+Boolean"
        },
        "pause": {
          "!doc": "Pauses the tween. Resume playback with Tween.resume.",
          "!type": "fn()"
        },
        "target": {
          "!doc": "The target object, such as a Phaser.Sprite or property like Phaser.Sprite.scale.",
          "!type": "+Object"
        },
        "interpolation": {
          "!doc": "Sets the interpolation function the tween will use. By default it uses Phaser.Math.linearInterpolation.\nAlso available: Phaser.Math.bezierInterpolation and Phaser.Math.catmullRomInterpolation.\nThe interpolation function is only used if the target properties is an array.\nIf you have child tweens and pass -1 as the index value and it will set the interpolation function across all of them.",
          "!type": "fn(interpolation: +Function, context: +Object, index: +Number) -> +Phaser.Tween"
        },
        "delay": {
          "!doc": "Sets the delay in milliseconds before this tween will start. If there are child tweens it sets the delay before the first child starts.\nThe delay is invoked as soon as you call `Tween.start`. If the tween is already running this method doesn't do anything for the current active tween.\nIf you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to delay.\nIf you have child tweens and pass -1 as the index value it sets the delay across all of them.",
          "!type": "fn(duration: +Number, index: +Number) -> +Phaser.Tween"
        },
        "stop": {
          "!doc": "Stops the tween if running and flags it for deletion from the TweenManager.\nIf called directly the `Tween.onComplete` signal is not dispatched and no chained tweens are started unless the complete parameter is set to `true`.\nIf you just wish to pause a tween then use Tween.pause instead.",
          "!type": "fn(complete: +Boolean) -> +Phaser.Tween"
        },
        "repeatAll": {
          "!doc": "Set how many times this tween and all of its children will repeat.\nA tween (A) with 3 children (B,C,D) with a `repeatAll` value of 2 would play as: ABCDABCD before completing.",
          "!type": "fn(total: +Number) -> +Phaser.Tween"
        },
        "chainedTween": {
          "!doc": "If this Tween is chained to another this holds a reference to it.",
          "!type": "+Phaser.Tween"
        },
        "timeline": {
          "!doc": "An Array of TweenData objects that comprise the different parts of this Tween.",
          "!type": "+Array"
        },
        "frameBased": {
          "!doc": "Is this Tween frame or time based? A frame based tween will use the physics elapsed timer when updating. This means\nit will retain the same consistent frame rate, regardless of the speed of the device. The duration value given should\nbe given in frames.\n\nIf the Tween uses a time based update (which is the default) then the duration is given in milliseconds.\nIn this situation a 2000ms tween will last exactly 2 seconds, regardless of the device and how many visual updates the tween\nhas actually been through. For very short tweens you may wish to experiment with a frame based update instead.\n\nThe default value is whatever you've set in TweenManager.frameBased.",
          "!type": "+Boolean"
        },
        "to": {
          "!doc": "Sets this tween to be a `to` tween on the properties given. A `to` tween starts at the current value and tweens to the destination value given.\nFor example a Sprite with an `x` coordinate of 100 could be tweened to `x` 200 by giving a properties object of `{ x: 200 }`.\nThe ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as \"Circ\".\n\".easeIn\", \".easeOut\" and \"easeInOut\" variants are all supported for all ease types.",
          "!type": "fn(properties: +Object, duration: +Number, ease: +Function, autoStart: +Boolean, delay: +Number, repeat: +Number, yoyo: +Boolean) -> +Phaser.Tween"
        },
        "pendingDelete": {
          "!doc": "True if this Tween is ready to be deleted by the TweenManager.",
          "!type": "+Boolean"
        },
        "properties": {
          "!doc": "Target property cache used when building the child data values.",
          "!type": "+Object"
        },
        "onLoop": {
          "!doc": "The onLoop event is fired if the Tween, or any child tweens loop.\nIt will be sent 2 parameters: the target object and this tween.",
          "!type": "+Phaser.Signal"
        }
      }
    },
    "Polygon": {
      "!doc": "Creates a new Polygon.\n\nThe points can be set from a variety of formats:\n\n- An array of Point objects: `[new Phaser.Point(x1, y1), ...]`\n- An array of objects with public x/y properties: `[obj1, obj2, ...]`\n- An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\n- As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`\n- As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`\n- As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`",
      "!type": "fn(points: +Array._Phaser.Point_)",
      "prototype": {
        "flatten": {
          "!doc": "Flattens this Polygon so the points are a sequence of numbers. Any Point objects found are removed and replaced with two numbers.",
          "!type": "fn() -> +Phaser.Polygon"
        },
        "area": {
          "!doc": "The area of this Polygon.",
          "!type": "+Number"
        },
        "contains": {
          "!doc": "Checks whether the x and y coordinates are contained within this polygon.",
          "!type": "fn(x: +Number, y: +Number) -> +Boolean"
        },
        "toNumberArray": {
          "!doc": "Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]",
          "!type": "fn(output: +Array) -> +Array"
        },
        "clone": {
          "!doc": "Creates a copy of the given Polygon.\nThis is a deep clone, the resulting copy contains new Phaser.Point objects",
          "!type": "fn(output: +Phaser.Polygon) -> +Phaser.Polygon"
        },
        "setTo": {
          "!doc": "Sets this Polygon to the given points.\n\nThe points can be set from a variety of formats:\n\n- An array of Point objects: `[new Phaser.Point(x1, y1), ...]`\n- An array of objects with public x/y properties: `[obj1, obj2, ...]`\n- An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\n- An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`\n- As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`\n- As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`\n- As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`\n\n`setTo` may also be called without any arguments to remove all points.",
          "!type": "fn(points: +Array._Phaser.Point_) -> +Phaser.Polygon"
        },
        "closed": {
          "!doc": "Is the Polygon closed or not?",
          "!type": "+Boolean"
        },
        "type": {
          "!doc": "The base object type.",
          "!type": "+Number"
        },
        "points": {
          "!doc": "The array of vertex points.",
          "!type": "+Array._Phaser.Point_"
        }
      }
    },
    "InputHandler": {
      "!doc": "The Input Handler is bound to a specific Sprite and is responsible for managing all Input events on that Sprite.",
      "!type": "fn(sprite: +Phaser.Sprite)",
      "prototype": {
        "pointerTimeUp": {
          "!doc": "A timestamp representing when the Pointer left the touchscreen.",
          "!type": "fn(pointerId: +Number) -> +Number"
        },
        "enableDrag": {
          "!doc": "Allow this Sprite to be dragged by any valid pointer.\n\nWhen the drag begins the Sprite.events.onDragStart event will be dispatched.\n\nWhen the drag completes by way of the user letting go of the pointer that was dragging the sprite, the Sprite.events.onDragStop event is dispatched.\n\nFor the duration of the drag the Sprite.events.onDragUpdate event is dispatched. This event is only dispatched when the pointer actually\nchanges position and moves. The event sends 5 parameters: `sprite`, `pointer`, `dragX`, `dragY` and `snapPoint`.",
          "!type": "fn(lockCenter: +Boolean, bringToTop: +Boolean, pixelPerfect: +Boolean, alphaThreshold: +Boolean, boundsRect: +Phaser.Rectangle, boundsSprite: +Phaser.Sprite)"
        },
        "overDuration": {
          "!doc": "If the pointer is currently over this Sprite this returns how long it has been there for in milliseconds.",
          "!type": "fn(pointerId: +Number) -> +Number"
        },
        "pixelPerfectClick": {
          "!doc": "Use a pixel perfect check when testing for clicks or touches on the Sprite.",
          "!type": "+Boolean"
        },
        "globalToLocalX": {
          "!doc": "Warning: EXPERIMENTAL",
          "!type": "fn(x: +Number)"
        },
        "snapPoint": {
          "!doc": "If the sprite is set to snap while dragging this holds the point of the most recent 'snap' event.",
          "!type": "+Phaser.Point"
        },
        "globalToLocalY": {
          "!doc": "Warning: EXPERIMENTAL",
          "!type": "fn(y: +Number)"
        },
        "allowVerticalDrag": {
          "!doc": "Controls if the Sprite is allowed to be dragged vertically.",
          "!type": "+Boolean"
        },
        "checked": {
          "!doc": "A disposable flag used by the Pointer class when performing priority checks.",
          "!type": "+Boolean"
        },
        "checkPixel": {
          "!doc": "Runs a pixel perfect check against the given x/y coordinates of the Sprite this InputHandler is bound to.\nIt compares the alpha value of the pixel and if >= InputHandler.pixelPerfectAlpha it returns true.",
          "!type": "fn(x: +Number, y: +Number, pointer: +Phaser.Pointer) -> +Boolean"
        },
        "pointerOut": {
          "!doc": "Is the Pointer outside of this Sprite?",
          "!type": "fn(pointerId: +Number) -> +Boolean"
        },
        "bringToTop": {
          "!doc": "If true when this Sprite is clicked or dragged it will automatically be bought to the top of the Group it is within.",
          "!type": "+Boolean"
        },
        "disableDrag": {
          "!doc": "Stops this sprite from being able to be dragged.\nIf it is currently the target of an active drag it will be stopped immediately; also disables any set callbacks.",
          "!type": "fn()"
        },
        "isPixelPerfect": {
          "!doc": "Is this object using pixel perfect checking?",
          "!type": "fn() -> +Boolean"
        },
        "dragStartPoint": {
          "!doc": "The Point from which the most recent drag started from. Useful if you need to return an object to its starting position.",
          "!type": "+Phaser.Point"
        },
        "useHandCursor": {
          "!doc": "On a desktop browser you can set the 'hand' cursor to appear when moving over the Sprite.",
          "!type": "+Boolean"
        },
        "destroy": {
          "!doc": "Clean up memory.",
          "!type": "fn()"
        },
        "pointerTimeOut": {
          "!doc": "A timestamp representing when the Pointer left the touchscreen.",
          "!type": "fn(pointerId: +Number) -> +Number"
        },
        "pointerDragged": {
          "!doc": "Is this sprite being dragged by the mouse or not?",
          "!type": "fn(pointerId: +Number) -> +Boolean"
        },
        "validForInput": {
          "!doc": "Checks if the object this InputHandler is bound to is valid for consideration in the Pointer move event.\nThis is called by Phaser.Pointer and shouldn't typically be called directly.",
          "!type": "fn(highestID: +Number, highestRenderID: +Number, includePixelPerfect: +Boolean) -> +Boolean"
        },
        "pointerDown": {
          "!doc": "If the Pointer is down this returns true.\nThis *only* checks if the Pointer is down, not if it's down over any specific Sprite.",
          "!type": "fn(pointerId: +Number) -> +Boolean"
        },
        "stop": {
          "!doc": "Stops the Input Handler from running.",
          "!type": "fn()"
        },
        "enableSnap": {
          "!doc": "Make this Sprite snap to the given grid either during drag or when it's released.\nFor example 16x16 as the snapX and snapY would make the sprite snap to every 16 pixels.",
          "!type": "fn(snapX: +Number, snapY: +Number, onDrag: +Boolean, onRelease: +Boolean, snapOffsetX: +Number, snapOffsetY: +Number)"
        },
        "startDrag": {
          "!doc": "Called by Pointer when drag starts on this Sprite. Should not usually be called directly.",
          "!type": "fn(pointer: +Phaser.Pointer)"
        },
        "reset": {
          "!doc": "Resets the Input Handler and disables it.",
          "!type": "fn()"
        },
        "scaleLayer": {
          "!doc": "EXPERIMENTAL: Please do not use this property unless you know what it does. Likely to change in the future.",
          "!type": "+Boolean"
        },
        "checkPointerOver": {
          "!doc": "Checks if the given pointer is over the Sprite this InputHandler belongs to.\nUse the `fastTest` flag is to quickly check just the bounding hit area even if `InputHandler.pixelPerfectOver` is `true`.",
          "!type": "fn(pointer: +Phaser.Pointer, fastTest: +Boolean) -> +Boolean"
        },
        "pointerTimeDown": {
          "!doc": "A timestamp representing when the Pointer first touched the touchscreen.",
          "!type": "fn(pointerId: +Number) -> +Number"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "pixelPerfectOver": {
          "!doc": "Use a pixel perfect check when testing for pointer over.",
          "!type": "+Boolean"
        },
        "justOut": {
          "!doc": "Returns true if the pointer has left the Sprite within the specified delay time (defaults to 500ms, half a second)",
          "!type": "fn(pointerId: +Number, delay: +Number) -> +Boolean"
        },
        "snapX": {
          "!doc": "When a Sprite has snapping enabled this holds the width of the snap grid.",
          "!type": "+Number"
        },
        "snapY": {
          "!doc": "When a Sprite has snapping enabled this holds the height of the snap grid.",
          "!type": "+Number"
        },
        "updateDrag": {
          "!doc": "Updates the Pointer drag on this Sprite.",
          "!type": "fn(pointer: +Phaser.Pointer) -> +Boolean"
        },
        "update": {
          "!doc": "Update.",
          "!type": "fn(pointer: +Phaser.Pointer)"
        },
        "pointerTimeOver": {
          "!doc": "A timestamp representing when the Pointer first touched the touchscreen.",
          "!type": "fn(pointerId: +Number) -> +Number"
        },
        "enabled": {
          "!doc": "If enabled the Input Handler will process input requests and monitor pointer activity.",
          "!type": "+Boolean"
        },
        "snapOffsetX": {
          "!doc": "This defines the top-left X coordinate of the snap grid.",
          "!type": "+Number"
        },
        "allowHorizontalDrag": {
          "!doc": "Controls if the Sprite is allowed to be dragged horizontally.",
          "!type": "+Boolean"
        },
        "draggable": {
          "!doc": "Is this sprite allowed to be dragged by the mouse? true = yes, false = no",
          "!type": "+Boolean"
        },
        "snapOffsetY": {
          "!doc": "This defines the top-left Y coordinate of the snap grid..",
          "!type": "+Number"
        },
        "sprite": {
          "!doc": "The Sprite object to which this Input Handler belongs.",
          "!type": "+Phaser.Sprite"
        },
        "justOver": {
          "!doc": "Returns true if the pointer has entered the Sprite within the specified delay time (defaults to 500ms, half a second)",
          "!type": "fn(pointerId: +Number, delay: +Number) -> +Boolean"
        },
        "justReleased": {
          "!doc": "Returns true if the pointer was touching this Sprite, but has been released within the specified delay time (defaults to 500ms, half a second)",
          "!type": "fn(pointerId: +Number, delay: +Number) -> +Boolean"
        },
        "checkBoundsSprite": {
          "!doc": "Parent Sprite Bounds check for the sprite drag.",
          "!type": "fn()"
        },
        "boundsSprite": {
          "!doc": "A Sprite the bounds of which this sprite is restricted during drag.",
          "!type": "+Phaser.Sprite"
        },
        "dragOffset": {
          "!doc": "The offset from the Sprites position that dragging takes place from.",
          "!type": "+Phaser.Point"
        },
        "justPressed": {
          "!doc": "Returns true if the pointer has touched or clicked on the Sprite within the specified delay time (defaults to 500ms, half a second)",
          "!type": "fn(pointerId: +Number, delay: +Number) -> +Boolean"
        },
        "pointerOver": {
          "!doc": "Is the Pointer over this Sprite?",
          "!type": "fn(pointerId: +Number) -> +Boolean"
        },
        "checkBoundsRect": {
          "!doc": "Bounds Rect check for the sprite drag",
          "!type": "fn()"
        },
        "pixelPerfectAlpha": {
          "!doc": "The alpha tolerance threshold. If the alpha value of the pixel matches or is above this value, it's considered a hit.",
          "!type": "+Number"
        },
        "setDragLock": {
          "!doc": "Restricts this sprite to drag movement only on the given axis. Note: If both are set to false the sprite will never move!",
          "!type": "fn(allowHorizontal: +Boolean, allowVertical: +Boolean)"
        },
        "start": {
          "!doc": "Starts the Input Handler running. This is called automatically when you enable input on a Sprite, or can be called directly if you need to set a specific priority.",
          "!type": "fn(priority: +Number, useHandCursor: +Boolean) -> +Phaser.Sprite"
        },
        "dragFromCenter": {
          "!doc": "Is the Sprite dragged from its center, or the point at which the Pointer was pressed down upon it?",
          "!type": "+Boolean"
        },
        "snapOnRelease": {
          "!doc": "When the Sprite is dragged this controls if the Sprite will be snapped on release.",
          "!type": "+Boolean"
        },
        "downDuration": {
          "!doc": "If the pointer is currently over this Sprite this returns how long it has been there for in milliseconds.",
          "!type": "fn(pointerId: +Number) -> +Number"
        },
        "priorityID": {
          "!doc": "The priorityID is used to determine which game objects should get priority when input events occur. For example if you have\nseveral Sprites that overlap, by default the one at the top of the display list is given priority for input events. You can\nstop this from happening by controlling the priorityID value. The higher the value, the more important they are considered to the Input events.",
          "!type": "+Number"
        },
        "pointerUp": {
          "!doc": "If the Pointer is up this returns true.\nThis *only* checks if the Pointer is up, not if it's up over any specific Sprite.",
          "!type": "fn(pointerId: +Number) -> +Boolean"
        },
        "snapOffset": {
          "!doc": "A Point object that contains by how far the Sprite snap is offset.",
          "!type": "+Phaser.Point"
        },
        "snapOnDrag": {
          "!doc": "When the Sprite is dragged this controls if the center of the Sprite will snap to the pointer on drag or not.",
          "!type": "+Boolean"
        },
        "pointerX": {
          "!doc": "The x coordinate of the Input pointer, relative to the top-left of the parent Sprite.\nThis value is only set when the pointer is over this Sprite.",
          "!type": "fn(pointerId: +Number) -> +Number"
        },
        "pointerY": {
          "!doc": "The y coordinate of the Input pointer, relative to the top-left of the parent Sprite\nThis value is only set when the pointer is over this Sprite.",
          "!type": "fn(pointerId: +Number) -> +Number"
        },
        "stopDrag": {
          "!doc": "Called by Pointer when drag is stopped on this Sprite. Should not usually be called directly.",
          "!type": "fn(pointer: +Phaser.Pointer)"
        },
        "isDragged": {
          "!doc": "true if the Sprite is being currently dragged.",
          "!type": "+Boolean"
        },
        "checkPointerDown": {
          "!doc": "Checks if the given pointer is both down and over the Sprite this InputHandler belongs to.\nUse the `fastTest` flag is to quickly check just the bounding hit area even if `InputHandler.pixelPerfectOver` is `true`.",
          "!type": "fn(pointer: +Phaser.Pointer, fastTest: +Boolean) -> +Boolean"
        },
        "boundsRect": {
          "!doc": "A region of the game world within which the sprite is restricted during drag.",
          "!type": "+Phaser.Rectangle"
        },
        "disableSnap": {
          "!doc": "Stops the sprite from snapping to a grid during drag or release.",
          "!type": "fn()"
        }
      }
    },
    "Circle": {
      "intersectsRectangle": {
        "!doc": "Checks if the given Circle and Rectangle objects intersect.",
        "!type": "fn(c: +Phaser.Circle, r: +Phaser.Rectangle) -> +Boolean"
      },
      "intersects": {
        "!doc": "Determines whether the two Circle objects intersect.\nThis method checks the radius distances between the two Circle objects to see if they intersect.",
        "!type": "fn(a: +Phaser.Circle, b: +Phaser.Circle) -> +Boolean"
      },
      "!doc": "Creates a new Circle object with the center coordinate specified by the x and y parameters and the diameter specified by the diameter parameter.\nIf you call this function without parameters, a circle with x, y, diameter and radius properties set to 0 is created.",
      "equals": {
        "!doc": "Determines whether the two Circle objects match. This method compares the x, y and diameter properties.",
        "!type": "fn(a: +Phaser.Circle, b: +Phaser.Circle) -> +Boolean"
      },
      "!type": "fn(x: +Number, y: +Number, diameter: +Number)",
      "prototype": {
        "circumferencePoint": {
          "!doc": "Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.",
          "!type": "fn(angle: +Number, asDegrees: +Boolean, out: +Phaser.Point) -> +Phaser.Point"
        },
        "area": {
          "!doc": "The area of this circle.",
          "!type": "+Number"
        },
        "distance": {
          "!doc": "Returns the distance from the center of the Circle object to the given object\n(can be Circle, Point or anything with x/y properties)",
          "!type": "fn(dest: +Object, round: +Boolean) -> +Number"
        },
        "offset": {
          "!doc": "Adjusts the location of the Circle object, as determined by its center coordinate, by the specified amounts.",
          "!type": "fn(dx: +Number, dy: +Number) -> +Phaser.Circle"
        },
        "bottom": {
          "!doc": "Gets or sets the bottom of the circle.",
          "!type": "+Number"
        },
        "offsetPoint": {
          "!doc": "Adjusts the location of the Circle object using a Point object as a parameter. This method is similar to the Circle.offset() method, except that it takes a Point object as a parameter.",
          "!type": "fn(point: +Point) -> +Phaser.Circle"
        },
        "right": {
          "!doc": "Gets or sets the value of the rightmost point of the circle.",
          "!type": "+Number"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "getBounds": {
          "!doc": "Returns the framing rectangle of the circle as a Phaser.Rectangle object.",
          "!type": "fn() -> +Phaser.Rectangle"
        },
        "copyFrom": {
          "!doc": "Copies the x, y and diameter properties from any given object to this Circle.",
          "!type": "fn(source: +Object) -> +Phaser.Circle"
        },
        "empty": {
          "!doc": "Gets or sets the empty state of the circle.",
          "!type": "+Boolean"
        },
        "copyTo": {
          "!doc": "Copies the x, y and diameter properties from this Circle to any given object.",
          "!type": "fn(dest: +Object) -> +Object"
        },
        "random": {
          "!doc": "Returns a uniformly distributed random point from anywhere within this Circle.",
          "!type": "fn(out: +Phaser.Point) -> +Phaser.Point"
        },
        "contains": {
          "!doc": "Return true if the given x/y coordinates are within this Circle object.",
          "!type": "fn(x: +Number, y: +Number) -> +Boolean"
        },
        "diameter": {
          "!doc": "Gets or sets the diameter of the circle.",
          "!type": "+Number"
        },
        "top": {
          "!doc": "Gets or sets the top of the circle.",
          "!type": "+Number"
        },
        "left": {
          "!doc": "The x coordinate of the leftmost point of the circle. Changing the left property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.",
          "!type": "+Object"
        },
        "circumference": {
          "!doc": "The circumference of the circle.",
          "!type": "fn() -> +Number"
        },
        "clone": {
          "!doc": "Returns a new Circle object with the same values for the x, y, width, and height properties as this Circle object.",
          "!type": "fn(output: +Phaser.Circle) -> +Phaser.Circle"
        },
        "x": {
          "!doc": "The x coordinate of the center of the circle.",
          "!type": "+Number"
        },
        "setTo": {
          "!doc": "Sets the members of Circle to the specified values.",
          "!type": "fn(x: +Number, y: +Number, diameter: +Number) -> +Phaser.Circle"
        },
        "y": {
          "!doc": "The y coordinate of the center of the circle.",
          "!type": "+Number"
        },
        "toString": {
          "!doc": "Returns a string representation of this object.",
          "!type": "fn() -> +String"
        },
        "radius": {
          "!doc": "Gets or sets the radius of the circle.",
          "!type": "+Number"
        }
      }
    },
    "TILEMAP": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "RECTANGLE": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "ArraySet": {
      "!doc": "ArraySet is a Set data structure (items must be unique within the set) that also maintains order.\nThis allows specific items to be easily added or removed from the Set.\n\nItem equality (and uniqueness) is determined by the behavior of `Array.indexOf`.\n\nThis used primarily by the Input subsystem.",
      "!type": "fn(list: +Array._any_)",
      "prototype": {
        "add": {
          "!doc": "Adds a new element to the end of the list.\nIf the item already exists in the list it is not moved.",
          "!type": "fn(item: +Object) -> +Object"
        },
        "next": {
          "!doc": "Returns the the next item (based on the cursor) and advances the cursor.",
          "!type": "+Object"
        },
        "getIndex": {
          "!doc": "Gets the index of the item in the list, or -1 if it isn't in the list.",
          "!type": "fn(item: +Object) -> +Number"
        },
        "getByKey": {
          "!doc": "Gets an item from the set based on the property strictly equaling the value given.\nReturns null if not found.",
          "!type": "fn(property: +String, value: +Object) -> +Object"
        },
        "list": {
          "!doc": "The backing array.",
          "!type": "+Array._any_"
        },
        "remove": {
          "!doc": "Removes the given element from this list if it exists.",
          "!type": "fn(item: +Object) -> +Object"
        },
        "callAll": {
          "!doc": "Calls a function on all members of this list, using the member as the context for the callback.\n\nIf the `key` property is present it must be a function.\nThe function is invoked using the item as the context.",
          "!type": "fn(key: +String, parameter: +any)"
        },
        "removeAll": {
          "!doc": "Removes every member from this ArraySet and optionally destroys it.",
          "!type": "fn(destroy: +Boolean)"
        },
        "total": {
          "!doc": "Number of items in the ArraySet. Same as `list.length`.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "Checks for the item within this list.",
          "!type": "fn(item: +Object) -> +Boolean"
        },
        "reset": {
          "!doc": "Removes all the items.",
          "!type": "fn()"
        },
        "position": {
          "!doc": "Current cursor position as established by `first` and `next`.",
          "!type": "+Number"
        },
        "setAll": {
          "!doc": "Sets the property `key` to the given value on all members of this list.",
          "!type": "fn(key: +Object, value: +Object)"
        },
        "first": {
          "!doc": "Returns the first item and resets the cursor to the start.",
          "!type": "+Object"
        }
      }
    },
    "RandomDataGenerator": {
      "!doc": "An extremely useful repeatable random data generator.\n\nBased on Nonsense by Josh Faul https://github.com/jocafa/Nonsense.\n\nThe random number genererator is based on the Alea PRNG, but is modified.\n - https://github.com/coverslide/node-alea\n - https://github.com/nquinlan/better-random-numbers-for-javascript-mirror\n - http://baagoe.org/en/wiki/Better_random_numbers_for_javascript (original, perm. 404)",
      "!type": "fn(seeds: +Array._any_)",
      "prototype": {
        "normal": {
          "!doc": "Returns a random real number between -1 and 1.",
          "!type": "fn() -> +Number"
        },
        "integerInRange": {
          "!doc": "Returns a random integer between and including min and max.",
          "!type": "fn(min: +Number, max: +Number) -> +Number"
        },
        "sign": {
          "!doc": "Returns a sign to be used with multiplication operator.",
          "!type": "fn() -> +Number"
        },
        "integer": {
          "!doc": "Returns a random integer between 0 and 2^32.",
          "!type": "fn() -> +Number"
        },
        "real": {
          "!doc": "Returns a random real number between 0 and 2^32.",
          "!type": "fn() -> +Number"
        },
        "uuid": {
          "!doc": "Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368",
          "!type": "fn() -> +String"
        },
        "realInRange": {
          "!doc": "Returns a random real number between min and max.",
          "!type": "fn(min: +Number, max: +Number) -> +Number"
        },
        "pick": {
          "!doc": "Returns a random member of `array`.",
          "!type": "fn(ary: +Array) -> +Object"
        },
        "angle": {
          "!doc": "Returns a random angle between -180 and 180.",
          "!type": "fn() -> +Number"
        },
        "sow": {
          "!doc": "Reset the seed of the random data generator.\n\n_Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.",
          "!type": "fn(seeds: +Array._any_)"
        },
        "state": {
          "!doc": "Gets or Sets the state of the generator. This allows you to retain the values\nthat the generator is using between games, i.e. in a game save file.\n\nTo seed this generator with a previously saved state you can pass it as the \n`seed` value in your game config, or call this method directly after Phaser has booted.\n\nCall this method with no parameters to return the current state.\n\nIf providing a state it should match the same format that this method\nreturns, which is a string with a header `!rnd` followed by the `c`,\n`s0`, `s1` and `s2` values respectively, each comma-delimited.",
          "!type": "fn(state: +String) -> +String"
        },
        "weightedPick": {
          "!doc": "Returns a random member of `array`, favoring the earlier entries.",
          "!type": "fn(ary: +Array) -> +Object"
        },
        "frac": {
          "!doc": "Returns a random real number between 0 and 1.",
          "!type": "fn() -> +Number"
        },
        "between": {
          "!doc": "Returns a random integer between and including min and max.\nThis method is an alias for RandomDataGenerator.integerInRange.",
          "!type": "fn(min: +Number, max: +Number) -> +Number"
        },
        "timestamp": {
          "!doc": "Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.",
          "!type": "fn(min: +Number, max: +Number) -> +Number"
        }
      }
    },
    "Device": {
      "!doc": "It is not possible to instantiate the Device class manually.",
      "onInitialized": {
        "!doc": "This signal is dispatched after device initialization occurs but before any of the ready\ncallbacks (see {@link Phaser.Device.whenReady whenReady}) have been invoked.\n\nLocal \"patching\" for a particular device can/should be done in this event.\n\n_Note_: This signal is removed after the device has been readied; if a handler has not been\nadded _before_ `new Phaser.Game(..)` it is probably too late.",
        "!type": "+Phaser.Signal"
      },
      "!type": "fn()",
      "prototype": {
        "fullscreenKeyboard": {
          "!doc": "Does the browser support access to the Keyboard during Full Screen mode?",
          "!type": "+Boolean"
        },
        "arora": {
          "!doc": "Set to true if running in Arora.",
          "!type": "+Boolean"
        },
        "windowsPhone": {
          "!doc": "Is running on a Windows Phone?",
          "!type": "+Boolean"
        },
        "opera": {
          "!doc": "Set to true if running in Opera.",
          "!type": "+Boolean"
        },
        "webGL": {
          "!doc": "Is webGL available?",
          "!type": "+Boolean"
        },
        "getUserMedia": {
          "!doc": "Does the device support the getUserMedia API?",
          "!type": "+Boolean"
        },
        "firefox": {
          "!doc": "Set to true if running in Firefox.",
          "!type": "+Boolean"
        },
        "ieVersion": {
          "!doc": "If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.",
          "!type": "+Number"
        },
        "hlsVideo": {
          "!doc": "Can this device play hls video files?",
          "!type": "+Boolean"
        },
        "canvasBitBltShift": {
          "!doc": "True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.",
          "!type": "+Boolean"
        },
        "opus": {
          "!doc": "Can this device play opus files?",
          "!type": "+Boolean"
        },
        "iOS": {
          "!doc": "Is running on iOS?",
          "!type": "+Boolean"
        },
        "vibration": {
          "!doc": "Does the device support the Vibration API?",
          "!type": "+Boolean"
        },
        "epiphany": {
          "!doc": "Set to true if running in Epiphany.",
          "!type": "+Boolean"
        },
        "ogg": {
          "!doc": "Can this device play ogg files?",
          "!type": "+Boolean"
        },
        "audioData": {
          "!doc": "Are Audio tags available?",
          "!type": "+Boolean"
        },
        "iPhone4": {
          "!doc": "Is running on iPhone4?",
          "!type": "+Boolean"
        },
        "edge": {
          "!doc": "Set to true if running in Microsoft Edge browser.",
          "!type": "+Boolean"
        },
        "cordova": {
          "!doc": "Is the game running under Apache Cordova?",
          "!type": "+Boolean"
        },
        "isConsoleOpen": {
          "!doc": "Check whether the console is open.\nNote that this only works in Firefox with Firebug and earlier versions of Chrome.\nIt used to work in Chrome, but then they removed the ability: {@link http://src.chromium.org/viewvc/blink?view=revision&revision=151136}",
          "!type": "fn()"
        },
        "electron": {
          "!doc": "Is the game running under GitHub Electron?",
          "!type": "+Boolean"
        },
        "safariVersion": {
          "!doc": "If running in Safari this will contain the major version number.",
          "!type": "+Number"
        },
        "quirksMode": {
          "!doc": "Is the browser running in strict mode (false) or quirks mode? (true)",
          "!type": "+Boolean"
        },
        "nodeWebkit": {
          "!doc": "Is the game running under Node-Webkit?",
          "!type": "+Boolean"
        },
        "worker": {
          "!doc": "Is worker available?",
          "!type": "+Boolean"
        },
        "ie": {
          "!doc": "Set to true if running in Internet Explorer.",
          "!type": "+Boolean"
        },
        "css3D": {
          "!doc": "Is css3D available?",
          "!type": "+Boolean"
        },
        "canvas": {
          "!doc": "Is canvas available?",
          "!type": "+Boolean"
        },
        "cancelFullscreen": {
          "!doc": "If the browser supports the Full Screen API this holds the call you need to use to cancel it.",
          "!type": "+String"
        },
        "firefoxVersion": {
          "!doc": "If running in Firefox this will contain the major version number.",
          "!type": "+Number"
        },
        "chrome": {
          "!doc": "Set to true if running in Chrome.",
          "!type": "+Boolean"
        },
        "wheelType": {
          "!doc": "The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'",
          "!type": "+String"
        },
        "touch": {
          "!doc": "Is touch available?",
          "!type": "+Boolean"
        },
        "chromeOS": {
          "!doc": "Is running on chromeOS?",
          "!type": "+Boolean"
        },
        "webm": {
          "!doc": "Can this device play webm files?",
          "!type": "+Boolean"
        },
        "node": {
          "!doc": "Is the game running under Node.js?",
          "!type": "+Boolean"
        },
        "fullscreen": {
          "!doc": "Does the browser support the Full Screen API?",
          "!type": "+Boolean"
        },
        "pixelRatio": {
          "!doc": "PixelRatio of the host device?",
          "!type": "+Number"
        },
        "support32bit": {
          "!doc": "Does the device context support 32bit pixel manipulation using array buffer views?",
          "!type": "+Boolean"
        },
        "deviceReadyAt": {
          "!doc": "The time the device became ready.",
          "!type": "+Number"
        },
        "mobileSafari": {
          "!doc": "Set to true if running in Mobile Safari.",
          "!type": "+Boolean"
        },
        "mspointer": {
          "!doc": "Is mspointer available?",
          "!type": "+Boolean"
        },
        "iPhone": {
          "!doc": "Is running on iPhone?",
          "!type": "+Boolean"
        },
        "requestFullscreen": {
          "!doc": "If the browser supports the Full Screen API this holds the call you need to use to activate it.",
          "!type": "+String"
        },
        "safari": {
          "!doc": "Set to true if running in Safari.",
          "!type": "+Boolean"
        },
        "android": {
          "!doc": "Is running on android?",
          "!type": "+Boolean"
        },
        "localStorage": {
          "!doc": "Is localStorage available?",
          "!type": "+Boolean"
        },
        "mp4Video": {
          "!doc": "Can this device play h264 mp4 video files?",
          "!type": "+Boolean"
        },
        "vp9Video": {
          "!doc": "Can this device play vp9 video files?",
          "!type": "+Boolean"
        },
        "LITTLE_ENDIAN": {
          "!doc": "Same value as `littleEndian`.",
          "!type": "+Boolean"
        },
        "chromeVersion": {
          "!doc": "If running in Chrome this will contain the major version number.",
          "!type": "+Number"
        },
        "h264Video": {
          "!doc": "Can this device play h264 mp4 video files?",
          "!type": "+Boolean"
        },
        "desktop": {
          "!doc": "Is running on a desktop?",
          "!type": "+Boolean"
        },
        "crosswalk": {
          "!doc": "Is the game running under the Intel Crosswalk XDK?",
          "!type": "+Boolean"
        },
        "file": {
          "!doc": "Is file available?",
          "!type": "+Boolean"
        },
        "webmVideo": {
          "!doc": "Can this device play webm video files?",
          "!type": "+Boolean"
        },
        "linux": {
          "!doc": "Is running on linux?",
          "!type": "+Boolean"
        },
        "pointerLock": {
          "!doc": "Is Pointer Lock available?",
          "!type": "+Boolean"
        },
        "oggVideo": {
          "!doc": "Can this device play ogg video files?",
          "!type": "+Boolean"
        },
        "canPlayVideo": {
          "!doc": "Check whether the host environment can play video files.",
          "!type": "fn(type: +String) -> +Boolean"
        },
        "initialized": {
          "!doc": "The time as which initialization has completed.",
          "!type": "+Boolean"
        },
        "iPad": {
          "!doc": "Is running on iPad?",
          "!type": "+Boolean"
        },
        "m4a": {
          "!doc": "True if this device can play m4a files.",
          "!type": "+Boolean"
        },
        "canPlayAudio": {
          "!doc": "Check whether the host environment can play audio.",
          "!type": "fn(type: +String) -> +Boolean"
        },
        "macOS": {
          "!doc": "Is running on macOS?",
          "!type": "+Boolean"
        },
        "webApp": {
          "!doc": "Set to true if running as a WebApp, i.e. within a WebView",
          "!type": "+Boolean"
        },
        "silk": {
          "!doc": "Set to true if running in the Silk browser (as used on the Amazon Kindle)",
          "!type": "+Boolean"
        },
        "fileSystem": {
          "!doc": "Is fileSystem available?",
          "!type": "+Boolean"
        },
        "trident": {
          "!doc": "Set to true if running a Trident version of Internet Explorer (IE11+)",
          "!type": "+Boolean"
        },
        "tridentVersion": {
          "!doc": "If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}",
          "!type": "+Number"
        },
        "webAudio": {
          "!doc": "Is the WebAudio API available?",
          "!type": "+Boolean"
        },
        "cocoonJSApp": {
          "!doc": "Is this game running with CocoonJS.App?",
          "!type": "+Boolean"
        },
        "iOSVersion": {
          "!doc": "If running in iOS this will contain the major version number.",
          "!type": "+Number"
        },
        "cocoonJS": {
          "!doc": "Is the game running under CocoonJS?",
          "!type": "+Boolean"
        },
        "typedArray": {
          "!doc": "Does the browser support TypedArrays?",
          "!type": "+Boolean"
        },
        "midori": {
          "!doc": "Set to true if running in Midori.",
          "!type": "+Boolean"
        },
        "littleEndian": {
          "!doc": "Is the device big or little endian? (only detected if the browser supports TypedArrays)",
          "!type": "+Boolean"
        },
        "onInitialized": {
          "!doc": "This signal is dispatched after device initialization occurs but before any of the ready\ncallbacks (see {@link Phaser.Device.whenReady whenReady}) have been invoked.\n\nLocal \"patching\" for a particular device can/should be done in this event.\n\n_Note_: This signal is removed after the device has been readied; if a handler has not been\nadded _before_ `new Phaser.Game(..)` it is probably too late.",
          "!type": "+Phaser.Signal"
        },
        "windows": {
          "!doc": "Is running on windows?",
          "!type": "+Boolean"
        },
        "wav": {
          "!doc": "Can this device play wav files?",
          "!type": "+Boolean"
        },
        "dolby": {
          "!doc": "Can this device play EC-3 Dolby Digital Plus files?",
          "!type": "+Boolean"
        },
        "ejecta": {
          "!doc": "Is the game running under Ejecta?",
          "!type": "+Boolean"
        },
        "isAndroidStockBrowser": {
          "!doc": "Detect if the host is a an Android Stock browser.\nThis is available before the device \"ready\" event.\n\nAuthors might want to scale down on effects and switch to the CANVAS rendering method on those devices.",
          "!type": "fn()"
        },
        "mp3": {
          "!doc": "Can this device play mp3 files?",
          "!type": "+Boolean"
        }
      },
      "whenReady": {
        "!doc": "Add a device-ready handler and ensure the device ready sequence is started.\n\nPhaser.Device will _not_ activate or initialize until at least one `whenReady` handler is added,\nwhich is normally done automatically be calling `new Phaser.Game(..)`.\n\nThe handler is invoked when the device is considered \"ready\", which may be immediately\nif the device is already \"ready\". See {@link Phaser.Device#deviceReadyAt deviceReadyAt}.",
        "!type": "fn(handler: +Function, context: +Object, nonPrimer: +Boolean)"
      }
    },
    "GAMES": {
      "!doc": "An array of Phaser game instances.",
      "!type": "+Array"
    },
    "AnimationParser": {
      "JSONDataPyxel": {
        "!doc": "Parse the JSON data and extract the animation frame data from it.",
        "!type": "fn(game: +Phaser.Game, json: +Object) -> +Phaser.FrameData"
      },
      "JSONData": {
        "!doc": "Parse the JSON data and extract the animation frame data from it.",
        "!type": "fn(game: +Phaser.Game, json: +Object) -> +Phaser.FrameData"
      },
      "!doc": "Responsible for parsing sprite sheet and JSON data into the internal FrameData format that Phaser uses for animations.",
      "XMLData": {
        "!doc": "Parse the XML data and extract the animation frame data from it.",
        "!type": "fn(game: +Phaser.Game, xml: +Object) -> +Phaser.FrameData"
      },
      "spriteSheet": {
        "!doc": "Parse a Sprite Sheet and extract the animation frame data from it.",
        "!type": "fn(game: +Phaser.Game, key: +String, frameWidth: +Number, frameHeight: +Number, frameMax: +Number, margin: +Number, spacing: +Number) -> +Phaser.FrameData"
      },
      "JSONDataHash": {
        "!doc": "Parse the JSON data and extract the animation frame data from it.",
        "!type": "fn(game: +Phaser.Game, json: +Object) -> +Phaser.FrameData"
      },
      "!type": "fn()",
      "prototype": {}
    },
    "Canvas": {
      "removeFromDOM": {
        "!doc": "Removes the given canvas element from the DOM.",
        "!type": "fn(canvas: +HTMLCanvasElement)"
      },
      "setBackgroundColor": {
        "!doc": "Sets the background color behind the canvas. This changes the canvas style property.",
        "!type": "fn(canvas: +HTMLCanvasElement, color: +String) -> +HTMLCanvasElement"
      },
      "!doc": "The Canvas class handles everything related to creating the `canvas` DOM tag that Phaser will use, \nincluding styles, offset and aspect ratio.",
      "prototype": {},
      "getSmoothingPrefix": {
        "!doc": "Gets the Smoothing Enabled vendor prefix being used on the given context, or null if not set.",
        "!type": "fn(context: +CanvasRenderingContext2D) -> +String"
      },
      "setTransform": {
        "!doc": "Sets the transform of the given canvas to the matrix values provided.",
        "!type": "fn(context: +CanvasRenderingContext2D, translateX: +Number, translateY: +Number, scaleX: +Number, scaleY: +Number, skewX: +Number, skewY: +Number) -> +CanvasRenderingContext2D"
      },
      "getSmoothingEnabled": {
        "!doc": "Returns `true` if the given context has image smoothing enabled, otherwise returns `false`.",
        "!type": "fn(context: +CanvasRenderingContext2D) -> +Boolean"
      },
      "create": {
        "!doc": "Creates a `canvas` DOM element. The element is not automatically added to the document.",
        "!type": "fn(parent: +Object, width: +Number, height: +Number, id: +String, skipPool: +Boolean) -> +HTMLCanvasElement"
      },
      "setImageRenderingCrisp": {
        "!doc": "Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).\nNote that if this doesn't given the desired result then see the setSmoothingEnabled.",
        "!type": "fn(canvas: +HTMLCanvasElement) -> +HTMLCanvasElement"
      },
      "!type": "fn()",
      "setUserSelect": {
        "!doc": "Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.",
        "!type": "fn(canvas: +HTMLCanvasElement, value: +String) -> +HTMLCanvasElement"
      },
      "addToDOM": {
        "!doc": "Adds the given canvas element to the DOM. The canvas will be added as a child of the given parent.\nIf no parent is given it will be added as a child of the document.body.",
        "!type": "fn(canvas: +HTMLCanvasElement, parent: +String, overflowHidden: +Boolean) -> +HTMLCanvasElement"
      },
      "setSmoothingEnabled": {
        "!doc": "Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.\nBy default browsers have image smoothing enabled, which isn't always what you visually want, especially\nwhen using pixel art in a game. Note that this sets the property on the context itself, so that any image\ndrawn to the context will be affected. This sets the property across all current browsers but support is\npatchy on earlier browsers, especially on mobile.",
        "!type": "fn(context: +CanvasRenderingContext2D, value: +Boolean) -> +CanvasRenderingContext2D"
      },
      "setImageRenderingBicubic": {
        "!doc": "Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').\nNote that if this doesn't given the desired result then see the CanvasUtils.setSmoothingEnabled method.",
        "!type": "fn(canvas: +HTMLCanvasElement) -> +HTMLCanvasElement"
      },
      "setTouchAction": {
        "!doc": "Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.",
        "!type": "fn(canvas: +HTMLCanvasElement, value: +String) -> +HTMLCanvasElement"
      }
    },
    "Color": {
      "webToColor": {
        "!doc": "Converts a CSS 'web' string into a Phaser Color object.\n\nThe web string can be in the format `'rgb(r,g,b)'` or `'rgba(r,g,b,a)'` where r/g/b are in the range [0..255] and a is in the range [0..1].",
        "!type": "fn(web: +String, out: +Object) -> +Object"
      },
      "getAlphaFloat": {
        "!doc": "Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component as a value between 0 and 1.",
        "!type": "fn(color: +Number) -> +Number"
      },
      "RGBtoHSL": {
        "!doc": "Converts an RGB color value to HSL (hue, saturation and lightness).\nConversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\nAssumes RGB values are contained in the set [0, 255] and returns h, s and l in the set [0, 1].\nBased on code by Michael Jackson (https://github.com/mjijackson)",
        "!type": "fn(r: +Number, g: +Number, b: +Number, out: +Object) -> +Object"
      },
      "valueToColor": {
        "!doc": "Converts a value - a \"hex\" string, a \"CSS 'web' string\", or a number - into red, green, blue, and alpha components.\n\nThe value can be a string (see `hexToColor` and `webToColor` for the supported formats) or a packed integer (see `getRGB`).\n\nAn alpha channel is _not_ supported when specifying a hex string.",
        "!type": "fn(value: +String, out: +Object) -> +Object"
      },
      "blendLinearBurn": {
        "!doc": "An alias for blendSubtract, it simply sums the values of the two colors and subtracts 255.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "blendVividLight": {
        "!doc": "This blend mode combines Color Dodge and Color Burn (rescaled so that neutral colors become middle gray).\nDodge applies when values in the top layer are lighter than middle gray, and burn to darker values.\nThe middle gray is the neutral color. When color is lighter than this, this effectively moves the white point of the bottom \nlayer down by twice the difference; when it is darker, the black point is moved up by twice the difference. The perceived contrast increases.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "getAlpha": {
        "!doc": "Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component, as a value between 0 and 255.",
        "!type": "fn(color: +Number) -> +Number"
      },
      "fromRGBA": {
        "!doc": "A utility to convert an integer in 0xRRGGBBAA format to a color object.\nThis does not rely on endianness.",
        "!type": "fn(rgba: +Number, out: +Object) -> +Object"
      },
      "blendReflect": {
        "!doc": "Reflect blend mode. This mode is useful when adding shining objects or light zones to images.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "HSLtoRGB": {
        "!doc": "Converts an HSL (hue, saturation and lightness) color value to RGB.\nConversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\nAssumes HSL values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].\nBased on code by Michael Jackson (https://github.com/mjijackson)",
        "!type": "fn(h: +Number, s: +Number, l: +Number, out: +Object) -> +Object"
      },
      "packPixel": {
        "!doc": "Packs the r, g, b, a components into a single integer, for use with Int32Array.\nIf device is little endian then ABGR order is used. Otherwise RGBA order is used.",
        "!type": "fn(r: +Number, g: +Number, b: +Number, a: +Number) -> +Number"
      },
      "blendLighten": {
        "!doc": "Selects the lighter of the backdrop and source colors.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "toRGBA": {
        "!doc": "A utility to convert RGBA components to a 32 bit integer in RRGGBBAA format.",
        "!type": "fn(r: +Number, g: +Number, b: +Number, a: +Number) -> +Number"
      },
      "blendDarken": {
        "!doc": "Selects the darker of the backdrop and source colors.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "blendScreen": {
        "!doc": "Multiplies the complements of the backdrop and source color values, then complements the result.\nThe result color is always at least as light as either of the two constituent colors. \nScreening any color with white produces white; screening with black leaves the original color unchanged.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "getRGB": {
        "!doc": "Return the component parts of a color as an Object with the properties alpha, red, green, blue.\n\nAlpha will only be set if it exist in the given color (0xAARRGGBB)",
        "!type": "fn(color: +Number) -> +Object"
      },
      "hexToRGB": {
        "!doc": "Converts a hex string into an integer color value.",
        "!type": "fn(hex: +String) -> +Number"
      },
      "blendGlow": {
        "!doc": "Glow blend mode. This mode is a variation of reflect mode with the source and backdrop colors swapped.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "blendSoftLight": {
        "!doc": "Darkens or lightens the colors, depending on the source color value. \n\nIf the source color is lighter than 0.5, the backdrop is lightened, as if it were dodged; \nthis is useful for adding highlights to a scene. \n\nIf the source color is darker than 0.5, the backdrop is darkened, as if it were burned in. \nThe degree of lightening or darkening is proportional to the difference between the source color and 0.5; \nif it is equal to 0.5, the backdrop is unchanged.\n\nPainting with pure black or white produces a distinctly darker or lighter area, but does not result in pure black or white. \nThe effect is similar to shining a diffused spotlight on the backdrop.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "interpolateColorWithRGB": {
        "!doc": "Interpolates the two given colours based on the supplied step and currentStep properties.",
        "!type": "fn(color: +Number, r: +Number, g: +Number, b: +Number, steps: +Number, currentStep: +Number) -> +Number"
      },
      "blendSubtract": {
        "!doc": "Combines the source and backdrop colors and returns their value minus 255.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "getColor32": {
        "!doc": "Given an alpha and 3 color values this will return an integer representation of it.",
        "!type": "fn(a: +Number, r: +Number, g: +Number, b: +Number) -> +Number"
      },
      "HSLColorWheel": {
        "!doc": "Get HSL color wheel values in an array which will be 360 elements in size.",
        "!type": "fn(s: +Number, l: +Number) -> +Array"
      },
      "getWebRGB": {
        "!doc": "Returns a CSS friendly string value from the given color.",
        "!type": "fn(color: +Number) -> +String"
      },
      "componentToHex": {
        "!doc": "Return a string containing a hex representation of the given color component.",
        "!type": "fn(color: +Number) -> +String"
      },
      "blendDifference": {
        "!doc": "Subtracts the darker of the two constituent colors from the lighter.\n\nPainting with white inverts the backdrop color; painting with black produces no change.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "getBlue": {
        "!doc": "Given a native color value (in the format 0xAARRGGBB) this will return the Blue component, as a value between 0 and 255.",
        "!type": "fn(color: +Number) -> +Number"
      },
      "hexToColor": {
        "!doc": "Converts a hex string into a Phaser Color object.\n\nThe hex string can supplied as `'#0033ff'` or the short-hand format of `'#03f'`; it can begin with an optional \"#\" or \"0x\", or be unprefixed.    \n\nAn alpha channel is _not_ supported.",
        "!type": "fn(hex: +String, out: +Object) -> +Object"
      },
      "blendLinearDodge": {
        "!doc": "An alias for blendAdd, it simply sums the values of the two colors.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "getGreen": {
        "!doc": "Given a native color value (in the format 0xAARRGGBB) this will return the Green component, as a value between 0 and 255.",
        "!type": "fn(color: +Number) -> +Number"
      },
      "blendColorBurn": {
        "!doc": "Darkens the backdrop color to reflect the source color.\nPainting with white produces no change.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "blendNegation": {
        "!doc": "Negation blend mode.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "blendNormal": {
        "!doc": "Blends the source color, ignoring the backdrop.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "getRandomColor": {
        "!doc": "Returns a random color value between black and white\nSet the min value to start each channel from the given offset.\nSet the max value to restrict the maximum color used per channel.",
        "!type": "fn(min: +Number, max: +Number, alpha: +Number) -> +Number"
      },
      "blendOverlay": {
        "!doc": "Multiplies or screens the colors, depending on the backdrop color.\nSource colors overlay the backdrop while preserving its highlights and shadows. \nThe backdrop color is not replaced, but is mixed with the source color to reflect the lightness or darkness of the backdrop.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "createColor": {
        "!doc": "A utility function to create a lightweight 'color' object with the default components.\nAny components that are not specified will default to zero.\n\nThis is useful when you want to use a shared color object for the getPixel and getPixelAt methods.",
        "!type": "fn(r: +Number, g: +Number, b: +Number, a: +Number, h: +Number, s: +Number, l: +Number, v: +Number) -> +Object"
      },
      "HSVColorWheel": {
        "!doc": "Get HSV color wheel values in an array which will be 360 elements in size.",
        "!type": "fn(s: +Number, v: +Number) -> +Array"
      },
      "RGBtoString": {
        "!doc": "Converts the given color values into a string.\nIf prefix was '#' it will be in the format `#RRGGBB` otherwise `0xAARRGGBB`.",
        "!type": "fn(r: +Number, g: +Number, b: +Number, a: +Number, prefix: +String) -> +String"
      },
      "blendExclusion": {
        "!doc": "Produces an effect similar to that of the Difference mode, but lower in contrast. \nPainting with white inverts the backdrop color; painting with black produces no change.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "blendHardLight": {
        "!doc": "Multiplies or screens the colors, depending on the source color value. \n\nIf the source color is lighter than 0.5, the backdrop is lightened, as if it were screened; \nthis is useful for adding highlights to a scene. \n\nIf the source color is darker than 0.5, the backdrop is darkened, as if it were multiplied; \nthis is useful for adding shadows to a scene. \n\nThe degree of lightening or darkening is proportional to the difference between the source color and 0.5; \nif it is equal to 0.5, the backdrop is unchanged.\n\nPainting with pure black or white produces pure black or white. The effect is similar to shining a harsh spotlight on the backdrop.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "getRed": {
        "!doc": "Given a native color value (in the format 0xAARRGGBB) this will return the Red component, as a value between 0 and 255.",
        "!type": "fn(color: +Number) -> +Number"
      },
      "HSVtoRGB": {
        "!doc": "Converts an HSV (hue, saturation and value) color value to RGB.\nConversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\nAssumes HSV values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].\nBased on code by Michael Jackson (https://github.com/mjijackson)",
        "!type": "fn(h: +Number, s: +Number, v: +Number, out: +Object) -> +Object"
      },
      "!type": "fn()",
      "hueToColor": {
        "!doc": "Converts a hue to an RGB color.\nBased on code by Michael Jackson (https://github.com/mjijackson)",
        "!type": "fn(p: +Number, q: +Number, t: +Number) -> +Number"
      },
      "updateColor": {
        "!doc": "Takes a color object and updates the rgba property.",
        "!type": "fn(out: +Object) -> +Number"
      },
      "blendLinearLight": {
        "!doc": "This blend mode combines Linear Dodge and Linear Burn (rescaled so that neutral colors become middle gray).\nDodge applies to values of top layer lighter than middle gray, and burn to darker values.\nThe calculation simplifies to the sum of bottom layer and twice the top layer, subtract 128. The contrast decreases.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "blendMultiply": {
        "!doc": "Multiplies the backdrop and source color values.\nThe result color is always at least as dark as either of the two constituent\ncolors. Multiplying any color with black produces black;\nmultiplying with white leaves the original color unchanged.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "blendAverage": {
        "!doc": "Takes the average of the source and backdrop colors.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "!doc": "The Phaser.Color class is a set of static methods that assist in color manipulation and conversion.",
      "getColor": {
        "!doc": "Given 3 color values this will return an integer representation of it.",
        "!type": "fn(r: +Number, g: +Number, b: +Number) -> +Number"
      },
      "prototype": {},
      "interpolateColor": {
        "!doc": "Interpolates the two given colours based on the supplied step and currentStep properties.",
        "!type": "fn(color1: +Number, color2: +Number, steps: +Number, currentStep: +Number, alpha: +Number) -> +Number"
      },
      "blendHardMix": {
        "!doc": "Runs blendVividLight on the source and backdrop colors.\nIf the resulting color is 128 or more, it receives a value of 255; if less than 128, a value of 0.\nTherefore, all blended pixels have red, green, and blue channel values of either 0 or 255.\nThis changes all pixels to primary additive colors (red, green, or blue), white, or black.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "interpolateRGB": {
        "!doc": "Interpolates the two given colours based on the supplied step and currentStep properties.",
        "!type": "fn(r1: +Number, g1: +Number, b1: +Number, r2: +Number, g2: +Number, b2: +Number, steps: +Number, currentStep: +Number) -> +Number"
      },
      "blendPinLight": {
        "!doc": "If the backdrop color (light source) is lighter than 50%, the blendDarken mode is used, and colors lighter than the backdrop color do not change.\nIf the backdrop color is darker than 50% gray, colors lighter than the blend color are replaced, and colors darker than the blend color do not change.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "RGBtoHSV": {
        "!doc": "Converts an RGB color value to HSV (hue, saturation and value).\nConversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\nAssumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].\nBased on code by Michael Jackson (https://github.com/mjijackson)",
        "!type": "fn(r: +Number, g: +Number, b: +Number, out: +Object) -> +Object"
      },
      "blendPhoenix": {
        "!doc": "Phoenix blend mode. This subtracts the lighter color from the darker color, and adds 255, giving a bright result.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "blendAdd": {
        "!doc": "Adds the source and backdrop colors together and returns the value, up to a maximum of 255.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      },
      "unpackPixel": {
        "!doc": "Unpacks the r, g, b, a components into the specified color object, or a new\nobject, for use with Int32Array. If little endian, then ABGR order is used when\nunpacking, otherwise, RGBA order is used. The resulting color object has the\n`r, g, b, a` properties which are unrelated to endianness.\n\nNote that the integer is assumed to be packed in the correct endianness. On little-endian\nthe format is 0xAABBGGRR and on big-endian the format is 0xRRGGBBAA. If you want a\nendian-independent method, use fromRGBA(rgba) and toRGBA(r, g, b, a).",
        "!type": "fn(rgba: +Number, out: +Object, hsl: +Boolean, hsv: +Boolean) -> +Object"
      },
      "blendColorDodge": {
        "!doc": "Brightens the backdrop color to reflect the source color. \nPainting with black produces no change.",
        "!type": "fn(a: +Number, b: +Number) -> +Number"
      }
    },
    "Particles": {
      "!doc": "Phaser.Particles is the Particle Manager for the game. It is called during the game update loop and in turn updates any Emitters attached to it.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "add": {
          "!doc": "Adds a new Particle Emitter to the Particle Manager.",
          "!type": "fn(emitter: +Phaser.Emitter) -> +Phaser.Emitter"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "emitters": {
          "!doc": "Internal emitters store.",
          "!type": "+Object"
        },
        "update": {
          "!doc": "Called by the core game loop. Updates all Emitters who have their exists value set to true.",
          "!type": "fn()"
        },
        "ID": {
          "!doc": "-",
          "!type": "+Number"
        },
        "remove": {
          "!doc": "Removes an existing Particle Emitter from the Particle Manager.",
          "!type": "fn(emitter: +Phaser.Emitter)"
        }
      },
      "Arcade": {
        "Emitter": {
          "SORT_ASCENDING": "+Number",
          "RETURN_TOTAL": "+Number",
          "!doc": "Emitter is a lightweight particle emitter that uses Arcade Physics.\nIt can be used for one-time explosions or for continuous effects like rain and fire.\nAll it really does is launch Particle objects out at set intervals, and fixes their positions and velocities accordingly.",
          "RETURN_NONE": "+Number",
          "!type": "fn(game: +Phaser.Game, x: +Number, y: +Number, maxParticles: +Number)",
          "SORT_DESCENDING": "+Number",
          "RETURN_CHILD": "+Number",
          "prototype": {
            "xy": {
              "!doc": "Positions the child found at the given index within this group to the given x and y coordinates.",
              "!type": "fn(index: +Number, x: +Number, y: +Number)"
            },
            "parent": {
              "!doc": "[read-only] The display object container that contains this display object.",
              "!type": "+PIXI.DisplayObjectContainer"
            },
            "descendingSortHandler": {
              "!doc": "An internal helper function for the sort process.",
              "!type": "fn(a: +Object, b: +Object)"
            },
            "minParticleSpeed": {
              "!doc": "The minimum possible velocity of a particle.",
              "!type": "+Phaser.Point"
            },
            "bounce": {
              "!doc": "How much each particle should bounce on each axis. 1 = full bounce, 0 = no bounce.",
              "!type": "+Phaser.Point"
            },
            "lifespan": {
              "!doc": "How long each particle lives once it is emitted in ms. Default is 2 seconds. Set lifespan to 'zero' for particles to live forever.",
              "!type": "+Number"
            },
            "type": {
              "!doc": "Internal Phaser Type value.",
              "!type": "+Number"
            },
            "moveAll": {
              "!doc": "Moves all children from this Group to the Group given.",
              "!type": "fn(group: +Phaser.Group, silent: +Boolean) -> +Phaser.Group"
            },
            "removeAll": {
              "!doc": "Removes all children from this group, but does not remove the group from its parent.",
              "!type": "fn(destroy: +Boolean, silent: +Boolean)"
            },
            "minParticleScale": {
              "!doc": "The minimum possible scale of a particle. This is applied to the X and Y axis. If you need to control each axis see minParticleScaleX.",
              "!type": "+Number"
            },
            "enableBody": {
              "!doc": "If true all Sprites created by, or added to this group, will have a physics body enabled on them.\n\nThe default body type is controlled with {@link #physicsBodyType}.",
              "!type": "+Boolean"
            },
            "children": {
              "!doc": "[read-only] The array of children of this container.",
              "!type": "+Array_DisplayObject_"
            },
            "explode": {
              "!doc": "Call this function to emit the given quantity of particles at all once (an explosion)",
              "!type": "fn(lifespan: +Number, quantity: +Number) -> +Phaser.Particles.Arcade.Emitter"
            },
            "customSort": {
              "!doc": "Sort the children in the group according to custom sort function.\n\nThe `sortHandler` is provided the two parameters: the two children involved in the comparison (a and b).\nIt should return -1 if `a > b`, 1 if `a < b` or 0 if `a === b`.",
              "!type": "fn(sortHandler: +Function, context: +Object)"
            },
            "enableBodyDebug": {
              "!doc": "If true when a physics body is created (via {@link #enableBody}) it will create a physics debug object as well.\n\nThis only works for P2 bodies.",
              "!type": "+Boolean"
            },
            "pivot": {
              "!doc": "The pivot point of the displayObject that it rotates around",
              "!type": "+Phaser.Point"
            },
            "revive": {
              "!doc": "Handy for bringing game objects \"back to life\". Just sets alive and exists back to true.",
              "!type": "fn() -> +Phaser.Particles.Arcade.Emitter"
            },
            "scaleData": {
              "!doc": "An array of the calculated scale easing data applied to particles with scaleRates > 0.",
              "!type": "+Array"
            },
            "flow": {
              "!doc": "Call this function to start emitting a flow of particles at the given frequency.\nIt will carry on going until the total given is reached.\nEach time the flow is run the quantity number of particles will be emitted together.\nIf you set the total to be 20 and quantity to be 5 then flow will emit 4 times in total (4 x 5 = 20 total)\nIf you set the total to be -1 then no quantity cap is used and it will keep emitting.",
              "!type": "fn(lifespan: +Number, frequency: +Number, quantity: +Number, total: +Number, immediate: +Boolean) -> +Phaser.Particles.Arcade.Emitter"
            },
            "bringToTop": {
              "!doc": "Brings the given child to the top of this group so it renders above all other children.",
              "!type": "fn(child: +Object) -> +Object"
            },
            "moveUp": {
              "!doc": "Moves the given child up one place in this group unless it's already at the top.",
              "!type": "fn(child: +Object) -> +Object"
            },
            "physicsType": {
              "!doc": "The const physics body type of this object.",
              "!type": "+Number"
            },
            "height": {
              "!doc": "Gets or sets the height of the Emitter. This is the region in which a particle can be emitted.",
              "!type": "+Number"
            },
            "emitY": {
              "!doc": "The point the particles are emitted from.\nEmitter.x and Emitter.y control the containers location, which updates all current particles\nEmitter.emitX and Emitter.emitY control the emission location relative to the x/y position.",
              "!type": "+Number"
            },
            "postUpdate": {
              "!doc": "The core postUpdate - as called by World.",
              "!type": "fn()"
            },
            "particleBringToTop": {
              "!doc": "If this is `true` then when the Particle is emitted it will be bought to the top of the Emitters display list.",
              "!type": "+Boolean"
            },
            "particleAnchor": {
              "!doc": "When a particle is created its anchor will be set to match this Point object (defaults to x/y: 0.5 to aid in rotation)",
              "!type": "+Phaser.Point"
            },
            "emitX": {
              "!doc": "The point the particles are emitted from.\nEmitter.x and Emitter.y control the containers location, which updates all current particles\nEmitter.emitX and Emitter.emitY control the emission location relative to the x/y position.",
              "!type": "+Number"
            },
            "destroy": {
              "!doc": "Destroys this Emitter, all associated child Particles and then removes itself from the Particle Manager.",
              "!type": "fn()"
            },
            "cursorIndex": {
              "!doc": "The current index of the Group cursor. Advance it with Group.next.",
              "!type": "+Number"
            },
            "setRotation": {
              "!doc": "A more compact way of setting the angular velocity constraints of the particles.",
              "!type": "fn(min: +Number, max: +Number) -> +Phaser.Particles.Arcade.Emitter"
            },
            "getFirstDead": {
              "!doc": "Get the first child that is dead (`child.alive === false`).\n\nThis is handy for checking if everything has been wiped out and adding to the pool as needed.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no dead ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
              "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
            },
            "physicsSortDirection": {
              "!doc": "If this Group contains Arcade Physics Sprites you can set a custom sort direction via this property.\n\nIt should be set to one of the Phaser.Physics.Arcade sort direction constants: \n\nPhaser.Physics.Arcade.SORT_NONE\nPhaser.Physics.Arcade.LEFT_RIGHT\nPhaser.Physics.Arcade.RIGHT_LEFT\nPhaser.Physics.Arcade.TOP_BOTTOM\nPhaser.Physics.Arcade.BOTTOM_TOP\n\nIf set to `null` the Group will use whatever Phaser.Physics.Arcade.sortDirection is set to. This is the default behavior.",
              "!type": "+Number"
            },
            "addAt": {
              "!doc": "Adds an existing object to this group.\n\nThe child is added to the group at the location specified by the index value, this allows you to control child ordering.",
              "!type": "fn(child: +DisplayObject, index: +Number, silent: +Boolean) -> +PIXI.DisplayObject"
            },
            "worldPosition": {
              "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
              "!type": "+Phaser.Point"
            },
            "forEachAlive": {
              "!doc": "Call a function on each alive child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
              "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
            },
            "at": {
              "!doc": "Change the emitters center to match the center of any object with a `center` property, such as a Sprite.\nIf the object doesn't have a center property it will be set to object.x + object.width / 2",
              "!type": "fn(object: +Object) -> +Phaser.Particles.Arcade.Emitter"
            },
            "left": {
              "!doc": "Gets the left position of the Emitter.",
              "!type": "+Number"
            },
            "resetCursor": {
              "!doc": "Sets the group cursor to the first child in the group.\n\nIf the optional index parameter is given it sets the cursor to the object at that index instead.",
              "!type": "fn(index: +Number) -> +Object"
            },
            "emitParticle": {
              "!doc": "This function is used internally to emit the next particle in the queue.\n\nHowever it can also be called externally to emit a particle.\n\nWhen called externally you can use the arguments to override any defaults the Emitter has set.",
              "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String) -> +Boolean"
            },
            "addMultiple": {
              "!doc": "Adds an array of existing Display Objects to this Group.\n\nThe Display Objects are automatically added to the top of this Group, and will render on-top of everything already in this Group.\n\nAs well as an array you can also pass another Group as the first argument. In this case all of the children from that\nGroup will be removed from it and added into this Group.",
              "!type": "fn(children: +Array._DisplayObject_, silent: +Boolean) -> +Array._DisplayObject_"
            },
            "setProperty": {
              "!doc": "Sets a property to the given value on the child. The operation parameter controls how the value is set.\n\nThe operations are:\n- 0: set the existing value to the given value; if force is `true` a new property will be created if needed\n- 1: will add the given value to the value already present.\n- 2: will subtract the given value from the value already present.\n- 3: will multiply the value already present by the given value.\n- 4: will divide the value already present by the given value.",
              "!type": "fn(child: +Object, key: +Array, value: +Object, operation: +Number, force: +Boolean) -> +Boolean"
            },
            "preUpdate": {
              "!doc": "The core preUpdate - as called by World.",
              "!type": "fn()"
            },
            "hash": {
              "!doc": "The hash array is an array belonging to this Group into which you can add any of its children via Group.addToHash and Group.removeFromHash.\n\nOnly children of this Group can be added to and removed from the hash.\n\nThis hash is used automatically by Phaser Arcade Physics in order to perform non z-index based destructive sorting.\nHowever if you don't use Arcade Physics, or this isn't a physics enabled Group, then you can use the hash to perform your own\nsorting and filtering of Group children without touching their z-index (and therefore display draw order)",
              "!type": "+Array"
            },
            "filterArea": {
              "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
              "!type": "+Phaser.Rectangle"
            },
            "addToHash": {
              "!doc": "Adds a child of this Group into the hash array.\nThis call will return false if the child is not a child of this Group, or is already in the hash.",
              "!type": "fn(child: +DisplayObject) -> +Boolean"
            },
            "worldScale": {
              "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
              "!type": "+Phaser.Point"
            },
            "alive": {
              "!doc": "The alive property is useful for Groups that are children of other Groups and need to be included/excluded in checks like forEachAlive.",
              "!type": "+Boolean"
            },
            "checkProperty": {
              "!doc": "Checks a property for the given value on the child.",
              "!type": "fn(child: +Object, key: +Array, value: +Object, force: +Boolean) -> +Boolean"
            },
            "callbackFromArray": {
              "!doc": "Returns a reference to a function that exists on a child of the group based on the given callback array.",
              "!type": "fn(child: +Object, callback: +Array, length: +Number)"
            },
            "worldAlpha": {
              "!doc": "[read-only] The multiplied alpha of the displayObject",
              "!type": "+Number"
            },
            "multiplyAll": {
              "!doc": "Multiplies the given property by the amount on all children in this group.\n\n`Group.multiplyAll('x', 2)` will x2 the child.x value for each child.",
              "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
            },
            "top": {
              "!doc": "Gets the top position of the Emitter.",
              "!type": "+Number"
            },
            "getByName": {
              "!doc": "Searches the Group for the first instance of a child with the `name`\nproperty matching the given argument. Should more than one child have\nthe same name only the first instance is returned.",
              "!type": "fn(name: +String) -> +Object"
            },
            "angle": {
              "!doc": "The angle of rotation of the group container, in degrees.\n\nThis adjusts the group itself by modifying its local rotation transform.\n\nThis has no impact on the rotation/angle properties of the children, but it will update their worldTransform\nand on-screen orientation and position.",
              "!type": "+Number"
            },
            "iterate": {
              "!doc": "Iterates over the children of the group performing one of several actions for matched children.\n\nA child is considered a match when it has a property, named `key`, whose value is equal to `value`\naccording to a strict equality comparison.\n\nThe result depends on the `returnType`:\n\n- {@link Phaser.Group.RETURN_TOTAL RETURN_TOTAL}:\n    The callback, if any, is applied to all matching children. The number of matched children is returned.\n- {@link Phaser.Group.RETURN_NONE RETURN_NONE}:\n    The callback, if any, is applied to all matching children. No value is returned.\n- {@link Phaser.Group.RETURN_CHILD RETURN_CHILD}:\n    The callback, if any, is applied to the *first* matching child and the *first* matched child is returned.\n    If there is no matching child then null is returned.\n\nIf `args` is specified it must be an array. The matched child will be assigned to the first\nelement and the entire array will be applied to the callback function.",
              "!type": "fn(key: +String, value: +Object, returnType: +Number, callback: +Function, callbackContext: +Object, args: +Array._any_) -> +Object"
            },
            "onDestroy": {
              "!doc": "This signal is dispatched when the group is destroyed.",
              "!type": "+Phaser.Signal"
            },
            "set": {
              "!doc": "Quickly set a property on a single child of this group to a new value.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
              "!type": "fn(child: +Phaser.Sprite, key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean) -> +Boolean"
            },
            "getFirstExists": {
              "!doc": "Get the first display object that exists, or doesn't exist.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if none matching your exists argument were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
              "!type": "fn(exists: +Boolean, createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
            },
            "setXSpeed": {
              "!doc": "A more compact way of setting the X velocity range of the emitter.",
              "!type": "fn(min: +Number, max: +Number) -> +Phaser.Particles.Arcade.Emitter"
            },
            "minParticleAlpha": {
              "!doc": "The minimum possible alpha value of a particle.",
              "!type": "+Number"
            },
            "right": {
              "!doc": "Gets the right position of the Emitter.",
              "!type": "+Number"
            },
            "kill": {
              "!doc": "Call this function to turn off all the particles and the emitter.",
              "!type": "fn() -> +Phaser.Particles.Arcade.Emitter"
            },
            "reverse": {
              "!doc": "Reverses all children in this group.\n\nThis operation applies only to immediate children and does not propagate to subgroups.",
              "!type": "fn()"
            },
            "filter": {
              "!doc": "Find children matching a certain predicate.\n\nFor example:\n\n    var healthyList = Group.filter(function(child, index, children) {\n        return child.health > 10 ? true : false;\n    }, true);\n    healthyList.callAll('attack');\n\nNote: Currently this will skip any children which are Groups themselves.",
              "!type": "fn(predicate: +Function, checkExists: +Boolean) -> +Phaser.ArraySet"
            },
            "maxParticles": {
              "!doc": "The total number of particles in this emitter.",
              "!type": "+Number"
            },
            "stage": {
              "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
              "!type": "+Phaser.Stage"
            },
            "addAll": {
              "!doc": "Adds the amount to the given property on all children in this group.\n\n`Group.addAll('x', 10)` will add 10 to the child.x value for each child.",
              "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
            },
            "width": {
              "!doc": "Gets or sets the width of the Emitter. This is the region in which a particle can be emitted.",
              "!type": "+Number"
            },
            "x": {
              "!doc": "Gets or sets the x position of the Emitter.",
              "!type": "+Number"
            },
            "ignoreDestroy": {
              "!doc": "A group with `ignoreDestroy` set to `true` ignores all calls to its `destroy` method.",
              "!type": "+Boolean"
            },
            "y": {
              "!doc": "Gets or sets the y position of the Emitter.",
              "!type": "+Number"
            },
            "exists": {
              "!doc": "If exists is true the group is updated, otherwise it is skipped.",
              "!type": "+Boolean"
            },
            "z": {
              "!doc": "The z-depth value of this object within its parent container/Group - the World is a Group as well.\nThis value must be unique for each child in a Group.",
              "!type": "+Number"
            },
            "divideAll": {
              "!doc": "Divides the given property by the amount on all children in this group.\n\n`Group.divideAll('x', 2)` will half the child.x value for each child.",
              "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
            },
            "setAllChildren": {
              "!doc": "Quickly set the same property across all children of this group, and any child Groups, to a new value.\n\nIf this group contains other Groups then the same property is set across their children as well, iterating down until it reaches the bottom.\nUnlike with `setAll` the property is NOT set on child Groups itself.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
              "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
            },
            "physicsBodyType": {
              "!doc": "If {@link #enableBody} is true this is the type of physics body that is created on new Sprites.\n\nThe valid values are {@link Phaser.Physics.ARCADE}, {@link Phaser.Physics.P2JS}, {@link Phaser.Physics.NINJA}, etc.",
              "!type": "+Number"
            },
            "angularDrag": {
              "!doc": "The angular drag component of particles launched from the emitter if they are rotating.",
              "!type": "+Number"
            },
            "getIndex": {
              "!doc": "Get the index position of the given child in this group, which should match the child's `z` property.",
              "!type": "fn(child: +Object) -> +Number"
            },
            "getBottom": {
              "!doc": "Returns the child at the bottom of this group.\n\nThe bottom child the child being displayed (rendered) below every other child.",
              "!type": "fn() -> +Object"
            },
            "replace": {
              "!doc": "Replaces a child of this group with the given newChild. The newChild cannot be a member of this group.",
              "!type": "fn(oldChild: +Object, newChild: +Object) -> +Object"
            },
            "maxParticleAlpha": {
              "!doc": "The maximum possible alpha value of a particle.",
              "!type": "+Number"
            },
            "resetChild": {
              "!doc": "Takes a child and if the `x` and `y` arguments are given it calls `child.reset(x, y)` on it.\n\nIf the `key` and optionally the `frame` arguments are given, it calls `child.loadTexture(key, frame)` on it.\n\nThe two operations are separate. For example if you just wish to load a new texture then pass `null` as the x and y values.",
              "!type": "fn(child: +DisplayObject, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
            },
            "frequency": {
              "!doc": "How often a particle is emitted in ms (if emitter is started with Explode === false).",
              "!type": "+Number"
            },
            "autoScale": {
              "!doc": "When a new Particle is emitted this controls if it will automatically scale in size. Use Emitter.setScale to configure.",
              "!type": "+Boolean"
            },
            "makeParticles": {
              "!doc": "This function generates a new set of particles for use by this emitter.\nThe particles are stored internally waiting to be emitted via Emitter.start.",
              "!type": "fn(keys: +Array, frames: +Array, quantity: +Number, collide: +Boolean, collideWorldBounds: +Boolean) -> +Phaser.Particles.Arcade.Emitter"
            },
            "getRandom": {
              "!doc": "Returns a random child from the group.",
              "!type": "fn(startIndex: +Number, length: +Number) -> +Object"
            },
            "forEachExists": {
              "!doc": "Call a function on each existing child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
              "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
            },
            "maxParticleScale": {
              "!doc": "The maximum possible scale of a particle. This is applied to the X and Y axis. If you need to control each axis see maxParticleScaleX.",
              "!type": "+Number"
            },
            "getTop": {
              "!doc": "Return the child at the top of this group.\n\nThe top child is the child displayed (rendered) above every other child.",
              "!type": "fn() -> +Object"
            },
            "create": {
              "!doc": "Creates a new Phaser.Sprite object and adds it to the top of this group.\n\nUse {@link #classType} to change the type of object created.",
              "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String, exists: +Boolean) -> +PIXI.DisplayObject"
            },
            "countDead": {
              "!doc": "Get the number of dead children in this group.",
              "!type": "fn() -> +Number"
            },
            "subAll": {
              "!doc": "Subtracts the amount from the given property on all children in this group.\n\n`Group.subAll('x', 10)` will minus 10 from the child.x value for each child.",
              "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
            },
            "fixedToCamera": {
              "!doc": "A Group that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Group.cameraOffset.\n\nNote that the cameraOffset values are in addition to any parent in the display list.\nSo if this Group was in a Group that has x: 200, then this will be added to the cameraOffset.x",
              "!type": "+Boolean"
            },
            "add": {
              "!doc": "Adds an existing object as the top child in this group.\n\nThe child is automatically added to the top of the group and is displayed on top of every previous child.\n\nIf Group.enableBody is set then a physics body will be created on the object, so long as one does not already exist.\n\nUse {@link #addAt} to control where a child is added. Use {@link #create} to create and add a new child.",
              "!type": "fn(child: +DisplayObject, silent: +Boolean) -> +PIXI.DisplayObject"
            },
            "area": {
              "!doc": "The area of the emitter. Particles can be randomly generated from anywhere within this rectangle.",
              "!type": "+Phaser.Rectangle"
            },
            "maxParticleSpeed": {
              "!doc": "The maximum possible velocity of a particle.",
              "!type": "+Phaser.Point"
            },
            "particleSendToBack": {
              "!doc": "If this is `true` then when the Particle is emitted it will be sent to the back of the Emitters display list.",
              "!type": "+Boolean"
            },
            "visible": {
              "!doc": "The visible state of the group. Non-visible Groups and all of their children are not rendered.",
              "!type": "+Boolean"
            },
            "swap": {
              "!doc": "Swaps the position of two children in this group.\n\nBoth children must be in this group, a child cannot be swapped with itself, and unparented children cannot be swapped.",
              "!type": "fn(child1: +Object, child2: +Object)"
            },
            "setScale": {
              "!doc": "A more compact way of setting the scale constraints of the particles.\nThe rate parameter, if set to a value above zero, lets you set the speed and ease which the Particle uses to change in scale from min to max across both axis.\nIf rate is zero, which is the default, the particle won't change scale during update, instead it will pick a random scale between min and max on emit.",
              "!type": "fn(minX: +Number, maxX: +Number, minY: +Number, maxY: +Number, rate: +Number, ease: +Function, yoyo: +Boolean) -> +Phaser.Particles.Arcade.Emitter"
            },
            "bottom": {
              "!doc": "Gets the bottom position of the Emitter.",
              "!type": "+Number"
            },
            "cameraOffset": {
              "!doc": "If this object is {@link #fixedToCamera} then this stores the x/y position offset relative to the top-left of the camera view.\nIf the parent of this Group is also `fixedToCamera` then the offset here is in addition to that and should typically be disabled.",
              "!type": "+Phaser.Point"
            },
            "setAlpha": {
              "!doc": "A more compact way of setting the alpha constraints of the particles.\nThe rate parameter, if set to a value above zero, lets you set the speed at which the Particle change in alpha from min to max.\nIf rate is zero, which is the default, the particle won't change alpha - instead it will pick a random alpha between min and max on emit.",
              "!type": "fn(min: +Number, max: +Number, rate: +Number, ease: +Function, yoyo: +Boolean) -> +Phaser.Particles.Arcade.Emitter"
            },
            "minRotation": {
              "!doc": "The minimum possible angular velocity of a particle.",
              "!type": "+Number"
            },
            "sort": {
              "!doc": "Sort the children in the group according to a particular key and ordering.\n\nCall this function to sort the group according to a particular key value and order.\n\nFor example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.\n\nInternally this uses a standard JavaScript Array sort, so everything that applies there also applies here, including\nalphabetical sorting, mixing strings and numbers, and Unicode sorting. See MDN for more details.",
              "!type": "fn(key: +String, order: +Number)"
            },
            "moveDown": {
              "!doc": "Moves the given child down one place in this group unless it's already at the bottom.",
              "!type": "fn(child: +Object) -> +Object"
            },
            "particleDrag": {
              "!doc": "The X and Y drag component of particles launched from the emitter.",
              "!type": "+Phaser.Point"
            },
            "hasProperty": {
              "!doc": "Checks if the child has the given property.\n\nWill scan up to 4 levels deep only.",
              "!type": "fn(child: +Object, key: +Array._string_) -> +Boolean"
            },
            "autoAlpha": {
              "!doc": "When a new Particle is emitted this controls if it will automatically change alpha. Use Emitter.setAlpha to configure.",
              "!type": "+Boolean"
            },
            "updateZ": {
              "!doc": "Internal method that re-applies all of the children's Z values.\n\nThis must be called whenever children ordering is altered so that their `z` indices are correctly updated.",
              "!type": "fn()"
            },
            "name": {
              "!doc": "A handy string name for this emitter. Can be set to anything.",
              "!type": "+String"
            },
            "maxRotation": {
              "!doc": "The maximum possible angular velocity of a particle.",
              "!type": "+Number"
            },
            "ascendingSortHandler": {
              "!doc": "An internal helper function for the sort process.",
              "!type": "fn(a: +Object, b: +Object)"
            },
            "position": {
              "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
              "!type": "+Phaser.Point"
            },
            "removeBetween": {
              "!doc": "Removes all children from this group whose index falls beteen the given startIndex and endIndex values.",
              "!type": "fn(startIndex: +Number, endIndex: +Number, destroy: +Boolean, silent: +Boolean)"
            },
            "removeFromHash": {
              "!doc": "Removes a child of this Group from the hash array.\nThis call will return false if the child is not in the hash.",
              "!type": "fn(child: +DisplayObject) -> +Boolean"
            },
            "alphaData": {
              "!doc": "An array of the calculated alpha easing data applied to particles with alphaRates > 0.",
              "!type": "+Array"
            },
            "classType": {
              "!doc": "The type of objects that will be created when using {@link #create} or {@link #createMultiple}.\n\nAny object may be used but it should extend either Sprite or Image and accept the same constructor arguments:\nwhen a new object is created it is passed the following parameters to its constructor: `(game, x, y, key, frame)`.",
              "!type": "+Object"
            },
            "next": {
              "!doc": "Advances the group cursor to the next (higher) object in the group.\n\nIf the cursor is at the end of the group (top child) it is moved the start of the group (bottom child).",
              "!type": "fn() -> +Object"
            },
            "cursor": {
              "!doc": "The current display object that the group cursor is pointing to, if any. (Can be set manually.)\n\nThe cursor is a way to iterate through the children in a Group using {@link #next} and {@link #previous}.",
              "!type": "+PIXI.DisplayObject"
            },
            "worldRotation": {
              "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
              "!type": "+Number"
            },
            "game": {
              "!doc": "A reference to the currently running Game.",
              "!type": "+Phaser.Game"
            },
            "renderable": {
              "!doc": "Can this object be rendered",
              "!type": "+Boolean"
            },
            "forEachDead": {
              "!doc": "Call a function on each dead child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
              "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
            },
            "update": {
              "!doc": "Called automatically by the game loop, decides when to launch particles and when to \"die\".",
              "!type": "fn()"
            },
            "scale": {
              "!doc": "The scale factor of the object.",
              "!type": "+Phaser.Point"
            },
            "countLiving": {
              "!doc": "Get the number of living children in this group.",
              "!type": "fn() -> +Number"
            },
            "remove": {
              "!doc": "Removes the given child from this group.\n\nThis will dispatch an `onRemovedFromGroup` event from the child (if it has one), and optionally destroy the child.\n\nIf the group cursor was referring to the removed child it is updated to refer to the next child.",
              "!type": "fn(child: +Object, destroy: +Boolean, silent: +Boolean) -> +Boolean"
            },
            "callAll": {
              "!doc": "Calls a function, specified by name, on all on children.\n\nThe function is called for all children regardless if they are dead or alive (see callAllExists for different options).\nAfter the method parameter and context you can add as many extra parameters as you like, which will all be passed to the child.",
              "!type": "fn(method: +String, context: +String, args: +Object)"
            },
            "total": {
              "!doc": "Total number of existing children in the group.",
              "!type": "+Number"
            },
            "setSize": {
              "!doc": "A more compact way of setting the width and height of the emitter.",
              "!type": "fn(width: +Number, height: +Number) -> +Phaser.Particles.Arcade.Emitter"
            },
            "particleClass": {
              "!doc": "For emitting your own particle class types. They must extend Phaser.Particle.",
              "!type": "+Object"
            },
            "alpha": {
              "!doc": "The alpha value of the group container.",
              "!type": "+Number"
            },
            "createMultiple": {
              "!doc": "Creates multiple Phaser.Sprite objects and adds them to the top of this group.\n\nUseful if you need to quickly generate a pool of identical sprites, such as bullets.\n\nBy default the sprites will be set to not exist and will be positioned at 0, 0 (relative to the group.x/y).\nUse {@link #classType} to change the type of object created.",
              "!type": "fn(quantity: +Number, key: +String, frame: +Number, exists: +Boolean)"
            },
            "setYSpeed": {
              "!doc": "A more compact way of setting the Y velocity range of the emitter.",
              "!type": "fn(min: +Number, max: +Number) -> +Phaser.Particles.Arcade.Emitter"
            },
            "setAll": {
              "!doc": "Quickly set the same property across all children of this group to a new value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be set on the group but not its children.\nIf you need that ability please see `Group.setAllChildren`.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
              "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
            },
            "on": {
              "!doc": "Determines whether the emitter is currently emitting particles. It is totally safe to directly toggle this.",
              "!type": "+Boolean"
            },
            "callAllExists": {
              "!doc": "Calls a function, specified by name, on all children in the group who exist (or do not exist).\n\nAfter the existsValue parameter you can add as many parameters as you like, which will all be passed to the child callback.",
              "!type": "fn(callback: +String, existsValue: +Boolean, parameter: +Object)"
            },
            "checkAll": {
              "!doc": "Quickly check that the same property across all children of this group is equal to the given value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be checked on the group but not its children.",
              "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, force: +Boolean)"
            },
            "previous": {
              "!doc": "Moves the group cursor to the previous (lower) child in the group.\n\nIf the cursor is at the start of the group (bottom child) it is moved to the end (top child).",
              "!type": "fn() -> +Object"
            },
            "forEach": {
              "!doc": "Call a function on each child in this group.\n\nAdditional arguments for the callback can be specified after the `checkExists` parameter. For example,\n\n    Group.forEach(awardBonusGold, this, true, 100, 500)\n\nwould invoke `awardBonusGold` function with the parameters `(child, 100, 500)`.\n\nNote: This check will skip any children which are Groups themselves.",
              "!type": "fn(callback: +Function, callbackContext: +Object, checkExists: +Boolean, args: +Object)"
            },
            "rotation": {
              "!doc": "The angle of rotation of the group container, in radians.\n\nThis will adjust the group container itself by modifying its rotation.\nThis will have no impact on the rotation value of its children, but it will update their worldTransform and on-screen position.",
              "!type": "+Number"
            },
            "start": {
              "!doc": "Call this function to start emitting particles.",
              "!type": "fn(explode: +Boolean, lifespan: +Number, frequency: +Number, quantity: +Number, forceQuantity: +Number) -> +Phaser.Particles.Arcade.Emitter"
            },
            "length": {
              "!doc": "Total number of children in this group, regardless of exists/alive status.",
              "!type": "+Number"
            },
            "sendToBack": {
              "!doc": "Sends the given child to the bottom of this group so it renders below all other children.",
              "!type": "fn(child: +Object) -> +Object"
            },
            "getAt": {
              "!doc": "Returns the child found at the given index within this group.",
              "!type": "fn(index: +Number) -> +PIXI.DisplayObject"
            },
            "pendingDestroy": {
              "!doc": "A Group is that has `pendingDestroy` set to `true` is flagged to have its destroy method \ncalled on the next logic update.\nYou can set it directly to flag the Group to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy a Group from within one of its own callbacks \nor a callback of one of its children.",
              "!type": "+Boolean"
            },
            "getFirstAlive": {
              "!doc": "Get the first child that is alive (`child.alive === true`).\n\nThis is handy for choosing a squad leader, etc.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no alive ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
              "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
            },
            "blendMode": {
              "!doc": "The blendMode as set on the particle when emitted from the Emitter. Defaults to NORMAL. Needs browser capable of supporting canvas blend-modes (most not available in WebGL)",
              "!type": "+Number"
            },
            "gravity": {
              "!doc": "Sets the `body.gravity.y` of each particle sprite to this value on launch.",
              "!type": "+Number"
            },
            "hitArea": {
              "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
              "!type": "+Phaser.Rectangle"
            }
          }
        },
        "!doc": "Arcade Particles is a Particle System integrated with Arcade Physics.",
        "!type": "fn()",
        "prototype": {}
      }
    },
    "LinkedList": {
      "!doc": "A basic Linked List data structure.\n\nThis implementation _modifies_ the `prev` and `next` properties of each item added:\n- The `prev` and `next` properties must be writable and should not be used for any other purpose.\n- Items _cannot_ be added to multiple LinkedLists at the same time.\n- Only objects can be added.",
      "!type": "fn()",
      "prototype": {
        "add": {
          "!doc": "Adds a new element to this linked list.",
          "!type": "fn(item: +Object) -> +Object"
        },
        "callAll": {
          "!doc": "Calls a function on all members of this list, using the member as the context for the callback.\nThe function must exist on the member.",
          "!type": "fn(callback: +Function)"
        },
        "next": {
          "!doc": "Next element in the list.",
          "!type": "+Object"
        },
        "total": {
          "!doc": "Number of elements in the list.",
          "!type": "+Number"
        },
        "last": {
          "!doc": "Last element in the list.",
          "!type": "+Object"
        },
        "prev": {
          "!doc": "Previous element in the list.",
          "!type": "+Object"
        },
        "reset": {
          "!doc": "Resets the first, last, next and previous node pointers in this list.",
          "!type": "fn()"
        },
        "remove": {
          "!doc": "Removes the given element from this linked list if it exists.",
          "!type": "fn(item: +Object)"
        },
        "first": {
          "!doc": "First element in the list.",
          "!type": "+Object"
        }
      }
    },
    "CIRCLE": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "AUTO": {
      "!doc": "AUTO renderer - picks between WebGL or Canvas based on device.",
      "!type": "+Number"
    },
    "ELLIPSE": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "scaleModes": {
      "!doc": "The scale modes that are supported by Pixi.\n\nThe DEFAULT scale mode affects the default scaling mode of future operations.\nIt can be re-assigned to either LINEAR or NEAREST, depending upon suitability.",
      "!type": "+Object"
    },
    "State": {
      "!doc": "This is a base State class which can be extended if you are creating your own game.\nIt provides quick access to common functions such as the camera, cache, input, match, sound and more.",
      "!type": "fn()",
      "prototype": {
        "loadUpdate": {
          "!doc": "loadUpdate is called during the Loader process. This only happens if you've set one or more assets to load in the preload method.",
          "!type": "fn()"
        },
        "paused": {
          "!doc": "This method will be called if the core game loop is paused.",
          "!type": "fn()"
        },
        "game": {
          "!doc": "This is a reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "loadRender": {
          "!doc": "loadRender is called during the Loader process. This only happens if you've set one or more assets to load in the preload method.\nThe difference between loadRender and render is that any objects you render in this method you must be sure their assets exist.",
          "!type": "fn()"
        },
        "tweens": {
          "!doc": "A reference to the tween manager.",
          "!type": "+Phaser.TweenManager"
        },
        "sound": {
          "!doc": "A reference to the Sound Manager which can create, play and stop sounds, as well as adjust global volume.",
          "!type": "+Phaser.SoundManager"
        },
        "update": {
          "!doc": "The update method is left empty for your own use.\nIt is called during the core game loop AFTER debug, physics, plugins and the Stage have had their preUpdate methods called.\nIt is called BEFORE Stage, Tweens, Sounds, Input, Physics, Particles and Plugins have had their postUpdate methods called.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "A reference to the Scale Manager which controls the way the game scales on different displays.",
          "!type": "+Phaser.ScaleManager"
        },
        "preload": {
          "!doc": "preload is called first. Normally you'd use this to load your game assets (or those needed for the current State)\nYou shouldn't create any objects in this method that require assets that you're also loading in this method, as\nthey won't yet be available.",
          "!type": "fn()"
        },
        "world": {
          "!doc": "A reference to the game world. All objects live in the Game World and its size is not bound by the display resolution.",
          "!type": "+Phaser.World"
        },
        "load": {
          "!doc": "A reference to the Loader, which you mostly use in the preload method of your state to load external assets.",
          "!type": "+Phaser.Loader"
        },
        "pauseUpdate": {
          "!doc": "pauseUpdate is called while the game is paused instead of preUpdate, update and postUpdate.",
          "!type": "fn()"
        },
        "physics": {
          "!doc": "A reference to the physics manager which looks after the different physics systems available within Phaser.",
          "!type": "+Phaser.Physics"
        },
        "create": {
          "!doc": "create is called once preload has completed, this includes the loading of any assets from the Loader.\nIf you don't have a preload method then create is the first method called in your State.",
          "!type": "fn()"
        },
        "camera": {
          "!doc": "A handy reference to World.camera.",
          "!type": "+Phaser.Camera"
        },
        "particles": {
          "!doc": "The Particle Manager. It is called during the core gameloop and updates any Particle Emitters it has created.",
          "!type": "+Phaser.Particles"
        },
        "render": {
          "!doc": "Nearly all display objects in Phaser render automatically, you don't need to tell them to render.\nHowever the render method is called AFTER the game renderer and plugins have rendered, so you're able to do any\nfinal post-processing style effects here. Note that this happens before plugins postRender takes place.",
          "!type": "fn()"
        },
        "make": {
          "!doc": "A reference to the GameObjectCreator which can be used to make new objects.",
          "!type": "+Phaser.GameObjectCreator"
        },
        "key": {
          "!doc": "The string based identifier given to the State when added into the State Manager.",
          "!type": "+String"
        },
        "add": {
          "!doc": "A reference to the GameObjectFactory which can be used to add new objects to the World.",
          "!type": "+Phaser.GameObjectFactory"
        },
        "init": {
          "!doc": "init is the very first function called when your State starts up. It's called before preload, create or anything else.\nIf you need to route the game away to another State you could do so here, or if you need to prepare a set of variables\nor objects before the preloading starts.",
          "!type": "fn()"
        },
        "cache": {
          "!doc": "A reference to the game cache which contains any loaded or generated assets, such as images, sound and more.",
          "!type": "+Phaser.Cache"
        },
        "preRender": {
          "!doc": "The preRender method is called after all Game Objects have been updated, but before any rendering takes place.",
          "!type": "fn()"
        },
        "rnd": {
          "!doc": "A reference to the seeded and repeatable random data generator.",
          "!type": "+Phaser.RandomDataGenerator"
        },
        "input": {
          "!doc": "A reference to the Input Manager.",
          "!type": "+Phaser.Input"
        },
        "stage": {
          "!doc": "A reference to the Stage.",
          "!type": "+Phaser.Stage"
        },
        "resize": {
          "!doc": "If your game is set to Scalemode RESIZE then each time the browser resizes it will call this function, passing in the new width and height.",
          "!type": "fn()"
        },
        "math": {
          "!doc": "A reference to Math class with lots of helpful functions.",
          "!type": "+Phaser.Math"
        },
        "time": {
          "!doc": "A reference to the game clock and timed events system.",
          "!type": "+Phaser.Time"
        },
        "resumed": {
          "!doc": "This method will be called when the core game loop resumes from a paused state.",
          "!type": "fn()"
        },
        "shutdown": {
          "!doc": "This method will be called when the State is shutdown (i.e. you switch to another state from this one).",
          "!type": "fn()"
        }
      }
    },
    "Video": {
      "!doc": "A Video object that takes a previously loaded Video from the Phaser Cache and handles playback of it.\n\nAlternatively it takes a getUserMedia feed from an active webcam and streams the contents of that to\nthe Video instead (see `startMediaStream` method)\n\nThe video can then be applied to a Sprite as a texture. If multiple Sprites share the same Video texture and playback\nchanges (i.e. you pause the video, or seek to a new time) then this change will be seen across all Sprites simultaneously.\n\nDue to a bug in IE11 you cannot play a video texture to a Sprite in WebGL. For IE11 force Canvas mode.\n\nIf you need each Sprite to be able to play a video fully independently then you will need one Video object per Sprite.\nPlease understand the obvious performance implications of doing this, and the memory required to hold videos in RAM.\n\nOn some mobile browsers such as iOS Safari, you cannot play a video until the user has explicitly touched the screen.\nThis works in the same way as audio unlocking. Phaser will handle the touch unlocking for you, however unlike with audio\nit's worth noting that every single Video needs to be touch unlocked, not just the first one. You can use the `changeSource`\nmethod to try and work around this limitation, but see the method help for details.\n\nSmall screen devices, especially iPod and iPhone will launch the video in its own native video player,\noutside of the Safari browser. There is no way to avoid this, it's a device imposed limitation.",
      "!type": "fn(game: +Phaser.Game, key: +String, url: +String)",
      "prototype": {
        "play": {
          "!doc": "Starts this video playing if it's not already doing so.",
          "!type": "fn(loop: +Boolean, playbackRate: +Number) -> +Phaser.Video"
        },
        "paused": {
          "!doc": "Gets or sets the paused state of the Video.\nIf the video is still touch locked (such as on iOS devices) this call has no effect.",
          "!type": "+Boolean"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "addToWorld": {
          "!doc": "Creates a new Phaser.Image object, assigns this Video to be its texture, adds it to the world then returns it.",
          "!type": "fn(x: +Number, y: +Number, anchorX: +Number, anchorY: +Number, scaleX: +Number, scaleY: +Number) -> +Phaser.Image"
        },
        "createVideoFromURL": {
          "!doc": "Creates a new Video element from the given URL.",
          "!type": "fn(url: +String, autoplay: +Boolean) -> +Phaser.Video"
        },
        "textureFrame": {
          "!doc": "The Frame this video uses for rendering.",
          "!type": "+Phaser.Frame"
        },
        "loop": {
          "!doc": "Gets or sets if the Video is set to loop.\nPlease note that at present some browsers (i.e. Chrome) do not support *seamless* video looping.\nIf the video isn't yet set this will always return false.",
          "!type": "+Boolean"
        },
        "onChangeSource": {
          "!doc": "This signal is dispatched if the Video source is changed. It sends 3 parameters: a reference to the Video object and the new width and height of the new video source.",
          "!type": "+Phaser.Signal"
        },
        "height": {
          "!doc": "The height of the video in pixels.",
          "!type": "+Number"
        },
        "add": {
          "!doc": "Updates the given Display Objects so they use this Video as their texture.\nThis will replace any texture they will currently have set.",
          "!type": "fn(object: +Phaser.Sprite) -> +Phaser.Video"
        },
        "unlock": {
          "!doc": "Enables the video on mobile devices, usually after the first touch.\nIf the SoundManager hasn't been unlocked then this will automatically unlock that as well.\nOnly one video can be pending unlock at any one time.",
          "!type": "fn()"
        },
        "setTouchLock": {
          "!doc": "Sets the Input Manager touch callback to be Video.unlock.\nRequired for mobile video unlocking. Mostly just used internally.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Destroys the Video object. This calls `Video.stop` and then `Video.removeVideoElement`.\nIf any Sprites are using this Video as their texture it is up to you to manage those.",
          "!type": "fn()"
        },
        "removeVideoElement": {
          "!doc": "Removes the Video element from the DOM by calling parentNode.removeChild on itself.\nAlso removes the autoplay and src attributes and nulls the reference.",
          "!type": "fn()"
        },
        "mute": {
          "!doc": "Gets or sets the muted state of the Video.",
          "!type": "+Boolean"
        },
        "onPlay": {
          "!doc": "This signal is dispatched when the Video starts to play. It sends 3 parameters: a reference to the Video object, if the video is set to loop or not and the playback rate.",
          "!type": "+Phaser.Signal"
        },
        "currentTime": {
          "!doc": "The current time of the video in seconds. If set the video will attempt to seek to that point in time.",
          "!type": "+Number"
        },
        "volume": {
          "!doc": "Gets or sets the volume of the Video, a value between 0 and 1. The value given is clamped to the range 0 to 1.",
          "!type": "+Number"
        },
        "stop": {
          "!doc": "Stops the video playing.\n\nThis removes all locally set signals.\n\nIf you only wish to pause playback of the video, to resume at a later time, use `Video.paused = true` instead.\nIf the video hasn't finished downloading calling `Video.stop` will not abort the download. To do that you need to\ncall `Video.destroy` instead.\n\nIf you are using a video stream from a webcam then calling Stop will disconnect the MediaStream session and disable the webcam.",
          "!type": "fn() -> +Phaser.Video"
        },
        "isStreaming": {
          "!doc": "Is there a streaming video source? I.e. from a webcam.",
          "!type": "+Boolean"
        },
        "disableTextureUpload": {
          "!doc": "If true this video will never send its image data to the GPU when its dirty flag is true. This only applies in WebGL.",
          "!type": "+Boolean"
        },
        "playing": {
          "!doc": "True if the video is currently playing (and not paused or ended), otherwise false.",
          "!type": "+Boolean"
        },
        "snapshot": {
          "!doc": "A snapshot grabbed from the video. This is initially black. Populate it by calling Video.grab().\nWhen called the BitmapData is updated with a grab taken from the current video playing or active video stream.\nIf Phaser has been compiled without BitmapData support this property will always be `null`.",
          "!type": "+Phaser.BitmapData"
        },
        "onAccess": {
          "!doc": "This signal is dispatched if the user allows access to their webcam.",
          "!type": "+Phaser.Signal"
        },
        "updateTexture": {
          "!doc": "Called automatically if the video source changes and updates the internal texture dimensions.\nThen dispatches the onChangeSource signal.",
          "!type": "fn(event: +Object, width: +Number, height: +Number)"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "video": {
          "!doc": "The HTML Video Element that is added to the document.",
          "!type": "+HTMLVideoElement"
        },
        "timeout": {
          "!doc": "The amount of ms allowed to elapsed before the Video.onTimeout signal is dispatched while waiting for webcam access.",
          "!type": "+Number"
        },
        "duration": {
          "!doc": "The duration of the video in seconds.",
          "!type": "+Number"
        },
        "changeSource": {
          "!doc": "On some mobile browsers you cannot play a video until the user has explicitly touched the video to allow it.\nPhaser handles this via the `setTouchLock` method. However if you have 3 different videos, maybe an \"Intro\", \"Start\" and \"Game Over\"\nsplit into three different Video objects, then you will need the user to touch-unlock every single one of them.\n\nYou can avoid this by using just one Video object and simply changing the video source. Once a Video element is unlocked it remains\nunlocked, even if the source changes. So you can use this to your benefit to avoid forcing the user to 'touch' the video yet again.\n\nAs you'd expect there are limitations. So far we've found that the videos need to be in the same encoding format and bitrate.\nThis method will automatically handle a change in video dimensions, but if you try swapping to a different bitrate we've found it\ncannot render the new video on iOS (desktop browsers cope better).\n\nWhen the video source is changed the video file is requested over the network. Listen for the `onChangeSource` signal to know\nwhen the new video has downloaded enough content to be able to be played. Previous settings such as the volume and loop state\nare adopted automatically by the new video.",
          "!type": "fn(src: +String, autoplay: +Boolean) -> +Phaser.Video"
        },
        "playbackRate": {
          "!doc": "Gets or sets the playback rate of the Video. This is the speed at which the video is playing.",
          "!type": "+Number"
        },
        "onTimeout": {
          "!doc": "This signal is dispatched if when asking for permission to use the webcam no response is given within a the Video.timeout limit.\nThis may be because the user has picked `Not now` in the permissions window, or there is a delay in establishing the LocalMediaStream.",
          "!type": "+Phaser.Signal"
        },
        "render": {
          "!doc": "If the game is running in WebGL this will push the texture up to the GPU if it's dirty.\nThis is called automatically if the Video is being used by a Sprite, otherwise you need to remember to call it in your render function.\nIf you wish to suppress this functionality set Video.disableTextureUpload to `true`.",
          "!type": "fn()"
        },
        "key": {
          "!doc": "The key of the Video in the Cache, if stored there. Will be `null` if this Video is using the webcam instead.",
          "!type": "+String"
        },
        "retry": {
          "!doc": "The current retry attempt.",
          "!type": "+Number"
        },
        "connectToMediaStream": {
          "!doc": "Connects to an external media stream for the webcam, rather than using a local one.",
          "!type": "fn(video: +HTMLVideoElement, stream: +MediaStream) -> +Phaser.Video"
        },
        "onError": {
          "!doc": "This signal is dispatched if an error occurs either getting permission to use the webcam (for a Video Stream) or when trying to play back a video file.",
          "!type": "+Phaser.Signal"
        },
        "startMediaStream": {
          "!doc": "Instead of playing a video file this method allows you to stream video data from an attached webcam.\n\nAs soon as this method is called the user will be prompted by their browser to \"Allow\" access to the webcam.\nIf they allow it the webcam feed is directed to this Video. Call `Video.play` to start the stream.\n\nIf they block the webcam the onError signal will be dispatched containing the NavigatorUserMediaError\nor MediaStreamError event.\n\nYou can optionally set a width and height for the stream. If set the input will be cropped to these dimensions.\nIf not given then as soon as the stream has enough data the video dimensions will be changed to match the webcam device.\nYou can listen for this with the onChangeSource signal.",
          "!type": "fn(captureAudio: +Boolean, width: +Number, height: +Number) -> +Phaser.Video"
        },
        "texture": {
          "!doc": "The PIXI.Texture.",
          "!type": "+PIXI.Texture"
        },
        "onComplete": {
          "!doc": "This signal is dispatched when the Video completes playback, i.e. enters an 'ended' state. Videos set to loop will never dispatch this signal.",
          "!type": "+Phaser.Signal"
        },
        "createVideoFromBlob": {
          "!doc": "Creates a new Video element from the given Blob. The Blob must contain the video data in the correct encoded format.\nThis method is typically called by the Phaser.Loader and Phaser.Cache for you, but is exposed publicly for convenience.",
          "!type": "fn(blob: +Blob) -> +Phaser.Video"
        },
        "retryLimit": {
          "!doc": "When starting playback of a video Phaser will monitor its readyState using a setTimeout call.\nThe setTimeout happens once every `Video.retryInterval` ms. It will carry on monitoring the video\nstate in this manner until the `retryLimit` is reached and then abort.",
          "!type": "+Number"
        },
        "videoStream": {
          "!doc": "The Video Stream data. Only set if this Video is streaming from the webcam via `startMediaStream`.",
          "!type": "+MediaStream"
        },
        "width": {
          "!doc": "The width of the video in pixels.",
          "!type": "+Number"
        },
        "progress": {
          "!doc": "The progress of this video. This is a value between 0 and 1, where 0 is the start and 1 is the end of the video.",
          "!type": "+Number"
        },
        "retryInterval": {
          "!doc": "The number of ms between each retry at monitoring the status of a downloading video.",
          "!type": "+Number"
        },
        "complete": {
          "!doc": "Called when the video completes playback (reaches and ended state).\nDispatches the Video.onComplete signal.",
          "!type": "fn()"
        },
        "grab": {
          "!doc": "Grabs the current frame from the Video or Video Stream and renders it to the Video.snapshot BitmapData.\n\nYou can optionally set if the BitmapData should be cleared or not, the alpha and the blend mode of the draw.\n\nIf you need more advanced control over the grabbing them call `Video.snapshot.copy` directly with the same parameters as BitmapData.copy.",
          "!type": "fn(clear: +Boolean, alpha: +Number, blendMode: +String) -> +Phaser.BitmapData"
        },
        "touchLocked": {
          "!doc": "true if this video is currently locked awaiting a touch event. This happens on some mobile devices, such as iOS.",
          "!type": "+Boolean"
        }
      }
    },
    "TweenManager": {
      "!doc": "Phaser.Game has a single instance of the TweenManager through which all Tween objects are created and updated.\nTweens are hooked into the game clock and pause system, adjusting based on the game state.\n\nTweenManager is based heavily on tween.js by http://soledadpenades.com.\nThe difference being that tweens belong to a games instance of TweenManager, rather than to a global TWEEN object.\nIt also has callbacks swapped for Signals and a few issues patched with regard to properties and completion errors.\nPlease see https://github.com/sole/tween.js for a full list of contributors.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "add": {
          "!doc": "Add a new tween into the TweenManager.",
          "!type": "fn(tween: +Phaser.Tween) -> +Phaser.Tween"
        },
        "isTweening": {
          "!doc": "Checks to see if a particular Sprite is currently being tweened.",
          "!type": "fn(object: +Object) -> +Boolean"
        },
        "pauseAll": {
          "!doc": "Pauses all currently running tweens.",
          "!type": "fn()"
        },
        "removeAll": {
          "!doc": "Remove all tweens running and in the queue. Doesn't call any of the tween onComplete events.",
          "!type": "fn()"
        },
        "game": {
          "!doc": "Local reference to game.",
          "!type": "+Phaser.Game"
        },
        "getAll": {
          "!doc": "Get all the tween objects in an array.",
          "!type": "fn() -> +Array._Phaser.Tween_"
        },
        "resumeAll": {
          "!doc": "Resumes all currently paused tweens.",
          "!type": "fn()"
        },
        "create": {
          "!doc": "Create a tween object for a specific object. The object can be any JavaScript object or Phaser object such as Sprite.",
          "!type": "fn(object: +Object) -> +Phaser.Tween"
        },
        "update": {
          "!doc": "Update all the tween objects you added to this manager.",
          "!type": "fn() -> +Boolean"
        },
        "frameBased": {
          "!doc": "Are all newly created Tweens frame or time based? A frame based tween will use the physics elapsed timer when updating. This means\nit will retain the same consistent frame rate, regardless of the speed of the device. The duration value given should\nbe given in frames.\n\nIf the Tween uses a time based update (which is the default) then the duration is given in milliseconds.\nIn this situation a 2000ms tween will last exactly 2 seconds, regardless of the device and how many visual updates the tween\nhas actually been through. For very short tweens you may wish to experiment with a frame based update instead.",
          "!type": "+Boolean"
        },
        "removeFrom": {
          "!doc": "Remove all tweens from a specific object, array of objects or Group.",
          "!type": "fn(obj: +Object, children: +Boolean)"
        },
        "remove": {
          "!doc": "Remove a tween from this manager.",
          "!type": "fn(tween: +Phaser.Tween)"
        }
      }
    },
    "ScaleManager": {
      "RESIZE": "+Number",
      "USER_SCALE": "+Number",
      "!doc": "Create a new ScaleManager object - this is done automatically by {@link Phaser.Game}\n\nThe `width` and `height` constructor parameters can either be a number which represents pixels or a string that represents a percentage: e.g. `800` (for 800 pixels) or `\"80%\"` for 80%.",
      "SHOW_ALL": "+Number",
      "NO_SCALE": "+Number",
      "!type": "fn(game: +Phaser.Game, width: +Number, height: +Number)",
      "prototype": {
        "scaleMode": {
          "!doc": "The scaling method used by the ScaleManager when not in fullscreen.\n\n<dl>\n  <dt>{@link Phaser.ScaleManager.NO_SCALE}<\/dt>\n  <dd>\n      The Game display area will not be scaled - even if it is too large for the canvas/screen.\n      This mode _ignores_ any applied scaling factor and displays the canvas at the Game size.\n  <\/dd>\n  <dt>{@link Phaser.ScaleManager.EXACT_FIT}<\/dt>\n  <dd>\n      The Game display area will be _stretched_ to fill the entire size of the canvas's parent element and/or screen.\n      Proportions are not maintained.\n  <\/dd>\n  <dt>{@link Phaser.ScaleManager.SHOW_ALL}<\/dt>\n  <dd>\n      Show the entire game display area while _maintaining_ the original aspect ratio.\n  <\/dd>\n  <dt>{@link Phaser.ScaleManager.RESIZE}<\/dt>\n  <dd>\n      The dimensions of the game display area are changed to match the size of the parent container.\n      That is, this mode _changes the Game size_ to match the display size.\n      <p>\n      Any manually set Game size (see {@link #setGameSize}) is ignored while in effect.\n  <\/dd>\n  <dt>{@link Phaser.ScaleManager.USER_SCALE}<\/dt>\n  <dd>\n      The game Display is scaled according to the user-specified scale set by {@link Phaser.ScaleManager#setUserScale setUserScale}.\n      <p>\n      This scale can be adjusted in the {@link Phaser.ScaleManager#setResizeCallback resize callback}\n      for flexible custom-sizing needs.\n  <\/dd>\n<\/dl>",
          "!type": "+Number"
        },
        "forceOrientation": {
          "!doc": "Force the game to run in only one orientation.\n\nThis enables generation of incorrect orientation signals and affects resizing but does not otherwise rotate or lock the orientation.\n\nOrientation checks are performed via the Screen Orientation API, if available in browser. This means it will check your monitor\norientation on desktop, or your device orientation on mobile, rather than comparing actual game dimensions. If you need to check the \nviewport dimensions instead and bypass the Screen Orientation API then set: `ScaleManager.compatibility.orientationFallback = 'viewport'`",
          "!type": "fn(forceLandscape: +Boolean, forcePortrait: +Boolean)"
        },
        "onOrientationChange": {
          "!doc": "This signal is dispatched when the orientation changes _or_ the validity of the current orientation changes.\n\nThe signal is supplied with the following arguments:\n- `scale` - the ScaleManager object\n- `prevOrientation`, a string - The previous orientation as per {@link Phaser.ScaleManager#screenOrientation screenOrientation}.\n- `wasIncorrect`, a boolean - True if the previous orientation was last determined to be incorrect.\n\nAccess the current orientation and validity with `scale.screenOrientation` and `scale.incorrectOrientation`.\nThus the following tests can be done:\n\n    // The orientation itself changed:\n    scale.screenOrientation !== prevOrientation\n    // The orientation just became incorrect:\n    scale.incorrectOrientation && !wasIncorrect\n\nIt is possible that this signal is triggered after {@link #forceOrientation} so the orientation\ncorrectness changes even if the orientation itself does not change.\n\nThis is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.",
          "!type": "+Phaser.Signal"
        },
        "isGameLandscape": {
          "!doc": "Returns true if the game dimensions are landscape (width > height).\nThis is especially useful to check when using the RESIZE scale mode \nbut wanting to maintain game orientation on desktop browsers, \nwhere typically the screen orientation will always be landscape regardless of the browser viewport.",
          "!type": "+Boolean"
        },
        "aspectRatio": {
          "!doc": "The aspect ratio of the scaled Display canvas.",
          "!type": "+Number"
        },
        "setGameSize": {
          "!doc": "Set the actual Game size.\nUse this instead of directly changing `game.width` or `game.height`.\n\nThe actual physical display (Canvas element size) depends on various settings including\n- Scale mode\n- Scaling factor\n- Size of Canvas's parent element or CSS rules such as min-height/max-height;\n- The size of the Window",
          "!type": "fn(width: +Number, height: +Number)"
        },
        "boundingParent": {
          "!doc": "The DOM element that is considered the Parent bounding element, if any.\n\nThis `null` if {@link #parentIsWindow} is true or if fullscreen mode is entered and {@link #fullScreenTarget} is specified.\nIt will also be null if there is no game canvas or if the game canvas has no parent.",
          "!type": "+DOMElement"
        },
        "minHeight": {
          "!doc": "Minimum height the canvas should be scaled to (in pixels).\nChange with {@link #setMinMax}.",
          "!type": "+Number"
        },
        "enterIncorrectOrientation": {
          "!doc": "This signal is dispatched when the browser enters an incorrect orientation, as defined by {@link #forceOrientation}.\n\nThis is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.",
          "!type": "+Phaser.Signal"
        },
        "fullScreenScaleMode": {
          "!doc": "The scaling method used by the ScaleManager when in fullscreen.\n\nSee {@link Phaser.ScaleManager#scaleMode scaleMode} for the different modes allowed.",
          "!type": "+Number"
        },
        "scaleFactorInversed": {
          "!doc": "The _current_ inversed scale factor. The displayed dimensions divided by the game dimensions.",
          "!type": "+Phaser.Point"
        },
        "onFullScreenChange": {
          "!doc": "This signal is dispatched when the browser enters or leaves fullscreen mode, if supported.\n\nThe signal is supplied with a single argument: `scale` (the ScaleManager). Use `scale.isFullScreen` to determine\nif currently running in Fullscreen mode.",
          "!type": "+Phaser.Signal"
        },
        "windowConstraints": {
          "!doc": "The edges on which to constrain the game Display/canvas in _addition_ to the restrictions of the parent container.\n\nThe properties are strings and can be '', 'visual', 'layout', or 'layout-soft'.\n- If 'visual', the edge will be constrained to the Window / displayed screen area\n- If 'layout', the edge will be constrained to the CSS Layout bounds\n- An invalid value is treated as 'visual'",
          "!type": "+Object"
        },
        "height": {
          "!doc": "Target height (in pixels) of the Display canvas.",
          "!type": "+Number"
        },
        "maxWidth": {
          "!doc": "Maximum width the canvas should be scaled to (in pixels).\nIf null it will scale to whatever width the browser can handle.\nChange with {@link #setMinMax}.",
          "!type": "+Number"
        },
        "isGamePortrait": {
          "!doc": "Returns true if the game dimensions are portrait (height > width).\nThis is especially useful to check when using the RESIZE scale mode \nbut wanting to maintain game orientation on desktop browsers, \nwhere typically the screen orientation will always be landscape regardless of the browser viewport.",
          "!type": "+Boolean"
        },
        "margin": {
          "!doc": "The Display canvas is aligned by adjusting the margins; the last margins are stored here.",
          "!type": "+Bounds_like"
        },
        "parentIsWindow": {
          "!doc": "If the parent container of the Game canvas is the browser window itself (i.e. document.body),\nrather than another div, this should set to `true`.\n\nThe {@link #parentNode} property is generally ignored while this is in effect.",
          "!type": "+Boolean"
        },
        "offset": {
          "!doc": "The offset coordinates of the Display canvas from the top-left of the browser window.\nThe is used internally by Phaser.Pointer (for Input) and possibly other types.",
          "!type": "+Phaser.Point"
        },
        "sourceAspectRatio": {
          "!doc": "The aspect ratio of the original game dimensions.",
          "!type": "+Number"
        },
        "stopFullScreen": {
          "!doc": "Stops / exits fullscreen mode, if active.",
          "!type": "fn() -> +Boolean"
        },
        "parseConfig": {
          "!doc": "Load configuration settings.",
          "!type": "fn(config: +Object)"
        },
        "destroy": {
          "!doc": "Destroys the ScaleManager and removes any event listeners.\nThis should probably only be called when the game is destroyed.",
          "!type": "fn()"
        },
        "createFullScreenTarget": {
          "!doc": "Creates a fullscreen target. This is called automatically as as needed when entering\nfullscreen mode and the resulting element is supplied to {@link #onFullScreenInit}.\n\nUse {@link #onFullScreenInit} to customize the created object.",
          "!type": "fn()"
        },
        "parentNode": {
          "!doc": "The _original_ DOM element for the parent of the Display canvas.\nThis may be different in fullscreen - see {@link #createFullScreenTarget}.\n\nThis should only be changed after moving the Game canvas to a different DOM parent.",
          "!type": "+DOMElement"
        },
        "onFullScreenInit": {
          "!doc": "This signal is dispatched when fullscreen mode is ready to be initialized but\nbefore the fullscreen request.\n\nThe signal is passed two arguments: `scale` (the ScaleManager), and an object in the form `{targetElement: DOMElement}`.\n\nThe `targetElement` is the {@link #fullScreenTarget} element,\nif such is assigned, or a new element created by {@link #createFullScreenTarget}.\n\nCustom CSS styling or resets can be applied to `targetElement` as required.\n\nIf `targetElement` is _not_ the same element as {@link #fullScreenTarget}:\n- After initialization the Display canvas is moved onto the `targetElement` for\n  the duration of the fullscreen mode, and restored to it's original DOM location when fullscreen is exited.\n- The `targetElement` is moved/re-parented within the DOM and may have its CSS styles updated.\n\nThe behavior of a pre-assigned target element is covered in {@link Phaser.ScaleManager#fullScreenTarget fullScreenTarget}.",
          "!type": "+Phaser.Signal"
        },
        "setResizeCallback": {
          "!doc": "Sets the callback that will be invoked before sizing calculations.\n\nThis is the appropriate place to call {@link #setUserScale} if needing custom dynamic scaling.\n\nThe callback is supplied with two arguments `scale` and `parentBounds` where `scale` is the ScaleManager\nand `parentBounds`, a Phaser.Rectangle, is the size of the Parent element.\n\nThis callback\n- May be invoked even though the parent container or canvas sizes have not changed\n- Unlike {@link #onSizeChange}, it runs _before_ the canvas is guaranteed to be updated\n- Will be invoked from `preUpdate`, _even when_ the game is paused    \n\nSee {@link #onSizeChange} for a better way of reacting to layout updates.",
          "!type": "fn(callback: +Function, context: +Object)"
        },
        "setUserScale": {
          "!doc": "Set a User scaling factor used in the USER_SCALE scaling mode.\n\nThe target canvas size is computed by:\n\n    canvas.width = (game.width * hScale) - hTrim\n    canvas.height = (game.height * vScale) - vTrim\n\nThis method can be used in the {@link Phaser.ScaleManager#setResizeCallback resize callback}.",
          "!type": "fn(hScale: +Number, vScale: +numer, hTrim: +Number, vTrim: +Number)"
        },
        "isLandscape": {
          "!doc": "Returns true if the screen orientation is in landscape mode.",
          "!type": "+Boolean"
        },
        "bounds": {
          "!doc": "The bounds of the scaled game. The x/y will match the offset of the canvas element and the width/height the scaled width and height.",
          "!type": "+Phaser.Rectangle"
        },
        "preUpdate": {
          "!doc": "The ScaleManager.preUpdate is called automatically by the core Game loop.",
          "!type": "fn()"
        },
        "compatibility": {
          "!doc": "Various compatibility settings.\nA value of \"(auto)\" indicates the setting is configured based on device and runtime information.\n\nA {@link #refresh} may need to be performed after making changes.",
          "!type": "+Object"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "dom": {
          "!doc": "Provides access to some cross-device DOM functions.",
          "!type": "+Phaser.DOM"
        },
        "scaleSprite": {
          "!doc": "Takes a Sprite or Image object and scales it to fit the given dimensions.\nScaling happens proportionally without distortion to the sprites texture.\nThe letterBox parameter controls if scaling will produce a letter-box effect or zoom the\nsprite until it fills the given values. Note that with letterBox set to false the scaled sprite may spill out over either\nthe horizontal or vertical sides of the target dimensions. If you wish to stop this you can crop the Sprite.",
          "!type": "fn(sprite: +Phaser.Sprite, width: +Number, height: +Number, letterBox: +Boolean) -> +Phaser.Sprite"
        },
        "isPortrait": {
          "!doc": "Returns true if the screen orientation is in portrait mode.",
          "!type": "+Boolean"
        },
        "setupScale": {
          "!doc": "Calculates and sets the game dimensions based on the given width and height.\n\nThis should _not_ be called when in fullscreen mode.",
          "!type": "fn(width: +Number, height: +Number)"
        },
        "pageAlignVertically": {
          "!doc": "When enabled the Display canvas will be vertically-aligned _in the Parent container_ (or {@link Phaser.ScaleManager#parentIsWindow window}).\n\nTo align vertically the Parent element should have a _non-collapsible_ height, such that it will maintain\na height _larger_ than the height of the contained Game canvas - the game canvas will then be scaled vertically\n_within_ the remaining available height dictated by the Parent element.\n\nOne way to prevent the parent from collapsing is to add an absolute \"min-height\" CSS property to the parent element.\nIf specifying a relative \"min-height/height\" or adjusting margins, the Parent height must still be non-collapsible (see note).\n\n_Note_: In version 2.2 the minimum document height is _not_ automatically set to the viewport/window height.\nTo automatically update the minimum document height set {@link Phaser.ScaleManager#compatibility compatibility.forceMinimumDocumentHeight} to true.\n\nVertical alignment is not applicable with the {@link .RESIZE} scaling mode.",
          "!type": "+Boolean"
        },
        "screenOrientation": {
          "!doc": "The _last known_ orientation of the screen, as defined in the Window Screen Web API.\nSee {@link Phaser.DOM.getScreenOrientation} for possible values.",
          "!type": "+String"
        },
        "maxHeight": {
          "!doc": "Maximum height the canvas should be scaled to (in pixels).\nIf null it will scale to whatever height the browser can handle.\nChange with {@link #setMinMax}.",
          "!type": "+Number"
        },
        "boot": {
          "!doc": "Start the ScaleManager.",
          "!type": "fn()"
        },
        "onFullScreenError": {
          "!doc": "This signal is dispatched when the browser fails to enter fullscreen mode;\nor if the device does not support fullscreen mode and `startFullScreen` is invoked.\n\nThe signal is supplied with a single argument: `scale` (the ScaleManager).",
          "!type": "+Phaser.Signal"
        },
        "onSizeChange": {
          "!doc": "This signal is dispatched when the size of the Display canvas changes _or_ the size of the Game changes. \nWhen invoked this is done _after_ the Canvas size/position have been updated.\n\nThis signal is _only_ called when a change occurs and a reflow may be required.\nFor example, if the canvas does not change sizes because of CSS settings (such as min-width)\nthen this signal will _not_ be triggered.\n\nUse this to handle responsive game layout options.\n\nThis is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.",
          "!type": "+Phaser.Signal"
        },
        "pageAlignHorizontally": {
          "!doc": "When enabled the Display canvas will be horizontally-aligned _in the Parent container_ (or {@link Phaser.ScaleManager#parentIsWindow window}).\n\nTo align horizontally across the page the Display canvas should be added directly to page;\nor the parent container should itself be horizontally aligned.\n\nHorizontal alignment is not applicable with the {@link .RESIZE} scaling mode.",
          "!type": "+Boolean"
        },
        "startFullScreen": {
          "!doc": "Start the browsers fullscreen mode - this _must_ be called from a user input Pointer or Mouse event.\n\nThe Fullscreen API must be supported by the browser for this to work - it is not the same as setting\nthe game size to fill the browser window. See {@link Phaser.ScaleManager#compatibility compatibility.supportsFullScreen} to check if the current\ndevice is reported to support fullscreen mode.\n\nThe {@link #fullScreenFailed} signal will be dispatched if the fullscreen change request failed or the game does not support the Fullscreen API.",
          "!type": "fn(antialias: +Boolean, allowTrampoline: +Boolean) -> +Boolean"
        },
        "trackParentInterval": {
          "!doc": "The maximum time (in ms) between dimension update checks for the Canvas's parent element (or window).\nUpdate checks normally happen quicker in response to other events.",
          "!type": "+Number"
        },
        "leaveIncorrectOrientation": {
          "!doc": "This signal is dispatched when the browser leaves an incorrect orientation, as defined by {@link #forceOrientation}.\n\nThis is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.",
          "!type": "+Phaser.Signal"
        },
        "scaleFactor": {
          "!doc": "The _current_ scale factor based on the game dimensions vs. the scaled dimensions.",
          "!type": "+Phaser.Point"
        },
        "refresh": {
          "!doc": "The \"refresh\" methods informs the ScaleManager that a layout refresh is required.\n\nThe ScaleManager automatically queues a layout refresh (eg. updates the Game size or Display canvas layout)\nwhen the browser is resized, the orientation changes, or when there is a detected change\nof the Parent size. Refreshing is also done automatically when public properties,\nsuch as {@link #scaleMode}, are updated or state-changing methods are invoked.\n\nThe \"refresh\" method _may_ need to be used in a few (rare) situtations when\n\n- a device change event is not correctly detected; or\n- the Parent size changes (and an immediate reflow is desired); or\n- the ScaleManager state is updated by non-standard means; or\n- certain {@link #compatibility} properties are manually changed.\n\nThe queued layout refresh is not immediate but will run promptly in an upcoming `preRender`.",
          "!type": "fn()"
        },
        "minWidth": {
          "!doc": "Minimum width the canvas should be scaled to (in pixels).\nChange with {@link #setMinMax}.",
          "!type": "+Number"
        },
        "forcePortrait": {
          "!doc": "If true, the game should only run in a portrait \nChange with {@link #forceOrientation}.",
          "!type": "+Boolean"
        },
        "fullScreenTarget": {
          "!doc": "If specified, this is the DOM element on which the Fullscreen API enter request will be invoked.\nThe target element must have the correct CSS styling and contain the Display canvas.\n\nThe elements style will be modified (ie. the width and height might be set to 100%)\nbut it will not be added to, removed from, or repositioned within the DOM.\nAn attempt is made to restore relevant style changes when fullscreen mode is left.\n\nFor pre-2.2.0 behavior set `game.scale.fullScreenTarget = game.canvas`.",
          "!type": "+DOMElement"
        },
        "parentScaleFactor": {
          "!doc": "The scale of the game in relation to its parent container.",
          "!type": "+Phaser.Point"
        },
        "incorrectOrientation": {
          "!doc": "True if {@link #forceLandscape} or {@link #forcePortrait} are set and do not agree with the browser orientation.\n\nThis value is not updated immediately.",
          "!type": "+Boolean"
        },
        "setMinMax": {
          "!doc": "Set the min and max dimensions for the Display canvas.\n\n_Note:_ The min/max dimensions are only applied in some cases\n- When the device is not in an incorrect orientation; or\n- The scale mode is EXACT_FIT when not in fullscreen",
          "!type": "fn(minWidth: +Number, minHeight: +Number, maxWidth: +Number, maxHeight: +Number)"
        },
        "grid": {
          "!doc": "_EXPERIMENTAL:_ A responsive grid on which you can align game objects.",
          "!type": "+Phaser.FlexGrid"
        },
        "getParentBounds": {
          "!doc": "Returns the computed Parent size/bounds that the Display canvas is allowed/expected to fill.\n\nIf in fullscreen mode or without parent (see {@link #parentIsWindow}),\nthis will be the bounds of the visual viewport itself.\n\nThis function takes the {@link #windowConstraints} into consideration - if the parent is partially outside\nthe viewport then this function may return a smaller than expected size.\n\nValues are rounded to the nearest pixel.",
          "!type": "fn(target: +Phaser.Rectangle) -> +Phaser.Rectangle"
        },
        "width": {
          "!doc": "Target width (in pixels) of the Display canvas.",
          "!type": "+Number"
        },
        "isFullScreen": {
          "!doc": "Returns true if the browser is in fullscreen mode, otherwise false.",
          "!type": "+Boolean"
        },
        "currentScaleMode": {
          "!doc": "Returns the current scale mode - for normal or fullscreen operation.\n\nSee {@link Phaser.ScaleManager#scaleMode scaleMode} for the different modes allowed.",
          "!type": "+Number"
        },
        "forceLandscape": {
          "!doc": "If true, the game should only run in a landscape orientation.\nChange with {@link #forceOrientation}.",
          "!type": "+Boolean"
        }
      },
      "EXACT_FIT": "+Number"
    },
    "Cache": {
      "TILEMAP": "+Number",
      "VIDEO": "+Number",
      "!doc": "Phaser has one single cache in which it stores all assets.\n\nThe cache is split up into sections, such as images, sounds, video, json, etc. All assets are stored using\na unique string-based key as their identifier. Assets stored in different areas of the cache can have the\nsame key, for example 'playerWalking' could be used as the key for both a sprite sheet and an audio file,\nbecause they are unique data types.\n\nThe cache is automatically populated by the Phaser.Loader. When you use the loader to pull in external assets\nsuch as images they are automatically placed into their respective cache. Most common Game Objects, such as\nSprites and Videos automatically query the cache to extract the assets they need on instantiation.\n\nYou can access the cache from within a State via `this.cache`. From here you can call any public method it has,\nincluding adding new entries to it, deleting them or querying them.\n\nUnderstand that almost without exception when you get an item from the cache it will return a reference to the\nitem stored in the cache, not a copy of it. Therefore if you retrieve an item and then modify it, the original\nobject in the cache will also be updated, even if you don't put it back into the cache again.\n\nBy default when you change State the cache is _not_ cleared, although there is an option to clear it should\nyour game require it. In a typical game set-up the cache is populated once after the main game has loaded and\nthen used as an asset store.",
      "BINARY": "+Number",
      "TEXT": "+Number",
      "JSON": "+Number",
      "prototype": {
        "addXML": {
          "!doc": "Add a new xml object into the cache.",
          "!type": "fn(key: +String, url: +String, data: +Object)"
        },
        "removeBitmapFont": {
          "!doc": "Removes a bitmap font from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "checkVideoKey": {
          "!doc": "Checks if the given key exists in the Video Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "checkImageKey": {
          "!doc": "Checks if the given key exists in the Image Cache. Note that this also includes Texture Atlases, Sprite Sheets and Retro Fonts.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "hasFrameData": {
          "!doc": "Check if the FrameData for the given key exists in the Image Cache.",
          "!type": "fn(key: +String, cache: +Number) -> +Boolean"
        },
        "addVideo": {
          "!doc": "Adds a Video file into the Cache. The file must have already been loaded, typically via Phaser.Loader.",
          "!type": "fn(key: +String, url: +String, data: +Object, isBlob: +Boolean)"
        },
        "getVideo": {
          "!doc": "Gets a Phaser.Video object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +Phaser.Video"
        },
        "getItem": {
          "!doc": "Get an item from a cache based on the given key and property.\n\nThis method is mostly used internally by other Cache methods such as `getImage` but is exposed\npublicly for your own use as well.",
          "!type": "fn(key: +String, cache: +Number, method: +String, property: +String) -> +Object"
        },
        "addPhysicsData": {
          "!doc": "Add a new physics data object to the Cache.",
          "!type": "fn(key: +String, url: +String, JSONData: +Object, format: +Number)"
        },
        "getFrameCount": {
          "!doc": "Get the total number of frames contained in the FrameData object specified by the given key.",
          "!type": "fn(key: +String, cache: +Number) -> +Number"
        },
        "addJSON": {
          "!doc": "Add a new json object into the cache.",
          "!type": "fn(key: +String, url: +String, data: +Object)"
        },
        "addTextureAtlas": {
          "!doc": "Add a new texture atlas to the Cache.",
          "!type": "fn(key: +String, url: +String, data: +Object, atlasData: +Object, format: +Number)"
        },
        "reloadSound": {
          "!doc": "Reload a Sound file from the server.",
          "!type": "fn(key: +String)"
        },
        "checkTextKey": {
          "!doc": "Checks if the given key exists in the Text Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "addRenderTexture": {
          "!doc": "Add a new Phaser.RenderTexture in to the cache.",
          "!type": "fn(key: +String, texture: +Phaser.RenderTexture)"
        },
        "checkJSONKey": {
          "!doc": "Checks if the given key exists in the JSON Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "removeJSON": {
          "!doc": "Removes a json object from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "checkShaderKey": {
          "!doc": "Checks if the given key exists in the Fragment Shader Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "removeXML": {
          "!doc": "Removes a xml object from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "checkBitmapFontKey": {
          "!doc": "Checks if the given key exists in the BitmapFont Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "addSpriteSheet": {
          "!doc": "Add a new sprite sheet in to the cache.",
          "!type": "fn(key: +String, url: +String, data: +Object, frameWidth: +Number, frameHeight: +Number, frameMax: +Number, margin: +Number, spacing: +Number)"
        },
        "decodedSound": {
          "!doc": "Add a new decoded sound.",
          "!type": "fn(key: +String, data: +Object)"
        },
        "addDefaultImage": {
          "!doc": "Adds a default image to be used in special cases such as WebGL Filters.\nIt uses the special reserved key of `__default`.\nThis method is called automatically when the Cache is created.\nThis image is skipped when `Cache.destroy` is called due to its internal requirements.",
          "!type": "fn()"
        },
        "checkPhysicsKey": {
          "!doc": "Checks if the given key exists in the Physics Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "getBitmapData": {
          "!doc": "Gets a BitmapData object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +Phaser.BitmapData"
        },
        "removeRenderTexture": {
          "!doc": "Removes a Render Texture from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "getFrameByName": {
          "!doc": "Get a single frame out of a frameData set by key.",
          "!type": "fn(key: +String, name: +String, cache: +Number) -> +Phaser.Frame"
        },
        "getText": {
          "!doc": "Gets a Text object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +Object"
        },
        "getTilemapData": {
          "!doc": "Gets a raw Tilemap data object from the cache. This will be in either CSV or JSON format.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +Object"
        },
        "addImage": {
          "!doc": "Adds an Image file into the Cache. The file must have already been loaded, typically via Phaser.Loader, but can also have been loaded into the DOM.\nIf an image already exists in the cache with the same key then it is removed and destroyed, and the new image inserted in its place.",
          "!type": "fn(key: +String, url: +String, data: +Object) -> +Object"
        },
        "removeBinary": {
          "!doc": "Removes a binary file from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "removeTilemap": {
          "!doc": "Removes a tilemap from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "destroy": {
          "!doc": "Clears the cache. Removes every local cache object reference.\nIf an object in the cache has a `destroy` method it will also be called.",
          "!type": "fn()"
        },
        "removeText": {
          "!doc": "Removes a text file from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "removeVideo": {
          "!doc": "Removes a video from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "checkKey": {
          "!doc": "Checks if a key for the given cache object type exists.",
          "!type": "fn(cache: +Number, key: +String) -> +Boolean"
        },
        "getRenderTexture": {
          "!doc": "Gets a RenderTexture object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +Object"
        },
        "getURL": {
          "!doc": "Get a cached object by the URL.\nThis only returns a value if you set Cache.autoResolveURL to `true` *before* starting the preload of any assets.\nBe aware that every call to this function makes a DOM src query, so use carefully and double-check for implications in your target browsers/devices.",
          "!type": "fn(url: +String) -> +Object"
        },
        "onSoundUnlock": {
          "!doc": "This event is dispatched when the sound system is unlocked via a touch event on cellular devices.",
          "!type": "+Phaser.Signal"
        },
        "checkSoundKey": {
          "!doc": "Checks if the given key exists in the Sound Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "removeSpriteSheet": {
          "!doc": "Removes a Sprite Sheet from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "removeCanvas": {
          "!doc": "Removes a canvas from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "addBitmapData": {
          "!doc": "Add a BitmapData object to the cache.",
          "!type": "fn(key: +String, bitmapData: +Phaser.BitmapData, frameData: +Phaser.FrameData) -> +Phaser.BitmapData"
        },
        "addShader": {
          "!doc": "Adds a Fragment Shader in to the Cache. The file must have already been loaded, typically via Phaser.Loader.",
          "!type": "fn(key: +String, url: +String, data: +Object)"
        },
        "getBinary": {
          "!doc": "Gets a binary object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +Object"
        },
        "getImage": {
          "!doc": "Gets a Image object from the cache. This returns a DOM Image object, not a Phaser.Image object.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.\n\nOnly the Image cache is searched, which covers images loaded via Loader.image, Sprite Sheets and Texture Atlases.\n\nIf you need the image used by a bitmap font or similar then please use those respective 'get' methods.",
          "!type": "fn(key: +String, full: +Boolean) -> +Phaser.Image"
        },
        "checkBitmapDataKey": {
          "!doc": "Checks if the given key exists in the BitmapData Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "removeSound": {
          "!doc": "Removes a sound from the cache.\n\nIf any `Phaser.Sound` objects use the audio file in the cache that you remove with this method, they will\n_automatically_ destroy themselves. If you wish to have full control over when Sounds are destroyed then\nyou must finish your house-keeping and destroy them all yourself first, before calling this method.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "getJSON": {
          "!doc": "Gets a JSON object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.\n\nYou can either return the object by reference (the default), or return a clone\nof it by setting the `clone` argument to `true`.",
          "!type": "fn(key: +String, clone: +Boolean) -> +Object"
        },
        "updateFrameData": {
          "!doc": "Replaces a set of frameData with a new Phaser.FrameData object.",
          "!type": "fn(key: +String, frameData: +Number, cache: +Number)"
        },
        "checkTilemapKey": {
          "!doc": "Checks if the given key exists in the Tilemap Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "clearGLTextures": {
          "!doc": "Empties out all of the GL Textures from Images stored in the cache.\nThis is called automatically when the WebGL context is lost and then restored.",
          "!type": "fn()"
        },
        "reloadSoundComplete": {
          "!doc": "Fires the onSoundUnlock event when the sound has completed reloading.",
          "!type": "fn(key: +String)"
        },
        "game": {
          "!doc": "Local reference to game.",
          "!type": "+Phaser.Game"
        },
        "getBitmapFont": {
          "!doc": "Gets a Bitmap Font object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +Phaser.BitmapFont"
        },
        "addSound": {
          "!doc": "Adds a Sound file into the Cache. The file must have already been loaded, typically via Phaser.Loader.",
          "!type": "fn(key: +String, url: +String, data: +Object, webAudio: +Boolean, audioTag: +Boolean)"
        },
        "getFrame": {
          "!doc": "Get a single frame by key. You'd only do this to get the default Frame created for a non-atlas/spritesheet image.",
          "!type": "fn(key: +String, cache: +Number) -> +Phaser.Frame"
        },
        "checkXMLKey": {
          "!doc": "Checks if the given key exists in the XML Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "addTilemap": {
          "!doc": "Add a new tilemap to the Cache.",
          "!type": "fn(key: +String, url: +String, mapData: +Object, format: +Number)"
        },
        "getBaseTexture": {
          "!doc": "Gets a PIXI.BaseTexture by key from the given Cache.",
          "!type": "fn(key: +String, cache: +Number) -> +PIXI.BaseTexture"
        },
        "getPhysicsData": {
          "!doc": "Gets a Physics Data object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.\n\nYou can get either the entire data set, a single object or a single fixture of an object from it.",
          "!type": "fn(key: +String, object: +String, fixtureKey: +String) -> +Object"
        },
        "isSoundDecoded": {
          "!doc": "Check if the given sound has finished decoding.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "checkBinaryKey": {
          "!doc": "Checks if the given key exists in the Binary Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "addBitmapFont": {
          "!doc": "Add a new Bitmap Font to the Cache.",
          "!type": "fn(key: +String, url: +String, data: +Object, atlasData: +Object, atlasType: +String, xSpacing: +Number, ySpacing: +Number)"
        },
        "isSoundReady": {
          "!doc": "Check if the given sound is ready for playback.\nA sound is considered ready when it has finished decoding and the device is no longer touch locked.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "checkURL": {
          "!doc": "Checks if the given URL has been loaded into the Cache.\nThis method will only work if Cache.autoResolveURL was set to `true` before any preloading took place.\nThe method will make a DOM src call to the URL given, so please be aware of this for certain file types, such as Sound files on Firefox\nwhich may cause double-load instances.",
          "!type": "fn(url: +String) -> +Boolean"
        },
        "getCanvas": {
          "!doc": "Gets a Canvas object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +Object"
        },
        "removeBitmapData": {
          "!doc": "Removes a bitmap data from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "updateSound": {
          "!doc": "Updates the sound object in the cache.",
          "!type": "fn(key: +String)"
        },
        "getShader": {
          "!doc": "Gets a fragment shader object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +String"
        },
        "getFrameData": {
          "!doc": "Gets a Phaser.FrameData object from the Image Cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String, cache: +Number) -> +Phaser.FrameData"
        },
        "addMissingImage": {
          "!doc": "Adds an image to be used when a key is wrong / missing.\nIt uses the special reserved key of `__missing`.\nThis method is called automatically when the Cache is created.\nThis image is skipped when `Cache.destroy` is called due to its internal requirements.",
          "!type": "fn()"
        },
        "addText": {
          "!doc": "Add a new text data.",
          "!type": "fn(key: +String, url: +String, data: +Object)"
        },
        "checkTextureKey": {
          "!doc": "Checks if the given key exists in the Texture Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "getXML": {
          "!doc": "Gets an XML object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +Object"
        },
        "getFrameByIndex": {
          "!doc": "Get a single frame out of a frameData set by key.",
          "!type": "fn(key: +String, index: +Number, cache: +Number) -> +Phaser.Frame"
        },
        "addCanvas": {
          "!doc": "Add a new canvas object in to the cache.",
          "!type": "fn(key: +String, canvas: +HTMLCanvasElement, context: +CanvasRenderingContext2D)"
        },
        "getKeys": {
          "!doc": "Gets all keys used in the requested Cache.",
          "!type": "fn(cache: +Number) -> +Array"
        },
        "addBinary": {
          "!doc": "Add a binary object in to the cache.",
          "!type": "fn(key: +String, binaryData: +Object)"
        },
        "removeImage": {
          "!doc": "Removes an image from the cache.\n\nYou can optionally elect to destroy it as well. This calls BaseTexture.destroy on it.\n\nNote that this only removes it from the Phaser and PIXI Caches. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String, removeFromPixi: +Boolean)"
        },
        "removePhysics": {
          "!doc": "Removes a physics data file from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "getPixiTexture": {
          "!doc": "Gets a PIXI.Texture by key from the PIXI.TextureCache.\n\nIf the texture isn't found in the cache, then it searches the Phaser Image Cache and\ncreates a new PIXI.Texture object which is then returned.",
          "!type": "fn(key: +String) -> +PIXI.Texture"
        },
        "checkRenderTextureKey": {
          "!doc": "Checks if the given key exists in the Render Texture Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "checkCanvasKey": {
          "!doc": "Checks if the given key exists in the Canvas Cache.",
          "!type": "fn(key: +String) -> +Boolean"
        },
        "removeShader": {
          "!doc": "Removes a shader from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "removeTextureAtlas": {
          "!doc": "Removes a Texture Atlas from the cache.\n\nNote that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere\nthen it will persist in memory.",
          "!type": "fn(key: +String)"
        },
        "getTextureFrame": {
          "!doc": "Get a single texture frame by key.\n\nYou'd only do this to get the default Frame created for a non-atlas / spritesheet image.",
          "!type": "fn(key: +String) -> +Phaser.Frame"
        },
        "autoResolveURL": {
          "!doc": "Automatically resolve resource URLs to absolute paths for use with the Cache.getURL method.",
          "!type": "+Boolean"
        },
        "getPixiBaseTexture": {
          "!doc": "Gets a PIXI.BaseTexture by key from the PIXI.BaseTextureCache.\n\nIf the texture isn't found in the cache, then it searches the Phaser Image Cache.",
          "!type": "fn(key: +String) -> +PIXI.BaseTexture"
        },
        "getSoundData": {
          "!doc": "Gets a raw Sound data object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +Object"
        },
        "getSound": {
          "!doc": "Gets a Phaser.Sound object from the cache.\n\nThe object is looked-up based on the key given.\n\nNote: If the object cannot be found a `console.warn` message is displayed.",
          "!type": "fn(key: +String) -> +Phaser.Sound"
        }
      },
      "SHADER": "+Number",
      "TEXTURE": "+Number",
      "IMAGE": "+Number",
      "CANVAS": "+Number",
      "BITMAPFONT": "+Number",
      "XML": "+Number",
      "SOUND": "+Number",
      "RENDER_TEXTURE": "+Number",
      "PHYSICS": "+Number",
      "!type": "fn(game: +Phaser.Game)",
      "BITMAPDATA": "+Number"
    },
    "Ellipse": {
      "!doc": "Creates a Ellipse object. A curve on a plane surrounding two focal points.",
      "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number)",
      "prototype": {
        "bottom": {
          "!doc": "Gets or sets the bottom of the ellipse.",
          "!type": "+Number"
        },
        "right": {
          "!doc": "Gets or sets the value of the rightmost point of the ellipse.",
          "!type": "+Number"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "getBounds": {
          "!doc": "Returns the framing rectangle of the ellipse as a Phaser.Rectangle object.",
          "!type": "fn() -> +Phaser.Rectangle"
        },
        "copyFrom": {
          "!doc": "Copies the x, y, width and height properties from any given object to this Ellipse.",
          "!type": "fn(source: +Object) -> +Phaser.Ellipse"
        },
        "empty": {
          "!doc": "Gets or sets the empty state of the ellipse.",
          "!type": "+Boolean"
        },
        "copyTo": {
          "!doc": "Copies the x, y, width and height properties from this Ellipse to any given object.",
          "!type": "fn(dest: +Object) -> +Object"
        },
        "random": {
          "!doc": "Returns a uniformly distributed random point from anywhere within this Ellipse.",
          "!type": "fn(out: +Phaser.Point) -> +Phaser.Point"
        },
        "contains": {
          "!doc": "Return true if the given x/y coordinates are within this Ellipse object.",
          "!type": "fn(x: +Number, y: +Number) -> +Boolean"
        },
        "top": {
          "!doc": "Gets or sets the top of the ellipse.",
          "!type": "+Number"
        },
        "left": {
          "!doc": "The left coordinate of the Ellipse. The same as the X coordinate.",
          "!type": "+Object"
        },
        "clone": {
          "!doc": "Returns a new Ellipse object with the same values for the x, y, width, and height properties as this Ellipse object.",
          "!type": "fn(output: +Phaser.Ellipse) -> +Phaser.Ellipse"
        },
        "x": {
          "!doc": "The X coordinate of the upper-left corner of the framing rectangle of this ellipse.",
          "!type": "+Number"
        },
        "width": {
          "!doc": "The overall width of this ellipse.",
          "!type": "+Number"
        },
        "setTo": {
          "!doc": "Sets the members of the Ellipse to the specified values.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number) -> +Phaser.Ellipse"
        },
        "y": {
          "!doc": "The Y coordinate of the upper-left corner of the framing rectangle of this ellipse.",
          "!type": "+Number"
        },
        "toString": {
          "!doc": "Returns a string representation of this object.",
          "!type": "fn() -> +String"
        },
        "height": {
          "!doc": "The overall height of this ellipse.",
          "!type": "+Number"
        }
      }
    },
    "Loader": {
      "PHYSICS_PHASER_JSON": "+Number",
      "!doc": "The Loader handles loading all external content such as Images, Sounds, Texture Atlases and data files.\n\nThe loader uses a combination of tag loading (eg. Image elements) and XHR and provides progress and completion callbacks.\n\nParallel loading (see {@link #enableParallel}) is supported and enabled by default.\nLoad-before behavior of parallel resources is controlled by synchronization points as discussed in {@link #withSyncPoint}.\n\nTexture Atlases can be created with tools such as [Texture Packer](https://www.codeandweb.com/texturepacker/phaser) and\n[Shoebox](http://renderhjs.net/shoebox/)",
      "TEXTURE_ATLAS_XML_STARLING": "+Number",
      "TEXTURE_ATLAS_JSON_HASH": "+Number",
      "!type": "fn(game: +Phaser.Game)",
      "TEXTURE_ATLAS_JSON_PYXEL": "+Number",
      "prototype": {
        "progressFloat": {
          "!doc": "The non-rounded load progress value (from 0.0 to 100.0).\n\nA general indicator of the progress.\nIt is possible for the progress to decrease, after `onLoadStart`, if more files are dynamically added.",
          "!type": "+Number"
        },
        "_withSyncPointDepth;": {
          "!doc": "A counter: if more than zero, files will be automatically added as a synchronization point.",
          "!type": "+Number"
        },
        "atlas": {
          "!doc": "Adds a Texture Atlas file to the current load queue.\n\nTo create the Texture Atlas you can use tools such as:\n\n[Texture Packer](https://www.codeandweb.com/texturepacker/phaser)\n[Shoebox](http://renderhjs.net/shoebox/)\n\nIf using Texture Packer we recommend you enable \"Trim sprite names\".\nIf your atlas software has an option to \"rotate\" the resulting frames, you must disable it.\n\nYou can choose to either load the data externally, by providing a URL to a json file.\nOr you can pass in a JSON object or String via the `atlasData` parameter.\nIf you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.\n\nIf URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getImage(key)`. JSON files are automatically parsed upon load.\nIf you need to control when the JSON is parsed then use `Loader.text` instead and parse the JSON file as needed.\n\nThe URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the textureURL isn't specified then the Loader will take the key and create a filename from that.\nFor example if the key is \"player\" and textureURL is null then the Loader will set the URL to be \"player.png\".\nThe same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will\nset the atlasURL to be the key. For example if the key is \"player\" the atlasURL will be set to \"player.json\".\n\nIf you do not desire this action then provide URLs and / or a data object.",
          "!type": "fn(key: +String, textureURL: +String, atlasURL: +String, atlasData: +Object, format: +Number) -> +Phaser.Loader"
        },
        "atlasJSONHash": {
          "!doc": "Adds a Texture Atlas file to the current load queue.\n\nUnlike `Loader.atlas` this call expects the atlas data to be in a JSON Hash format.\n\nTo create the Texture Atlas you can use tools such as:\n\n[Texture Packer](https://www.codeandweb.com/texturepacker/phaser)\n[Shoebox](http://renderhjs.net/shoebox/)\n\nIf using Texture Packer we recommend you enable \"Trim sprite names\".\nIf your atlas software has an option to \"rotate\" the resulting frames, you must disable it.\n\nYou can choose to either load the data externally, by providing a URL to a json file.\nOr you can pass in a JSON object or String via the `atlasData` parameter.\nIf you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.\n\nIf URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getImage(key)`. JSON files are automatically parsed upon load.\nIf you need to control when the JSON is parsed then use `Loader.text` instead and parse the JSON file as needed.\n\nThe URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the textureURL isn't specified then the Loader will take the key and create a filename from that.\nFor example if the key is \"player\" and textureURL is null then the Loader will set the URL to be \"player.png\".\nThe same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will\nset the atlasURL to be the key. For example if the key is \"player\" the atlasURL will be set to \"player.json\".\n\nIf you do not desire this action then provide URLs and / or a data object.",
          "!type": "fn(key: +String, textureURL: +String, atlasURL: +String, atlasData: +Object) -> +Phaser.Loader"
        },
        "checkKeyExists": {
          "!doc": "Check whether a file/asset with a specific key is queued to be loaded.\n\nTo access a loaded asset use Phaser.Cache, eg. {@link Phaser.Cache#checkImageKey}",
          "!type": "fn(type: +String, key: +String) -> +Boolean"
        },
        "resetLocked": {
          "!doc": "If true all calls to Loader.reset will be ignored. Useful if you need to create a load queue before swapping to a preloader state.",
          "!type": "+Boolean"
        },
        "onFileError": {
          "!doc": "This event is dispatched when a file (or pack) errors as a result of the load request.\n\nFor files it will be triggered before `onFileComplete`. For packs it will be triggered before `onPackComplete`.\n\nParams: `(file key, file)`",
          "!type": "+Phaser.Signal"
        },
        "bitmapFont": {
          "!doc": "Adds Bitmap Font files to the current load queue.\n\nTo create the Bitmap Font files you can use:\n\nBMFont (Windows, free): http://www.angelcode.com/products/bmfont/\nGlyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner\nLittera (Web-based, free): http://kvazars.com/littera/\n\nYou can choose to either load the data externally, by providing a URL to an xml file.\nOr you can pass in an XML object or String via the `xmlData` parameter.\nIf you pass a String the data is automatically run through `Loader.parseXML` and then immediately added to the Phaser.Cache.\n\nIf URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getBitmapFont(key)`. XML files are automatically parsed upon load.\nIf you need to control when the XML is parsed then use `Loader.text` instead and parse the XML file as needed.\n\nThe URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the textureURL isn't specified then the Loader will take the key and create a filename from that.\nFor example if the key is \"megaFont\" and textureURL is null then the Loader will set the URL to be \"megaFont.png\".\nThe same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will\nset the atlasURL to be the key. For example if the key is \"megaFont\" the atlasURL will be set to \"megaFont.xml\".\n\nIf you do not desire this action then provide URLs and / or a data object.",
          "!type": "fn(key: +String, textureURL: +String, atlasURL: +String, atlasData: +Object, xSpacing: +Number, ySpacing: +Number) -> +Phaser.Loader"
        },
        "getAsset": {
          "!doc": "Find a file/asset with a specific key.\n\nOnly assets in the download file queue will be found.",
          "!type": "fn(type: +String, key: +String) -> +Object"
        },
        "totalLoadedPacks": {
          "!doc": "Returns the number of asset packs that have already been loaded, even if they errored.",
          "!type": "fn() -> +Number"
        },
        "path": {
          "!doc": "The value of `path`, if set, is placed before any _relative_ file path given. For example:\n\n`load.path = \"images/sprites/\";\nload.image(\"ball\", \"ball.png\");\nload.image(\"tree\", \"level1/oaktree.png\");\nload.image(\"boom\", \"http://server.com/explode.png\");`\n\nWould load the `ball` file from `images/sprites/ball.png` and the tree from\n`images/sprites/level1/oaktree.png` but the file `boom` would load from the URL\ngiven as it's an absolute URL.\n\nPlease note that the path is added before the filename but *after* the baseURL (if set.)\n\nThe string _must_ end with a \"/\".",
          "!type": "+String"
        },
        "removeAll": {
          "!doc": "Remove all file loading requests - this is _insufficient_ to stop current loading. Use `reset` instead.",
          "!type": "fn()"
        },
        "xml": {
          "!doc": "Adds an XML file to the current load queue.\n\nThe file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getXML(key)`.\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\nand no URL is given then the Loader will set the URL to be \"alien.xml\". It will always add `.xml` as the extension.\nIf you do not desire this action then provide a URL.",
          "!type": "fn(key: +String, url: +String, overwrite: +Boolean) -> +Phaser.Loader"
        },
        "text": {
          "!doc": "Adds a Text file to the current load queue.\n\nThe file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getText(key)`\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\nand no URL is given then the Loader will set the URL to be \"alien.txt\". It will always add `.txt` as the extension.\nIf you do not desire this action then provide a URL.",
          "!type": "fn(key: +String, url: +String, overwrite: +Boolean) -> +Phaser.Loader"
        },
        "audioSprite": {
          "!doc": "Adds an audio sprite file to the current load queue.\n\nThe file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nAudio Sprites are a combination of audio files and a JSON configuration.\n\nThe JSON follows the format of that created by https://github.com/tonistiigi/audiosprite\n\nRetrieve the file via `Cache.getSoundData(key)`.\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.",
          "!type": "fn(key: +String, urls: +Array, jsonURL: +String, jsonData: +String, autoDecode: +Boolean) -> +Phaser.Loader"
        },
        "atlasJSONArray": {
          "!doc": "Adds a Texture Atlas file to the current load queue.\n\nUnlike `Loader.atlasJSONHash` this call expects the atlas data to be in a JSON Array format.\n\nTo create the Texture Atlas you can use tools such as:\n\n[Texture Packer](https://www.codeandweb.com/texturepacker/phaser)\n[Shoebox](http://renderhjs.net/shoebox/)\n\nIf using Texture Packer we recommend you enable \"Trim sprite names\".\nIf your atlas software has an option to \"rotate\" the resulting frames, you must disable it.\n\nYou can choose to either load the data externally, by providing a URL to a json file.\nOr you can pass in a JSON object or String via the `atlasData` parameter.\nIf you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.\n\nIf URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getImage(key)`. JSON files are automatically parsed upon load.\nIf you need to control when the JSON is parsed then use `Loader.text` instead and parse the JSON file as needed.\n\nThe URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the textureURL isn't specified then the Loader will take the key and create a filename from that.\nFor example if the key is \"player\" and textureURL is null then the Loader will set the URL to be \"player.png\".\nThe same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will\nset the atlasURL to be the key. For example if the key is \"player\" the atlasURL will be set to \"player.json\".\n\nIf you do not desire this action then provide URLs and / or a data object.",
          "!type": "fn(key: +String, textureURL: +String, atlasURL: +String, atlasData: +Object) -> +Phaser.Loader"
        },
        "useXDomainRequest": {
          "!doc": "If true and if the browser supports XDomainRequest, it will be used in preference for XHR.\n\nThis is only relevant for IE 9 and should _only_ be enabled for IE 9 clients when required by the server/CDN.",
          "!type": "+Boolean"
        },
        "image": {
          "!doc": "Adds an Image to the current load queue.\n\nThe file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n\nPhaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the image via `Cache.getImage(key)`\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\nand no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension.\nIf you do not desire this action then provide a URL.",
          "!type": "fn(key: +String, url: +String, overwrite: +Boolean) -> +Phaser.Loader"
        },
        "images": {
          "!doc": "Adds an array of images to the current load queue.\n\nIt works by passing each element of the array to the Loader.image method.\n\nThe files are **not** loaded immediately after calling this method. The files are added to the queue ready to be loaded when the loader starts.\n\nPhaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\n\nThe keys must be unique Strings. They are used to add the files to the Phaser.Cache upon successful load.\n\nRetrieve the images via `Cache.getImage(key)`\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\nand no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension.\nIf you do not desire this action then provide a URL.",
          "!type": "fn(keys: +Array, urls: +Array) -> +Phaser.Loader"
        },
        "cache": {
          "!doc": "Local reference to the Phaser.Cache.",
          "!type": "+Phaser.Cache"
        },
        "audiosprite": {
          "!doc": "A legacy alias for Loader.audioSprite. Please see that method for documentation.",
          "!type": "fn(key: +String, urls: +Array, jsonURL: +String, jsonData: +String, autoDecode: +Boolean) -> +Phaser.Loader"
        },
        "setPreloadSprite": {
          "!doc": "Set a Sprite to be a \"preload\" sprite by passing it to this method.\n\nA \"preload\" sprite will have its width or height crop adjusted based on the percentage of the loader in real-time.\nThis allows you to easily make loading bars for games.\n\nThe sprite will automatically be made visible when calling this.",
          "!type": "fn(sprite: +Phaser.Sprite, direction: +Number)"
        },
        "onFileComplete": {
          "!doc": "This event is dispatched when a file has either loaded or failed to load.\n\nAny function bound to this will receive the following parameters:\n\nprogress, file key, success?, total loaded files, total files\n\nWhere progress is a number between 1 and 100 (inclusive) representing the percentage of the load.",
          "!type": "+Phaser.Signal"
        },
        "onLoadStart": {
          "!doc": "This event is dispatched when the loading process starts: before the first file has been requested,\nbut after all the initial packs have been loaded.",
          "!type": "+Phaser.Signal"
        },
        "crossOrigin": {
          "!doc": "The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'.",
          "!type": "+Boolean"
        },
        "onFileStart": {
          "!doc": "This event is dispatched immediately before a file starts loading.\nIt's possible the file may fail (eg. download error, invalid format) after this event is sent.\n\nParams: `(progress, file key, file url)`",
          "!type": "+Phaser.Signal"
        },
        "pack": {
          "!doc": "Add a JSON resource pack ('packfile') to the Loader.\n\nA packfile is a JSON file that contains a list of assets to the be loaded.\nPlease see the example 'loader/asset pack' in the Phaser Examples repository.\n\nPacks are always put before the first non-pack file that is not loaded / loading.\n\nThis means that all packs added before any loading has started are added to the front\nof the file queue, in the order added.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nThe URL of the packfile can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.",
          "!type": "fn(key: +String, url: +String, data: +Object, callbackContext: +Object) -> +Phaser.Loader"
        },
        "script": {
          "!doc": "Adds a JavaScript file to the current load queue.\n\nThe file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n\nThe key must be a unique String.\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\nand no URL is given then the Loader will set the URL to be \"alien.js\". It will always add `.js` as the extension.\nIf you do not desire this action then provide a URL.\n\nUpon successful load the JavaScript is automatically turned into a script tag and executed, so be careful what you load!\n\nA callback, which will be invoked as the script tag has been created, can also be specified.\nThe callback must return relevant `data`.",
          "!type": "fn(key: +String, url: +String, callback: +Function, callbackContext: +Object) -> +Phaser.Loader"
        },
        "isLoading": {
          "!doc": "True if the Loader is in the process of loading the queue.",
          "!type": "+Boolean"
        },
        "maxParallelDownloads": {
          "!doc": "The number of concurrent / parallel resources to try and fetch at once.\n\nMany current browsers limit 6 requests per domain; this is slightly conservative.",
          "!type": "+Number"
        },
        "onLoadComplete": {
          "!doc": "This event is dispatched when the final file in the load queue has either loaded or failed.",
          "!type": "+Phaser.Signal"
        },
        "onPackComplete": {
          "!doc": "This event is dispatched when an asset pack has either loaded or failed to load.\n\nThis is called when the asset pack manifest file has loaded and successfully added its contents to the loader queue.\n\nParams: `(pack key, success?, total packs loaded, total packs)`",
          "!type": "+Phaser.Signal"
        },
        "binary": {
          "!doc": "Adds a binary file to the current load queue.\n\nThe file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getBinary(key)`.\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\nand no URL is given then the Loader will set the URL to be \"alien.bin\". It will always add `.bin` as the extension.\nIf you do not desire this action then provide a URL.\n\nIt will be loaded via xhr with a responseType of \"arraybuffer\". You can specify an optional callback to process the file after load.\nWhen the callback is called it will be passed 2 parameters: the key of the file and the file data.\n\nWARNING: If a callback is specified the data will be set to whatever it returns. Always return the data object, even if you didn't modify it.",
          "!type": "fn(key: +String, url: +String, callback: +Function, callbackContext: +Object) -> +Phaser.Loader"
        },
        "reset": {
          "!doc": "Reset the loader and clear any queued assets. If `Loader.resetLocked` is true this operation will abort.\n\nThis will abort any loading and clear any queued assets.\n\nOptionally you can clear any associated events.",
          "!type": "fn(hard: +Boolean, clearEvents: +Boolean)"
        },
        "hasLoaded": {
          "!doc": "True if all assets in the queue have finished loading.",
          "!type": "+Boolean"
        },
        "transformUrl": {
          "!doc": "Transforms the asset URL.\n\nThe default implementation prepends the baseURL if the url doesn't begin with http or //",
          "!type": "fn(url: +String, file: +Object) -> +String"
        },
        "preloadSprite": {
          "!doc": "You can optionally link a progress sprite with {@link Phaser.Loader#setPreloadSprite setPreloadSprite}.\n\nThis property is an object containing: sprite, rect, direction, width and height",
          "!type": "+Object"
        },
        "getAssetIndex": {
          "!doc": "Get the queue-index of the file/asset with a specific key.\n\nOnly assets in the download file queue will be found.",
          "!type": "fn(type: +String, key: +String) -> +Number"
        },
        "shader": {
          "!doc": "Adds a fragment shader file to the current load queue.\n\nThe file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getShader(key)`.\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"blur\"\nand no URL is given then the Loader will set the URL to be \"blur.frag\". It will always add `.frag` as the extension.\nIf you do not desire this action then provide a URL.",
          "!type": "fn(key: +String, url: +String, overwrite: +Boolean) -> +Phaser.Loader"
        },
        "game": {
          "!doc": "Local reference to game.",
          "!type": "+Phaser.Game"
        },
        "withSyncPoints": {
          "!doc": "Add a synchronization point to the assets/files added within the supplied callback.\n\nA synchronization point denotes that an asset _must_ be completely loaded before\nsubsequent assets can be loaded. An asset marked as a sync-point does not need to wait\nfor previous assets to load (unless they are sync-points). Resources, such as packs, may still\nbe downloaded around sync-points, as long as they do not finalize loading.",
          "!type": "fn(callback: +Function, callbackContext: +Object) -> +Phaser.Loader"
        },
        "video": {
          "!doc": "Adds a video file to the current load queue.\n\nThe file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getVideo(key)`.\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nYou don't need to preload a video in order to play it in your game. See `Video.createVideoFromURL` for details.",
          "!type": "fn(key: +String, urls: +String, loadEvent: +String, asBlob: +Boolean) -> +Phaser.Loader"
        },
        "totalQueuedFiles": {
          "!doc": "Returns the number of files still waiting to be processed in the load queue. This value decreases as each file in the queue is loaded.",
          "!type": "fn() -> +Number"
        },
        "tilemap": {
          "!doc": "Adds a Tile Map data file to the current load queue.\n\nYou can choose to either load the data externally, by providing a URL to a json file.\nOr you can pass in a JSON object or String via the `data` parameter.\nIf you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.\n\nIf a URL is provided the file is **not** loaded immediately after calling this method, but is added to the load queue.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getTilemapData(key)`. JSON files are automatically parsed upon load.\nIf you need to control when the JSON is parsed then use `Loader.text` instead and parse the text file as needed.\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the URL isn't specified and no data is given then the Loader will take the key and create a filename from that.\nFor example if the key is \"level1\" and no URL or data is given then the Loader will set the URL to be \"level1.json\".\nIf you set the format to be Tilemap.CSV it will set the URL to be \"level1.csv\" instead.\n\nIf you do not desire this action then provide a URL or data object.",
          "!type": "fn(key: +String, url: +String, data: +Object, format: +Number) -> +Phaser.Loader"
        },
        "removeFile": {
          "!doc": "Remove a file/asset from the loading queue.\n\nA file that is loaded or has started loading cannot be removed.",
          "!type": "fn(type: +String, key: +String)"
        },
        "totalQueuedPacks": {
          "!doc": "Returns the number of asset packs still waiting to be processed in the load queue. This value decreases as each pack in the queue is loaded.",
          "!type": "fn() -> +Number"
        },
        "physics": {
          "!doc": "Adds a physics data file to the current load queue.\n\nThe data must be in `Lime + Corona` JSON format. [Physics Editor](https://www.codeandweb.com) by code'n'web exports in this format natively.\n\nYou can choose to either load the data externally, by providing a URL to a json file.\nOr you can pass in a JSON object or String via the `data` parameter.\nIf you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.\n\nIf a URL is provided the file is **not** loaded immediately after calling this method, but is added to the load queue.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getJSON(key)`. JSON files are automatically parsed upon load.\nIf you need to control when the JSON is parsed then use `Loader.text` instead and parse the text file as needed.\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the URL isn't specified and no data is given then the Loader will take the key and create a filename from that.\nFor example if the key is \"alien\" and no URL or data is given then the Loader will set the URL to be \"alien.json\".\nIt will always use `.json` as the extension.\n\nIf you do not desire this action then provide a URL or data object.",
          "!type": "fn(key: +String, url: +String, data: +Object, format: +String) -> +Phaser.Loader"
        },
        "json": {
          "!doc": "Adds a JSON file to the current load queue.\n\nThe file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getJSON(key)`. JSON files are automatically parsed upon load.\nIf you need to control when the JSON is parsed then use `Loader.text` instead and parse the text file as needed.\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\nand no URL is given then the Loader will set the URL to be \"alien.json\". It will always add `.json` as the extension.\nIf you do not desire this action then provide a URL.",
          "!type": "fn(key: +String, url: +String, overwrite: +Boolean) -> +Phaser.Loader"
        },
        "audio": {
          "!doc": "Adds an audio file to the current load queue.\n\nThe file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getSound(key)`.\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nMobile warning: There are some mobile devices (certain iPad 2 and iPad Mini revisions) that cannot play 48000 Hz audio.\nWhen they try to play the audio becomes extremely distorted and buzzes, eventually crashing the sound system.\nThe solution is to use a lower encoding rate such as 44100 Hz.",
          "!type": "fn(key: +String, urls: +String, autoDecode: +Boolean) -> +Phaser.Loader"
        },
        "spritesheet": {
          "!doc": "Adds a Sprite Sheet to the current load queue.\n\nThe file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.\n\nTo clarify the terminology that Phaser uses: A Sprite Sheet is an image containing frames, usually of an animation, that are all equal\ndimensions and often in sequence. For example if the frame size is 32x32 then every frame in the sprite sheet will be that size.\nSometimes (outside of Phaser) the term \"sprite sheet\" is used to refer to a texture atlas.\nA Texture Atlas works by packing together images as best it can, using whatever frame sizes it likes, often with cropping and trimming\nthe frames in the process. Software such as Texture Packer, Flash CC or Shoebox all generate texture atlases, not sprite sheets.\nIf you've got an atlas then use `Loader.atlas` instead.\n\nThe key must be a unique String. It is used to add the image to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getImage(key)`. Sprite sheets, being image based, live in the same Cache as all other Images.\n\nThe URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\nand no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension.\nIf you do not desire this action then provide a URL.",
          "!type": "fn(key: +String, url: +String, frameWidth: +Number, frameHeight: +Number, frameMax: +Number, margin: +Number, spacing: +Number) -> +Phaser.Loader"
        },
        "start": {
          "!doc": "Start loading the assets. Normally you don't need to call this yourself as the StateManager will do so.",
          "!type": "fn()"
        },
        "atlasXML": {
          "!doc": "Adds a Texture Atlas file to the current load queue.\n\nThis call expects the atlas data to be in the Starling XML data format.\n\nTo create the Texture Atlas you can use tools such as:\n\n[Texture Packer](https://www.codeandweb.com/texturepacker/phaser)\n[Shoebox](http://renderhjs.net/shoebox/)\n\nIf using Texture Packer we recommend you enable \"Trim sprite names\".\nIf your atlas software has an option to \"rotate\" the resulting frames, you must disable it.\n\nYou can choose to either load the data externally, by providing a URL to an xml file.\nOr you can pass in an XML object or String via the `atlasData` parameter.\nIf you pass a String the data is automatically run through `Loader.parseXML` and then immediately added to the Phaser.Cache.\n\nIf URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.\n\nThe key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.\n\nRetrieve the file via `Cache.getImage(key)`. XML files are automatically parsed upon load.\nIf you need to control when the XML is parsed then use `Loader.text` instead and parse the XML file as needed.\n\nThe URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n\nIf the textureURL isn't specified then the Loader will take the key and create a filename from that.\nFor example if the key is \"player\" and textureURL is null then the Loader will set the URL to be \"player.png\".\nThe same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will\nset the atlasURL to be the key. For example if the key is \"player\" the atlasURL will be set to \"player.xml\".\n\nIf you do not desire this action then provide URLs and / or a data object.",
          "!type": "fn(key: +String, textureURL: +String, atlasURL: +String, atlasData: +Object) -> +Phaser.Loader"
        },
        "addToFileList": {
          "!doc": "Internal function that adds a new entry to the file list. Do not call directly.",
          "!type": "fn(type: +String, key: +String, url: +String, properties: +Object, overwrite: +Boolean, extension: +String) -> +Phaser.Loader"
        },
        "baseURL": {
          "!doc": "If you want to append a URL before the path of any asset you can set this here.\nUseful if allowing the asset base url to be configured outside of the game code.\nThe string _must_ end with a \"/\".",
          "!type": "+String"
        },
        "totalLoadedFiles": {
          "!doc": "Returns the number of files that have already been loaded, even if they errored.",
          "!type": "fn() -> +Number"
        },
        "addSyncPoint": {
          "!doc": "Add a synchronization point to a specific file/asset in the load queue.\n\nThis has no effect on already loaded assets.",
          "!type": "fn(type: +String, key: +String) -> +Phaser.Loader"
        },
        "resize": {
          "!doc": "Called automatically by ScaleManager when the game resizes in RESIZE scalemode.\n\nThis can be used to adjust the preloading sprite size, eg.",
          "!type": "fn()"
        },
        "progress": {
          "!doc": "The rounded load progress percentage value (from 0 to 100). See {@link Phaser.Loader#progressFloat}.",
          "!type": "+Number"
        },
        "enableParallel": {
          "!doc": "If true (the default) then parallel downloading will be enabled.\n\nTo disable all parallel downloads this must be set to false prior to any resource being loaded.",
          "!type": "+Boolean"
        },
        "replaceInFileList": {
          "!doc": "Internal function that replaces an existing entry in the file list with a new one. Do not call directly.",
          "!type": "fn(type: +String, key: +String, url: +String, properties: +Object)"
        }
      },
      "TEXTURE_ATLAS_JSON_ARRAY": "+Number",
      "PHYSICS_LIME_CORONA_JSON": "+Number"
    },
    "Time": {
      "!doc": "This is the core internal game clock.\n\nIt manages the elapsed time and calculation of elapsed values, used for game object motion and tweens,\nand also handles the standard Timer pool.\n\nTo create a general timed event, use the master {@link Phaser.Timer} accessible through {@link Phaser.Time.events events}.\n\nThere are different *types* of time in Phaser:\n\n- ***Game time*** always runs at the speed of time in real life.\n\n  Unlike wall-clock time, *game time stops when Phaser is paused*.\n\n  Game time is used for {@link Phaser.Timer timer events}.\n\n- ***Physics time*** represents the amount of time given to physics calculations.\n\n  *When {@link #slowMotion} is in effect physics time runs slower than game time.*\n  Like game time, physics time stops when Phaser is paused.\n\n  Physics time is used for physics calculations and {@link Phaser.Tween tweens}.\n\n- {@link https://en.wikipedia.org/wiki/Wall-clock_time ***Wall-clock time***} represents the duration between two events in real life time.\n\n  This time is independent of Phaser and always progresses, regardless of if Phaser is paused.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "game": {
          "!doc": "Local reference to game.",
          "!type": "+Phaser.Game"
        },
        "fpsMin": {
          "!doc": "Advanced timing result: The lowest rate the fps has dropped to.\n\nOnly calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.\nThis value can be manually reset.",
          "!type": "+Number"
        },
        "timeToCall": {
          "!doc": "The value that setTimeout needs to work out when to next update",
          "!type": "+Number"
        },
        "update": {
          "!doc": "Updates the game clock and if enabled the advanced timing data. This is called automatically by Phaser.Game.",
          "!type": "fn(time: +Number)"
        },
        "totalElapsedSeconds": {
          "!doc": "The number of seconds that have elapsed since the game was started.",
          "!type": "fn() -> +Number"
        },
        "elapsed": {
          "!doc": "Elapsed time since the last time update, in milliseconds, based on `now`.\n\nThis value _may_ include time that the game is paused/inactive.\n\n_Note:_ This is updated only once per game loop - even if multiple logic update steps are done.\nUse {@link Phaser.Timer#physicsTime physicsTime} as a basis of game/logic calculations instead.",
          "!type": "+Number"
        },
        "removeAll": {
          "!doc": "Remove all Timer objects, regardless of their state and clears all Timers from the {@link Phaser.Time#events events} timer.",
          "!type": "fn()"
        },
        "advancedTiming": {
          "!doc": "If true then advanced profiling, including the fps rate, fps min/max, suggestedFps and msMin/msMax are updated.",
          "!type": "+Boolean"
        },
        "fpsMax": {
          "!doc": "Advanced timing result: The highest rate the fps has reached (usually no higher than 60fps).\n\nOnly calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.\nThis value can be manually reset.",
          "!type": "+Number"
        },
        "now": {
          "!doc": "An increasing value representing cumulative milliseconds since an undisclosed epoch.\n\nWhile this value is in milliseconds and can be used to compute time deltas,\nit must must _not_ be used with `Date.now()` as it may not use the same epoch / starting reference.\n\nThe source may either be from a high-res source (eg. if RAF is available) or the standard Date.now;\nthe value can only be relied upon within a particular game instance.",
          "!type": "+Number"
        },
        "create": {
          "!doc": "Creates a new stand-alone Phaser.Timer object.",
          "!type": "fn(autoDestroy: +Boolean) -> +Phaser.Timer"
        },
        "physicsElapsedMS": {
          "!doc": "The physics update delta, in milliseconds - equivalent to `physicsElapsed * 1000`.",
          "!type": "+Number"
        },
        "desiredFpsMult": {
          "!doc": "The desiredFps multiplier as used by Game.update.",
          "!type": "+Number"
        },
        "boot": {
          "!doc": "Called automatically by Phaser.Game after boot. Should not be called directly.",
          "!type": "fn()"
        },
        "suggestedFps": {
          "!doc": "The suggested frame rate for your game, based on an averaged real frame rate.\nThis value is only populated if `Time.advancedTiming` is enabled.\n\n_Note:_ This is not available until after a few frames have passed; until then\nit's set to the same value as desiredFps.",
          "!type": "+Number"
        },
        "events": {
          "!doc": "A {@link Phaser.Timer} object bound to the master clock (this Time object) which events can be added to.",
          "!type": "+Phaser.Timer"
        },
        "elapsedSecondsSince": {
          "!doc": "How long has passed since the given time (in seconds).",
          "!type": "fn(since: +Number) -> +Number"
        },
        "add": {
          "!doc": "Adds an existing Phaser.Timer object to the Timer pool.",
          "!type": "fn(timer: +Phaser.Timer) -> +Phaser.Timer"
        },
        "elapsedSince": {
          "!doc": "How long has passed since the given time.",
          "!type": "fn(since: +Number) -> +Number"
        },
        "frames": {
          "!doc": "Advanced timing result: The number of render frames record in the last second.\n\nOnly calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.",
          "!type": "+Number"
        },
        "desiredFps": {
          "!doc": "The desired frame rate of the game. Defaults to 60.",
          "!type": "+Number"
        },
        "fps": {
          "!doc": "Advanced timing result: Frames per second.\n\nOnly calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.",
          "!type": "+Number"
        },
        "refresh": {
          "!doc": "Refreshes the Time.time and Time.elapsedMS properties from the system clock.",
          "!type": "fn()"
        },
        "prevTime": {
          "!doc": "The `now` when the previous update occurred.",
          "!type": "+Number"
        },
        "slowMotion": {
          "!doc": "Scaling factor to make the game move smoothly in slow motion\n- 1.0 = normal speed\n- 2.0 = half speed",
          "!type": "+Number"
        },
        "msMax": {
          "!doc": "Advanced timing result: The maximum amount of time the game has taken between consecutive frames.\n\nOnly calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.\nThis value can be manually reset.",
          "!type": "+Number"
        },
        "physicsElapsed": {
          "!doc": "The physics update delta, in fractional seconds.\n\nThis should be used as an applicable multiplier by all logic update steps (eg. `preUpdate/postUpdate/update`)\nto ensure consistent game timing. Game/logic timing can drift from real-world time if the system\nis unable to consistently maintain the desired FPS.\n\nWith fixed-step updates this is normally equivalent to `1.0 / desiredFps`.",
          "!type": "+Number"
        },
        "pauseDuration": {
          "!doc": "Records how long the game was last paused, in milliseconds.\n(This is not updated until the game is resumed.)",
          "!type": "+Number"
        },
        "timeExpected": {
          "!doc": "The time when the next call is expected when using setTimer to control the update loop",
          "!type": "+Number"
        },
        "reset": {
          "!doc": "Resets the private _started value to now and removes all currently running Timers.",
          "!type": "fn()"
        },
        "msMin": {
          "!doc": "Advanced timing result: The minimum amount of time the game has taken between consecutive frames.\n\nOnly calculated if {@link Phaser.Time#advancedTiming advancedTiming} is enabled.\nThis value can be manually reset.",
          "!type": "+Number"
        },
        "time": {
          "!doc": "The `Date.now()` value when the time was last updated.",
          "!type": "+Number"
        },
        "elapsedMS": {
          "!doc": "The time in ms since the last time update, in milliseconds, based on `time`.\n\nThis value is corrected for game pauses and will be \"about zero\" after a game is resumed.\n\n_Note:_ This is updated once per game loop - even if multiple logic update steps are done.\nUse {@link Phaser.Timer#physicsTime physicsTime} as a basis of game/logic calculations instead.",
          "!type": "+Number"
        }
      }
    },
    "Touch": {
      "!doc": "Phaser.Touch handles touch events with your game. Note: Android 2.x only supports 1 touch event at once, no multi-touch.\n\nYou should not normally access this class directly, but instead use a Phaser.Pointer object which normalises all game input for you.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "onTouchStart": {
          "!doc": "The internal method that handles the touchstart event from the browser.",
          "!type": "fn(event: +TouchEvent)"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "onTouchEnter": {
          "!doc": "For touch enter and leave its a list of the touch points that have entered or left the target.\nDoesn't appear to be supported by most browsers on a canvas element yet.",
          "!type": "fn(event: +TouchEvent)"
        },
        "onTouchMove": {
          "!doc": "The handler for the touchmove events.",
          "!type": "fn(event: +TouchEvent)"
        },
        "touchStartCallback": {
          "!doc": "A callback that can be fired on a touchStart event.",
          "!type": "+Function"
        },
        "start": {
          "!doc": "Starts the event listeners running.",
          "!type": "fn()"
        },
        "consumeTouchMove": {
          "!doc": "Consumes all touchmove events on the document (only enable this if you know you need it!).",
          "!type": "fn()"
        },
        "touchLeaveCallback": {
          "!doc": "A callback that can be fired on a touchLeave event.",
          "!type": "+Function"
        },
        "callbackContext": {
          "!doc": "The context under which callbacks are called.",
          "!type": "+Object"
        },
        "onTouchLeave": {
          "!doc": "For touch enter and leave its a list of the touch points that have entered or left the target.\nDoesn't appear to be supported by most browsers on a canvas element yet.",
          "!type": "fn(event: +TouchEvent)"
        },
        "enabled": {
          "!doc": "Touch events will only be processed if enabled.",
          "!type": "+Boolean"
        },
        "touchLockCallbacks": {
          "!doc": "An array of callbacks that will be fired every time a native touch start or touch end event is received from the browser.\nThis is used internally to handle audio and video unlocking on mobile devices.\nTo add a callback to this array please use `Touch.addTouchLockCallback`.",
          "!type": "+Array"
        },
        "touchEnterCallback": {
          "!doc": "A callback that can be fired on a touchEnter event.",
          "!type": "+Function"
        },
        "addTouchLockCallback": {
          "!doc": "Adds a callback that is fired when a browser touchstart or touchend event is received.\n\nThis is used internally to handle audio and video unlocking on mobile devices.\n\nIf the callback returns 'true' then the callback is automatically deleted once invoked.\n\nThe callback is added to the Phaser.Touch.touchLockCallbacks array and should be removed with Phaser.Touch.removeTouchLockCallback.",
          "!type": "fn(callback: +Function, context: +Object, onEnd: +Boolean)"
        },
        "touchMoveCallback": {
          "!doc": "A callback that can be fired on a touchMove event.",
          "!type": "+Function"
        },
        "onTouchCancel": {
          "!doc": "Touch cancel - touches that were disrupted (perhaps by moving into a plugin or browser chrome).\nOccurs for example on iOS when you put down 4 fingers and the app selector UI appears.",
          "!type": "fn(event: +TouchEvent)"
        },
        "stop": {
          "!doc": "Stop the event listeners.",
          "!type": "fn()"
        },
        "touchCancelCallback": {
          "!doc": "A callback that can be fired on a touchCancel event.",
          "!type": "+Function"
        },
        "removeTouchLockCallback": {
          "!doc": "Removes the callback at the defined index from the Phaser.Touch.touchLockCallbacks array",
          "!type": "fn(callback: +Function, context: +Object) -> +Boolean"
        },
        "touchEndCallback": {
          "!doc": "A callback that can be fired on a touchEnd event.",
          "!type": "+Function"
        },
        "onTouchEnd": {
          "!doc": "The handler for the touchend events.",
          "!type": "fn(event: +TouchEvent)"
        },
        "event": {
          "!doc": "The browser touch DOM event. Will be set to null if no touch event has ever been received.",
          "!type": "+TouchEvent"
        },
        "preventDefault": {
          "!doc": "If true the TouchEvent will have prevent.default called on it.",
          "!type": "+Boolean"
        }
      }
    },
    "RequestAnimationFrame": {
      "!doc": "Abstracts away the use of RAF or setTimeOut for the core game update loop.",
      "!type": "fn(game: +Phaser.Game, forceSetTimeOut: +Boolean)",
      "prototype": {
        "isRAF": {
          "!doc": "Is the browser using requestAnimationFrame?",
          "!type": "fn() -> +Boolean"
        },
        "isSetTimeOut": {
          "!doc": "Is the browser using setTimeout?",
          "!type": "fn() -> +Boolean"
        },
        "updateSetTimeout": {
          "!doc": "The update method for the setTimeout.",
          "!type": "fn()"
        },
        "game": {
          "!doc": "The currently running game.",
          "!type": "+Phaser.Game"
        },
        "stop": {
          "!doc": "Stops the requestAnimationFrame from running.",
          "!type": "fn()"
        },
        "isRunning": {
          "!doc": "true if RequestAnimationFrame is running, otherwise false.",
          "!type": "+Boolean"
        },
        "forceSetTimeOut": {
          "!doc": "Tell Phaser to use setTimeOut even if raf is available.",
          "!type": "+Boolean"
        },
        "start": {
          "!doc": "Starts the requestAnimationFrame running or setTimeout if unavailable in browser",
          "!type": "fn()"
        },
        "updateRAF": {
          "!doc": "The update method for the requestAnimationFrame",
          "!type": "fn()"
        }
      }
    },
    "SpriteBatch": {
      "SORT_ASCENDING": "+Number",
      "RETURN_TOTAL": "+Number",
      "!doc": "The SpriteBatch class is a really fast version of the DisplayObjectContainer built purely for speed, so use when you need a lot of sprites or particles.\nIt's worth mentioning that by default sprite batches are used through-out the renderer, so you only really need to use a SpriteBatch if you have over\n1000 sprites that all share the same texture (or texture atlas). It's also useful if running in Canvas mode and you have a lot of un-rotated or un-scaled\nSprites as it skips all of the Canvas setTransform calls, which helps performance, especially on mobile devices.\n\nPlease note that any Sprite that is part of a SpriteBatch will not have its bounds updated, so will fail checks such as outOfBounds.",
      "RETURN_NONE": "+Number",
      "!type": "fn(game: +Phaser.Game, parent: +Phaser.Group, name: +String, addToStage: +Boolean)",
      "SORT_DESCENDING": "+Number",
      "RETURN_CHILD": "+Number",
      "prototype": {
        "xy": {
          "!doc": "Positions the child found at the given index within this group to the given x and y coordinates.",
          "!type": "fn(index: +Number, x: +Number, y: +Number)"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "descendingSortHandler": {
          "!doc": "An internal helper function for the sort process.",
          "!type": "fn(a: +Object, b: +Object)"
        },
        "type": {
          "!doc": "Internal Phaser Type value.",
          "!type": "+Number"
        },
        "moveAll": {
          "!doc": "Moves all children from this Group to the Group given.",
          "!type": "fn(group: +Phaser.Group, silent: +Boolean) -> +Phaser.Group"
        },
        "removeAll": {
          "!doc": "Removes all children from this group, but does not remove the group from its parent.",
          "!type": "fn(destroy: +Boolean, silent: +Boolean)"
        },
        "enableBody": {
          "!doc": "If true all Sprites created by, or added to this group, will have a physics body enabled on them.\n\nThe default body type is controlled with {@link #physicsBodyType}.",
          "!type": "+Boolean"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "customSort": {
          "!doc": "Sort the children in the group according to custom sort function.\n\nThe `sortHandler` is provided the two parameters: the two children involved in the comparison (a and b).\nIt should return -1 if `a > b`, 1 if `a < b` or 0 if `a === b`.",
          "!type": "fn(sortHandler: +Function, context: +Object)"
        },
        "enableBodyDebug": {
          "!doc": "If true when a physics body is created (via {@link #enableBody}) it will create a physics debug object as well.\n\nThis only works for P2 bodies.",
          "!type": "+Boolean"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "bringToTop": {
          "!doc": "Brings the given child to the top of this group so it renders above all other children.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "moveUp": {
          "!doc": "Moves the given child up one place in this group unless it's already at the top.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "postUpdate": {
          "!doc": "The core postUpdate - as called by World.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Destroys this group.\n\nRemoves all children, then removes this group from its parent and nulls references.",
          "!type": "fn(destroyChildren: +Boolean, soft: +Boolean)"
        },
        "cursorIndex": {
          "!doc": "The current index of the Group cursor. Advance it with Group.next.",
          "!type": "+Number"
        },
        "getFirstDead": {
          "!doc": "Get the first child that is dead (`child.alive === false`).\n\nThis is handy for checking if everything has been wiped out and adding to the pool as needed.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no dead ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "physicsSortDirection": {
          "!doc": "If this Group contains Arcade Physics Sprites you can set a custom sort direction via this property.\n\nIt should be set to one of the Phaser.Physics.Arcade sort direction constants: \n\nPhaser.Physics.Arcade.SORT_NONE\nPhaser.Physics.Arcade.LEFT_RIGHT\nPhaser.Physics.Arcade.RIGHT_LEFT\nPhaser.Physics.Arcade.TOP_BOTTOM\nPhaser.Physics.Arcade.BOTTOM_TOP\n\nIf set to `null` the Group will use whatever Phaser.Physics.Arcade.sortDirection is set to. This is the default behavior.",
          "!type": "+Number"
        },
        "addAt": {
          "!doc": "Adds an existing object to this group.\n\nThe child is added to the group at the location specified by the index value, this allows you to control child ordering.",
          "!type": "fn(child: +DisplayObject, index: +Number, silent: +Boolean) -> +PIXI.DisplayObject"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "forEachAlive": {
          "!doc": "Call a function on each alive child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "resetCursor": {
          "!doc": "Sets the group cursor to the first child in the group.\n\nIf the optional index parameter is given it sets the cursor to the object at that index instead.",
          "!type": "fn(index: +Number) -> +Object"
        },
        "addMultiple": {
          "!doc": "Adds an array of existing Display Objects to this Group.\n\nThe Display Objects are automatically added to the top of this Group, and will render on-top of everything already in this Group.\n\nAs well as an array you can also pass another Group as the first argument. In this case all of the children from that\nGroup will be removed from it and added into this Group.",
          "!type": "fn(children: +Array._DisplayObject_, silent: +Boolean) -> +Array._DisplayObject_"
        },
        "setProperty": {
          "!doc": "Sets a property to the given value on the child. The operation parameter controls how the value is set.\n\nThe operations are:\n- 0: set the existing value to the given value; if force is `true` a new property will be created if needed\n- 1: will add the given value to the value already present.\n- 2: will subtract the given value from the value already present.\n- 3: will multiply the value already present by the given value.\n- 4: will divide the value already present by the given value.",
          "!type": "fn(child: +Object, key: +Array, value: +Object, operation: +Number, force: +Boolean) -> +Boolean"
        },
        "preUpdate": {
          "!doc": "The core preUpdate - as called by World.",
          "!type": "fn()"
        },
        "hash": {
          "!doc": "The hash array is an array belonging to this Group into which you can add any of its children via Group.addToHash and Group.removeFromHash.\n\nOnly children of this Group can be added to and removed from the hash.\n\nThis hash is used automatically by Phaser Arcade Physics in order to perform non z-index based destructive sorting.\nHowever if you don't use Arcade Physics, or this isn't a physics enabled Group, then you can use the hash to perform your own\nsorting and filtering of Group children without touching their z-index (and therefore display draw order)",
          "!type": "+Array"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "addToHash": {
          "!doc": "Adds a child of this Group into the hash array.\nThis call will return false if the child is not a child of this Group, or is already in the hash.",
          "!type": "fn(child: +DisplayObject) -> +Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "The alive property is useful for Groups that are children of other Groups and need to be included/excluded in checks like forEachAlive.",
          "!type": "+Boolean"
        },
        "checkProperty": {
          "!doc": "Checks a property for the given value on the child.",
          "!type": "fn(child: +Object, key: +Array, value: +Object, force: +Boolean) -> +Boolean"
        },
        "callbackFromArray": {
          "!doc": "Returns a reference to a function that exists on a child of the group based on the given callback array.",
          "!type": "fn(child: +Object, callback: +Array, length: +Number)"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "multiplyAll": {
          "!doc": "Multiplies the given property by the amount on all children in this group.\n\n`Group.multiplyAll('x', 2)` will x2 the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "getByName": {
          "!doc": "Searches the Group for the first instance of a child with the `name`\nproperty matching the given argument. Should more than one child have\nthe same name only the first instance is returned.",
          "!type": "fn(name: +String) -> +Object"
        },
        "angle": {
          "!doc": "The angle of rotation of the group container, in degrees.\n\nThis adjusts the group itself by modifying its local rotation transform.\n\nThis has no impact on the rotation/angle properties of the children, but it will update their worldTransform\nand on-screen orientation and position.",
          "!type": "+Number"
        },
        "iterate": {
          "!doc": "Iterates over the children of the group performing one of several actions for matched children.\n\nA child is considered a match when it has a property, named `key`, whose value is equal to `value`\naccording to a strict equality comparison.\n\nThe result depends on the `returnType`:\n\n- {@link Phaser.Group.RETURN_TOTAL RETURN_TOTAL}:\n    The callback, if any, is applied to all matching children. The number of matched children is returned.\n- {@link Phaser.Group.RETURN_NONE RETURN_NONE}:\n    The callback, if any, is applied to all matching children. No value is returned.\n- {@link Phaser.Group.RETURN_CHILD RETURN_CHILD}:\n    The callback, if any, is applied to the *first* matching child and the *first* matched child is returned.\n    If there is no matching child then null is returned.\n\nIf `args` is specified it must be an array. The matched child will be assigned to the first\nelement and the entire array will be applied to the callback function.",
          "!type": "fn(key: +String, value: +Object, returnType: +Number, callback: +Function, callbackContext: +Object, args: +Array._any_) -> +Object"
        },
        "onDestroy": {
          "!doc": "This signal is dispatched when the group is destroyed.",
          "!type": "+Phaser.Signal"
        },
        "set": {
          "!doc": "Quickly set a property on a single child of this group to a new value.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(child: +Phaser.Sprite, key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean) -> +Boolean"
        },
        "getFirstExists": {
          "!doc": "Get the first display object that exists, or doesn't exist.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if none matching your exists argument were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(exists: +Boolean, createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "reverse": {
          "!doc": "Reverses all children in this group.\n\nThis operation applies only to immediate children and does not propagate to subgroups.",
          "!type": "fn()"
        },
        "filter": {
          "!doc": "Find children matching a certain predicate.\n\nFor example:\n\n    var healthyList = Group.filter(function(child, index, children) {\n        return child.health > 10 ? true : false;\n    }, true);\n    healthyList.callAll('attack');\n\nNote: Currently this will skip any children which are Groups themselves.",
          "!type": "fn(predicate: +Function, checkExists: +Boolean) -> +Phaser.ArraySet"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "addAll": {
          "!doc": "Adds the amount to the given property on all children in this group.\n\n`Group.addAll('x', 10)` will add 10 to the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "ignoreDestroy": {
          "!doc": "A group with `ignoreDestroy` set to `true` ignores all calls to its `destroy` method.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The x coordinate of the group container.\n\nYou can adjust the group container itself by modifying its coordinates.\nThis will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "If exists is true the group is updated, otherwise it is skipped.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The y coordinate of the group container.\n\nYou can adjust the group container itself by modifying its coordinates.\nThis will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z-depth value of this object within its parent container/Group - the World is a Group as well.\nThis value must be unique for each child in a Group.",
          "!type": "+Number"
        },
        "divideAll": {
          "!doc": "Divides the given property by the amount on all children in this group.\n\n`Group.divideAll('x', 2)` will half the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "setAllChildren": {
          "!doc": "Quickly set the same property across all children of this group, and any child Groups, to a new value.\n\nIf this group contains other Groups then the same property is set across their children as well, iterating down until it reaches the bottom.\nUnlike with `setAll` the property is NOT set on child Groups itself.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
        },
        "physicsBodyType": {
          "!doc": "If {@link #enableBody} is true this is the type of physics body that is created on new Sprites.\n\nThe valid values are {@link Phaser.Physics.ARCADE}, {@link Phaser.Physics.P2JS}, {@link Phaser.Physics.NINJA}, etc.",
          "!type": "+Number"
        },
        "getIndex": {
          "!doc": "Get the index position of the given child in this group, which should match the child's `z` property.",
          "!type": "fn(child: +Object) -> +Number"
        },
        "getBottom": {
          "!doc": "Returns the child at the bottom of this group.\n\nThe bottom child the child being displayed (rendered) below every other child.",
          "!type": "fn() -> +Object"
        },
        "replace": {
          "!doc": "Replaces a child of this group with the given newChild. The newChild cannot be a member of this group.",
          "!type": "fn(oldChild: +Object, newChild: +Object) -> +Object"
        },
        "resetChild": {
          "!doc": "Takes a child and if the `x` and `y` arguments are given it calls `child.reset(x, y)` on it.\n\nIf the `key` and optionally the `frame` arguments are given, it calls `child.loadTexture(key, frame)` on it.\n\nThe two operations are separate. For example if you just wish to load a new texture then pass `null` as the x and y values.",
          "!type": "fn(child: +DisplayObject, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "getRandom": {
          "!doc": "Returns a random child from the group.",
          "!type": "fn(startIndex: +Number, length: +Number) -> +Object"
        },
        "forEachExists": {
          "!doc": "Call a function on each existing child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "getTop": {
          "!doc": "Return the child at the top of this group.\n\nThe top child is the child displayed (rendered) above every other child.",
          "!type": "fn() -> +Object"
        },
        "create": {
          "!doc": "Creates a new Phaser.Sprite object and adds it to the top of this group.\n\nUse {@link #classType} to change the type of object created.",
          "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String, exists: +Boolean) -> +PIXI.DisplayObject"
        },
        "countDead": {
          "!doc": "Get the number of dead children in this group.",
          "!type": "fn() -> +Number"
        },
        "subAll": {
          "!doc": "Subtracts the amount from the given property on all children in this group.\n\n`Group.subAll('x', 10)` will minus 10 from the child.x value for each child.",
          "!type": "fn(property: +String, amount: +Number, checkAlive: +Boolean, checkVisible: +Boolean)"
        },
        "fixedToCamera": {
          "!doc": "A Group that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Group.cameraOffset.\n\nNote that the cameraOffset values are in addition to any parent in the display list.\nSo if this Group was in a Group that has x: 200, then this will be added to the cameraOffset.x",
          "!type": "+Boolean"
        },
        "add": {
          "!doc": "Adds an existing object as the top child in this group.\n\nThe child is automatically added to the top of the group and is displayed on top of every previous child.\n\nIf Group.enableBody is set then a physics body will be created on the object, so long as one does not already exist.\n\nUse {@link #addAt} to control where a child is added. Use {@link #create} to create and add a new child.",
          "!type": "fn(child: +DisplayObject, silent: +Boolean) -> +PIXI.DisplayObject"
        },
        "visible": {
          "!doc": "The visible state of the group. Non-visible Groups and all of their children are not rendered.",
          "!type": "+Boolean"
        },
        "swap": {
          "!doc": "Swaps the position of two children in this group.\n\nBoth children must be in this group, a child cannot be swapped with itself, and unparented children cannot be swapped.",
          "!type": "fn(child1: +Object, child2: +Object)"
        },
        "cameraOffset": {
          "!doc": "If this object is {@link #fixedToCamera} then this stores the x/y position offset relative to the top-left of the camera view.\nIf the parent of this Group is also `fixedToCamera` then the offset here is in addition to that and should typically be disabled.",
          "!type": "+Phaser.Point"
        },
        "sort": {
          "!doc": "Sort the children in the group according to a particular key and ordering.\n\nCall this function to sort the group according to a particular key value and order.\n\nFor example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.\n\nInternally this uses a standard JavaScript Array sort, so everything that applies there also applies here, including\nalphabetical sorting, mixing strings and numbers, and Unicode sorting. See MDN for more details.",
          "!type": "fn(key: +String, order: +Number)"
        },
        "moveDown": {
          "!doc": "Moves the given child down one place in this group unless it's already at the bottom.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "hasProperty": {
          "!doc": "Checks if the child has the given property.\n\nWill scan up to 4 levels deep only.",
          "!type": "fn(child: +Object, key: +Array._string_) -> +Boolean"
        },
        "updateZ": {
          "!doc": "Internal method that re-applies all of the children's Z values.\n\nThis must be called whenever children ordering is altered so that their `z` indices are correctly updated.",
          "!type": "fn()"
        },
        "name": {
          "!doc": "A name for this group. Not used internally but useful for debugging.",
          "!type": "+String"
        },
        "ascendingSortHandler": {
          "!doc": "An internal helper function for the sort process.",
          "!type": "fn(a: +Object, b: +Object)"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "removeBetween": {
          "!doc": "Removes all children from this group whose index falls beteen the given startIndex and endIndex values.",
          "!type": "fn(startIndex: +Number, endIndex: +Number, destroy: +Boolean, silent: +Boolean)"
        },
        "removeFromHash": {
          "!doc": "Removes a child of this Group from the hash array.\nThis call will return false if the child is not in the hash.",
          "!type": "fn(child: +DisplayObject) -> +Boolean"
        },
        "classType": {
          "!doc": "The type of objects that will be created when using {@link #create} or {@link #createMultiple}.\n\nAny object may be used but it should extend either Sprite or Image and accept the same constructor arguments:\nwhen a new object is created it is passed the following parameters to its constructor: `(game, x, y, key, frame)`.",
          "!type": "+Object"
        },
        "next": {
          "!doc": "Advances the group cursor to the next (higher) object in the group.\n\nIf the cursor is at the end of the group (top child) it is moved the start of the group (bottom child).",
          "!type": "fn() -> +Object"
        },
        "cursor": {
          "!doc": "The current display object that the group cursor is pointing to, if any. (Can be set manually.)\n\nThe cursor is a way to iterate through the children in a Group using {@link #next} and {@link #previous}.",
          "!type": "+PIXI.DisplayObject"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "forEachDead": {
          "!doc": "Call a function on each dead child in this group.\n\nSee {@link Phaser.Group#forEach forEach} for details.",
          "!type": "fn(callback: +Function, callbackContext: +Object, args: +Object)"
        },
        "update": {
          "!doc": "The core update - as called by World.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "countLiving": {
          "!doc": "Get the number of living children in this group.",
          "!type": "fn() -> +Number"
        },
        "remove": {
          "!doc": "Removes the given child from this group.\n\nThis will dispatch an `onRemovedFromGroup` event from the child (if it has one), and optionally destroy the child.\n\nIf the group cursor was referring to the removed child it is updated to refer to the next child.",
          "!type": "fn(child: +Object, destroy: +Boolean, silent: +Boolean) -> +Boolean"
        },
        "callAll": {
          "!doc": "Calls a function, specified by name, on all on children.\n\nThe function is called for all children regardless if they are dead or alive (see callAllExists for different options).\nAfter the method parameter and context you can add as many extra parameters as you like, which will all be passed to the child.",
          "!type": "fn(method: +String, context: +String, args: +Object)"
        },
        "total": {
          "!doc": "Total number of existing children in the group.",
          "!type": "+Number"
        },
        "alpha": {
          "!doc": "The alpha value of the group container.",
          "!type": "+Number"
        },
        "createMultiple": {
          "!doc": "Creates multiple Phaser.Sprite objects and adds them to the top of this group.\n\nUseful if you need to quickly generate a pool of identical sprites, such as bullets.\n\nBy default the sprites will be set to not exist and will be positioned at 0, 0 (relative to the group.x/y).\nUse {@link #classType} to change the type of object created.",
          "!type": "fn(quantity: +Number, key: +String, frame: +Number, exists: +Boolean)"
        },
        "setAll": {
          "!doc": "Quickly set the same property across all children of this group to a new value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be set on the group but not its children.\nIf you need that ability please see `Group.setAllChildren`.\n\nThe operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, operation: +Number, force: +Boolean)"
        },
        "callAllExists": {
          "!doc": "Calls a function, specified by name, on all children in the group who exist (or do not exist).\n\nAfter the existsValue parameter you can add as many parameters as you like, which will all be passed to the child callback.",
          "!type": "fn(callback: +String, existsValue: +Boolean, parameter: +Object)"
        },
        "checkAll": {
          "!doc": "Quickly check that the same property across all children of this group is equal to the given value.\n\nThis call doesn't descend down children, so if you have a Group inside of this group, the property will be checked on the group but not its children.",
          "!type": "fn(key: +String, value: +Object, checkAlive: +Boolean, checkVisible: +Boolean, force: +Boolean)"
        },
        "previous": {
          "!doc": "Moves the group cursor to the previous (lower) child in the group.\n\nIf the cursor is at the start of the group (bottom child) it is moved to the end (top child).",
          "!type": "fn() -> +Object"
        },
        "forEach": {
          "!doc": "Call a function on each child in this group.\n\nAdditional arguments for the callback can be specified after the `checkExists` parameter. For example,\n\n    Group.forEach(awardBonusGold, this, true, 100, 500)\n\nwould invoke `awardBonusGold` function with the parameters `(child, 100, 500)`.\n\nNote: This check will skip any children which are Groups themselves.",
          "!type": "fn(callback: +Function, callbackContext: +Object, checkExists: +Boolean, args: +Object)"
        },
        "rotation": {
          "!doc": "The angle of rotation of the group container, in radians.\n\nThis will adjust the group container itself by modifying its rotation.\nThis will have no impact on the rotation value of its children, but it will update their worldTransform and on-screen position.",
          "!type": "+Number"
        },
        "length": {
          "!doc": "Total number of children in this group, regardless of exists/alive status.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends the given child to the bottom of this group so it renders below all other children.",
          "!type": "fn(child: +Object) -> +Object"
        },
        "getAt": {
          "!doc": "Returns the child found at the given index within this group.",
          "!type": "fn(index: +Number) -> +PIXI.DisplayObject"
        },
        "pendingDestroy": {
          "!doc": "A Group is that has `pendingDestroy` set to `true` is flagged to have its destroy method \ncalled on the next logic update.\nYou can set it directly to flag the Group to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy a Group from within one of its own callbacks \nor a callback of one of its children.",
          "!type": "+Boolean"
        },
        "getFirstAlive": {
          "!doc": "Get the first child that is alive (`child.alive === true`).\n\nThis is handy for choosing a squad leader, etc.\n\nYou can use the optional argument `createIfNull` to create a new Game Object if no alive ones were found in this Group.\n\nIt works by calling `Group.create` passing it the parameters given to this method, and returning the new child.\n\nIf a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child\nwill be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.",
          "!type": "fn(createIfNull: +Boolean, x: +Number, y: +Number, key: +String, frame: +String) -> +PIXI.DisplayObject"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        }
      }
    },
    "DeviceButton": {
      "!doc": "DeviceButtons belong to both `Phaser.Pointer` and `Phaser.SinglePad` (Gamepad) instances.\n\nFor Pointers they represent the various buttons that can exist on mice and pens, such as the left button, right button,\nmiddle button and advanced buttons like back and forward.\n\nAccess them via `Pointer.leftbutton`, `Pointer.rightButton` and so on.\n\nOn Gamepads they represent all buttons on the pad: from shoulder buttons to action buttons.\n\nAt the time of writing this there are device limitations you should be aware of:\n\n- On Windows, if you install a mouse driver, and its utility software allows you to customize button actions \n  (e.g., IntelliPoint and SetPoint), the middle (wheel) button, the 4th button, and the 5th button might not be set, \n  even when they are pressed.\n- On Linux (GTK), the 4th button and the 5th button are not supported.\n- On Mac OS X 10.5 there is no platform API for implementing any advanced buttons.",
      "!type": "fn(parent: +Phaser.Pointer, buttonCode: +Number)",
      "prototype": {
        "parent": {
          "!doc": "A reference to the Pointer or Gamepad that owns this button.",
          "!type": "+Phaser.Pointer"
        },
        "repeats": {
          "!doc": "Gamepad only.\nIf a button is held down this holds down the number of times the button has 'repeated'.",
          "!type": "+Number"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "timeUp": {
          "!doc": "The timestamp when the button was last released.",
          "!type": "+Number"
        },
        "ctrlKey": {
          "!doc": "True if the control key was held down when this button was last pressed or released.\nNot supported on Gamepads.",
          "!type": "+Boolean"
        },
        "start": {
          "!doc": "Called automatically by Phaser.Pointer and Phaser.SinglePad.\nHandles the button down state.",
          "!type": "fn(event: +Object, value: +Number)"
        },
        "buttonCode": {
          "!doc": "The buttoncode of this button if a Gamepad, or the DOM button event value if a Pointer.",
          "!type": "+Number"
        },
        "onFloat": {
          "!doc": "Gamepad only.\nThis Signal is dispatched every time this DeviceButton changes floating value (between, but not exactly, 0 and 1).\nWhen dispatched it sends 2 arguments: A reference to this DeviceButton and the value of the button.",
          "!type": "+Phaser.Signal"
        },
        "destroy": {
          "!doc": "Destroys this DeviceButton, this disposes of the onDown, onUp and onFloat signals \nand clears the parent and game references.",
          "!type": "fn()"
        },
        "timeDown": {
          "!doc": "The timestamp when the button was last pressed down.",
          "!type": "+Number"
        },
        "isDown": {
          "!doc": "The \"down\" state of the button.",
          "!type": "+Boolean"
        },
        "onUp": {
          "!doc": "This Signal is dispatched every time this DeviceButton is released from a down state.\nIt is only dispatched once (until the button is pressed again).\nWhen dispatched it sends 2 arguments: A reference to this DeviceButton and the value of the button.",
          "!type": "+Phaser.Signal"
        },
        "duration": {
          "!doc": "How long the button has been held down for in milliseconds.\nIf not currently down it returns -1.",
          "!type": "+Number"
        },
        "shiftKey": {
          "!doc": "True if the shift key was held down when this button was last pressed or released.\nNot supported on Gamepads.",
          "!type": "+Boolean"
        },
        "stop": {
          "!doc": "Called automatically by Phaser.Pointer and Phaser.SinglePad.\nHandles the button up state.",
          "!type": "fn(event: +Object, value: +Number)"
        },
        "isUp": {
          "!doc": "The \"up\" state of the button.",
          "!type": "+Boolean"
        },
        "padFloat": {
          "!doc": "Called automatically by Phaser.SinglePad.",
          "!type": "fn(value: +Number)"
        },
        "reset": {
          "!doc": "Resets this DeviceButton, changing it to an isUp state and resetting the duration and repeats counters.",
          "!type": "fn()"
        },
        "onDown": {
          "!doc": "This Signal is dispatched every time this DeviceButton is pressed down.\nIt is only dispatched once (until the button is released again).\nWhen dispatched it sends 2 arguments: A reference to this DeviceButton and the value of the button.",
          "!type": "+Phaser.Signal"
        },
        "justReleased": {
          "!doc": "Returns the \"just released\" state of this button.\nJust released is considered as being true if the button was released within the duration given (default 250ms).",
          "!type": "fn(duration: +Number) -> +Boolean"
        },
        "altKey": {
          "!doc": "True if the alt key was held down when this button was last pressed or released.\nNot supported on Gamepads.",
          "!type": "+Boolean"
        },
        "event": {
          "!doc": "The DOM event that caused the change in button state.",
          "!type": "+Object"
        },
        "value": {
          "!doc": "Button value. Mainly useful for checking analog buttons (like shoulder triggers) on Gamepads.",
          "!type": "+Number"
        },
        "justPressed": {
          "!doc": "Returns the \"just pressed\" state of this button.\nJust pressed is considered true if the button was pressed down within the duration given (default 250ms).",
          "!type": "fn(duration: +Number) -> +Boolean"
        }
      }
    },
    "LoaderParser": {
      "!doc": "Phaser.LoaderParser parses data objects from Phaser.Loader that need more preparation before they can be inserted into the Cache.",
      "jsonBitmapFont": {
        "!doc": "Parse a Bitmap Font from a JSON file.",
        "!type": "fn(json: +Object, baseTexture: +PIXI.BaseTexture, xSpacing: +Number, ySpacing: +Number) -> +Object"
      },
      "!type": "fn()",
      "prototype": {},
      "bitmapFont": {
        "!doc": "Alias for xmlBitmapFont, for backwards compatibility.",
        "!type": "fn(xml: +Object, baseTexture: +PIXI.BaseTexture, xSpacing: +Number, ySpacing: +Number) -> +Object"
      },
      "xmlBitmapFont": {
        "!doc": "Parse a Bitmap Font from an XML file.",
        "!type": "fn(xml: +Object, baseTexture: +PIXI.BaseTexture, xSpacing: +Number, ySpacing: +Number) -> +Object"
      }
    },
    "Gamepad": {
      "!doc": "The Gamepad class handles gamepad input and dispatches gamepad events.\n\nRemember to call `gamepad.start()`.\n\nHTML5 GAMEPAD API SUPPORT IS AT AN EXPERIMENTAL STAGE!\nAt moment of writing this (end of 2013) only Chrome supports parts of it out of the box. Firefox supports it\nvia prefs flags (about:config, search gamepad). The browsers map the same controllers differently.\nThis class has constants for Windows 7 Chrome mapping of XBOX 360 controller.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "game": {
          "!doc": "Local reference to game.",
          "!type": "+Phaser.Game"
        },
        "update": {
          "!doc": "Main gamepad update loop. Should not be called manually.",
          "!type": "fn()"
        },
        "onUpCallback": {
          "!doc": "This callback is invoked every time any gamepad button is released.",
          "!type": "+Function"
        },
        "pad1": {
          "!doc": "Gamepad #1;",
          "!type": "+Phaser.SinglePad"
        },
        "padsConnected": {
          "!doc": "How many live gamepads are currently connected.",
          "!type": "+Number"
        },
        "pad2": {
          "!doc": "Gamepad #2",
          "!type": "+Phaser.SinglePad"
        },
        "isDown": {
          "!doc": "Returns true if the button is currently pressed down, on ANY gamepad.",
          "!type": "fn(buttonCode: +Number) -> +Boolean"
        },
        "enabled": {
          "!doc": "Gamepad input will only be processed if enabled.",
          "!type": "+Boolean"
        },
        "setDeadZones": {
          "!doc": "Sets the deadZone variable for all four gamepads",
          "!type": "fn()"
        },
        "justPressed": {
          "!doc": "Returns the \"just pressed\" state of a button from ANY gamepad connected. Just pressed is considered true if the button was pressed down within the duration given (default 250ms).",
          "!type": "fn(buttonCode: +Number, duration: +Number) -> +Boolean"
        },
        "addCallbacks": {
          "!doc": "Add callbacks to the main Gamepad handler to handle connect/disconnect/button down/button up/axis change/float value buttons.",
          "!type": "fn(context: +Object, callbacks: +Object)"
        },
        "start": {
          "!doc": "Starts the Gamepad event handling.\nThis MUST be called manually before Phaser will start polling the Gamepad API.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Destroys this object and the associated event listeners.",
          "!type": "fn()"
        },
        "onFloatCallback": {
          "!doc": "This callback is invoked every time any gamepad button is changed to a value where value > 0 and value < 1.",
          "!type": "+Function"
        },
        "active": {
          "!doc": "If the gamepad input is active or not.",
          "!type": "+Boolean"
        },
        "callbackContext": {
          "!doc": "The context under which the callbacks are run.",
          "!type": "+Object"
        },
        "stop": {
          "!doc": "Stops the Gamepad event handling.",
          "!type": "fn()"
        },
        "onDownCallback": {
          "!doc": "This callback is invoked every time any gamepad button is pressed down.",
          "!type": "+Function"
        },
        "pad3": {
          "!doc": "Gamepad #3",
          "!type": "+Phaser.SinglePad"
        },
        "onDisconnectCallback": {
          "!doc": "This callback is invoked every time any gamepad is disconnected",
          "!type": "+Function"
        },
        "pad4": {
          "!doc": "Gamepad #4",
          "!type": "+Phaser.SinglePad"
        },
        "onConnectCallback": {
          "!doc": "This callback is invoked every time any gamepad is connected",
          "!type": "+Function"
        },
        "reset": {
          "!doc": "Reset all buttons/axes of all gamepads",
          "!type": "fn()"
        },
        "onAxisCallback": {
          "!doc": "This callback is invoked every time any gamepad axis is changed.",
          "!type": "+Function"
        },
        "supported": {
          "!doc": "Whether or not gamepads are supported in current browser.",
          "!type": "+Boolean"
        }
      }
    },
    "EMITTER": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "BITMAPTEXT": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "GameObjectFactory": {
      "!doc": "The GameObjectFactory is a quick way to create many common game objects\nusing {@linkcode Phaser.Game#add `game.add`}.\n\nCreated objects are _automatically added_ to the appropriate Manager, World, or manually specified parent Group.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "renderTexture": {
          "!doc": "A dynamic initially blank canvas to which images can be drawn.",
          "!type": "fn(width: +Number, height: +Number, key: +String, addToCache: +Boolean) -> +Phaser.RenderTexture"
        },
        "sound": {
          "!doc": "Creates a new Sound object.",
          "!type": "fn(key: +String, volume: +Number, loop: +Boolean, connect: +Boolean) -> +Phaser.Sound"
        },
        "rope": {
          "!doc": "Creates a new Rope object.\n\nExample usage: https://github.com/codevinsky/phaser-rope-demo/blob/master/dist/demo.js",
          "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String, points: +Array, group: +Phaser.Group) -> +Phaser.Rope"
        },
        "graphics": {
          "!doc": "Creates a new Graphics object.",
          "!type": "fn(x: +Number, y: +Number, group: +Phaser.Group) -> +Phaser.Graphics"
        },
        "video": {
          "!doc": "Create a Video object.\n\nThis will return a Phaser.Video object which you can pass to a Sprite to be used as a texture.",
          "!type": "fn(key: +String, url: +String) -> +Phaser.Video"
        },
        "tilemap": {
          "!doc": "Creates a new Phaser.Tilemap object.\n\nThe map can either be populated with data from a Tiled JSON file or from a CSV file.\nTo do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.\nWhen using CSV data you must provide the key and the tileWidth and tileHeight parameters.\nIf creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.\nNote that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.",
          "!type": "fn(key: +String, tileWidth: +Number, tileHeight: +Number, width: +Number, height: +Number) -> +Phaser.Tilemap"
        },
        "button": {
          "!doc": "Creates a new Button object.",
          "!type": "fn(x: +Number, y: +Number, key: +String, callback: +Function, callbackContext: +Object, overFrame: +String, outFrame: +String, downFrame: +String, upFrame: +String, group: +Phaser.Group) -> +Phaser.Button"
        },
        "world": {
          "!doc": "A reference to the game world.",
          "!type": "+Phaser.World"
        },
        "sprite": {
          "!doc": "Create a new Sprite with specific position and sprite sheet key.\n\nAt its most basic a Sprite consists of a set of coordinates and a texture that is used when rendered.\nThey also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),\nevents (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.",
          "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String, group: +Phaser.Group) -> +Phaser.Sprite"
        },
        "spriteBatch": {
          "!doc": "A SpriteBatch is a really fast version of a Phaser Group built solely for speed.\nUse when you need a lot of sprites or particles all sharing the same texture.\nThe speed gains are specifically for WebGL. In Canvas mode you won't see any real difference.",
          "!type": "fn(parent: +Phaser.Group, name: +String, addToStage: +Boolean) -> +Phaser.SpriteBatch"
        },
        "audio": {
          "!doc": "Creates a new Sound object.",
          "!type": "fn(key: +String, volume: +Number, loop: +Boolean, connect: +Boolean) -> +Phaser.Sound"
        },
        "text": {
          "!doc": "Creates a new Text object.",
          "!type": "fn(x: +Number, y: +Number, text: +String, style: +Object, group: +Phaser.Group) -> +Phaser.Text"
        },
        "group": {
          "!doc": "A Group is a container for display objects that allows for fast pooling, recycling and collision checks.",
          "!type": "fn(parent: +Object, name: +String, addToStage: +Boolean, enableBody: +Boolean, physicsBodyType: +Number) -> +Phaser.Group"
        },
        "audioSprite": {
          "!doc": "Creates a new AudioSprite object.",
          "!type": "fn(key: +String) -> +Phaser.AudioSprite"
        },
        "image": {
          "!doc": "Create a new `Image` object.\n\nAn Image is a light-weight object you can use to display anything that doesn't need physics or animation.\n\nIt can still rotate, scale, crop and receive input events. \nThis makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.",
          "!type": "fn(x: +Number, y: +Number, key: +String, frame: +String, group: +Phaser.Group) -> +Phaser.Image"
        },
        "retroFont": {
          "!doc": "Create a new RetroFont object.\n\nA RetroFont can be used as a texture for an Image or Sprite and optionally add it to the Cache.\nA RetroFont uses a bitmap which contains fixed with characters for the font set. You use character spacing to define the set.\nIf you need variable width character support then use a BitmapText object instead. The main difference between a RetroFont and a BitmapText\nis that a RetroFont creates a single texture that you can apply to a game object, where-as a BitmapText creates one Sprite object per letter of text.\nThe texture can be asssigned or one or multiple images/sprites, but note that the text the RetroFont uses will be shared across them all,\ni.e. if you need each Image to have different text in it, then you need to create multiple RetroFont objects.",
          "!type": "fn(font: +String, characterWidth: +Number, characterHeight: +Number, chars: +String, charsPerRow: +Number, xSpacing: +Number, ySpacing: +Number, xOffset: +Number, yOffset: +Number) -> +Phaser.RetroFont"
        },
        "bitmapText": {
          "!doc": "Create a new BitmapText object.\n\nBitmapText objects work by taking a texture file and an XML file that describes the font structure.\nIt then generates a new Sprite object for each letter of the text, proportionally spaced out and aligned to \nmatch the font structure.\n\nBitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability \nto use Web Fonts. However you trade this flexibility for pure rendering speed. You can also create visually compelling BitmapTexts by \nprocessing the font texture in an image editor first, applying fills and any other effects required.\n\nTo create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\n\nTo create a BitmapText data files you can use:\n\nBMFont (Windows, free): http://www.angelcode.com/products/bmfont/\nGlyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner\nLittera (Web-based, free): http://kvazars.com/littera/",
          "!type": "fn(x: +Number, y: +Number, font: +String, text: +String, size: +Number, group: +Phaser.Group) -> +Phaser.BitmapText"
        },
        "physicsGroup": {
          "!doc": "A Group is a container for display objects that allows for fast pooling, recycling and collision checks.\n\nA Physics Group is the same as an ordinary Group except that is has enableBody turned on by default, so any Sprites it creates\nare automatically given a physics body.",
          "!type": "fn(physicsBodyType: +Number, parent: +Object, name: +String, addToStage: +Boolean) -> +Phaser.Group"
        },
        "filter": {
          "!doc": "A WebGL shader/filter that can be applied to Sprites.",
          "!type": "fn(filter: +String, _any: +Object) -> +Phaser.Filter"
        },
        "existing": {
          "!doc": "Adds an existing display object to the game world.",
          "!type": "fn(object: +Object) -> +Object"
        },
        "tween": {
          "!doc": "Create a tween on a specific object.\n\nThe object can be any JavaScript object or Phaser object such as Sprite.",
          "!type": "fn(object: +Object) -> +Phaser.Tween"
        },
        "plugin": {
          "!doc": "Add a new Plugin into the PluginManager.\n\nThe Plugin must have 2 properties: `game` and `parent`. Plugin.game is set to the game reference the PluginManager uses, and parent is set to the PluginManager.",
          "!type": "fn(plugin: +Object, parameter: +any) -> +Phaser.Plugin"
        },
        "bitmapData": {
          "!doc": "Create a BitmapData object.\n\nA BitmapData object can be manipulated and drawn to like a traditional Canvas object and used to texture Sprites.",
          "!type": "fn(width: +Number, height: +Number, key: +String, addToCache: +Boolean) -> +Phaser.BitmapData"
        },
        "tileSprite": {
          "!doc": "Creates a new TileSprite object.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, key: +String, frame: +String, group: +Phaser.Group) -> +Phaser.TileSprite"
        },
        "emitter": {
          "!doc": "Create a new Emitter.\n\nA particle emitter can be used for one-time explosions or for\ncontinuous effects like rain and fire. All it really does is launch Particle objects out\nat set intervals, and fixes their positions and velocities accordingly.",
          "!type": "fn(x: +Number, y: +Number, maxParticles: +Number) -> +Phaser.Particles.Arcade.Emitter"
        },
        "creature": {
          "!doc": "Create a new Creature Animation object.\n\nCreature is a custom Game Object used in conjunction with the Creature Runtime libraries by Kestrel Moon Studios.\n\nIt allows you to display animated Game Objects that were created with the [Creature Automated Animation Tool](http://www.kestrelmoon.com/creature/).\n\nNote 1: You can only use Phaser.Creature objects in WebGL enabled games. They do not work in Canvas mode games.\n\nNote 2: You must use a build of Phaser that includes the CreatureMeshBone.js runtime and gl-matrix.js, or have them\nloaded before your Phaser game boots.\n\nSee the Phaser custom build process for more details.",
          "!type": "fn(x: +Number, y: +Number, key: +String, group: +Phaser.Group) -> +Phaser.Creature"
        }
      }
    },
    "ROPE": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Create": {
      "PALETTE_JMP": "+Number",
      "PALETTE_CGA": "+Number",
      "PALETTE_ARNE": "+Number",
      "!doc": "The Phaser.Create class is a collection of smaller helper methods that allow you to generate game content\nquickly and easily, without the need for any external files. You can create textures for sprites and in\ncoming releases we'll add dynamic sound effect generation support as well (like sfxr).\n\nAccess this via `Game.create` (`this.game.create` from within a State object)",
      "PALETTE_C64": "+Number",
      "PALETTE_JAPANESE_MACHINE": "+Number",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "canvas": {
          "!doc": "The canvas the BitmapData uses.",
          "!type": "+HTMLCanvasElement"
        },
        "texture": {
          "!doc": "Generates a new PIXI.Texture from the given data, which can be applied to a Sprite.\n\nThis allows you to create game graphics quickly and easily, with no external files but that use actual proper images\nrather than Phaser.Graphics objects, which are expensive to render and limited in scope.\n\nEach element of the array is a string holding the pixel color values, as mapped to one of the Phaser.Create PALETTE consts.\n\nFor example:\n\n`var data = [\n  ' 333 ',\n  ' 777 ',\n  'E333E',\n  ' 333 ',\n  ' 3 3 '\n];`\n\n`game.create.texture('bob', data);`\n\nThe above will create a new texture called `bob`, which will look like a little man wearing a hat. You can then use it\nfor sprites the same way you use any other texture: `game.add.sprite(0, 0, 'bob');`",
          "!type": "fn(key: +String, data: +Array, pixelWidth: +Number, pixelHeight: +Number, palette: +Number) -> +PIXI.Texture"
        },
        "grid": {
          "!doc": "Creates a grid texture based on the given dimensions.",
          "!type": "fn(key: +String, width: +Number, height: +Number, cellWidth: +Number, cellHeight: +Number, color: +String) -> +PIXI.Texture"
        },
        "bmd": {
          "!doc": "The internal BitmapData Create uses to generate textures from.",
          "!type": "+Phaser.BitmapData"
        },
        "context": {
          "!doc": "The 2d context of the canvas.",
          "!type": "+CanvasRenderingContext2D"
        },
        "palettes": {
          "!doc": "A range of 16 color palettes for use with sprite generation.",
          "!type": "+Array"
        }
      }
    },
    "LINE": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Component": {
      "BringToTop": {
        "!doc": "The BringToTop Component features quick access to Group sorting related methods.",
        "!type": "fn()",
        "prototype": {
          "sendToBack": {
            "!doc": "Sends this Game Object to the bottom of its parents display list.\nVisually this means it will render below all other children in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
            "!type": "fn() -> +PIXI.DisplayObject"
          },
          "moveDown": {
            "!doc": "Moves this Game Object down one place in its parents display list.\nThis call has no effect if the Game Object is already at the bottom of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
            "!type": "fn() -> +PIXI.DisplayObject"
          },
          "bringToTop": {
            "!doc": "Brings this Game Object to the top of its parents display list.\nVisually this means it will render over the top of any old child in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
            "!type": "fn() -> +PIXI.DisplayObject"
          },
          "moveUp": {
            "!doc": "Moves this Game Object up one place in its parents display list.\nThis call has no effect if the Game Object is already at the top of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
            "!type": "fn() -> +PIXI.DisplayObject"
          }
        }
      },
      "LoadTexture": {
        "!doc": "The LoadTexture component manages the loading of a texture into the Game Object and the changing of frames.",
        "!type": "fn()",
        "prototype": {
          "resizeFrame": {
            "!doc": "Resizes the Frame dimensions that the Game Object uses for rendering.\n\nYou shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData\nit can be useful to adjust the dimensions directly in this way.",
            "!type": "fn(parent: +Object, width: +Number, height: +Number)"
          },
          "frameName": {
            "!doc": "Gets or sets the current frame name of the texture being used to render this Game Object.\n\nTo change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use, \nfor example: `player.frameName = \"idle\"`.\n\nIf the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.\n\nIf you are using a sprite sheet then you should use the `frame` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
            "!type": "+String"
          },
          "setFrame": {
            "!doc": "Sets the texture frame the Game Object uses for rendering.\n\nThis is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.",
            "!type": "fn(frame: +Phaser.Frame)"
          },
          "loadTexture": {
            "!doc": "Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.\n\nIf your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.\n\nYou should only use `loadTexture` if you want to replace the base texture entirely.\n\nCalling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.\n\nYou can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite. \nDoing this then sets the key to be the `frame` argument (the frame is set to zero). \n\nThis allows you to create sprites using `load.image` during development, and then change them \nto use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS' \nand swapping it to be the key of the atlas data.\n\nNote: You cannot use a RenderTexture as a texture for a TileSprite.",
            "!type": "fn(key: +String, frame: +String, stopAnimation: +Boolean)"
          },
          "resetFrame": {
            "!doc": "Resets the texture frame dimensions that the Game Object uses for rendering.",
            "!type": "fn()"
          },
          "frame": {
            "!doc": "Gets or sets the current frame index of the texture being used to render this Game Object.\n\nTo change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,\nfor example: `player.frame = 4`.\n\nIf the frame index given doesn't exist it will revert to the first frame found in the texture.\n\nIf you are using a texture atlas then you should use the `frameName` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
            "!type": "+Number"
          }
        }
      },
      "Health": {
        "!doc": "The Health component provides the ability for Game Objects to have a `health` property \nthat can be damaged and reset through game code.\nRequires the LifeSpan component.",
        "!type": "fn()",
        "prototype": {
          "damage": {
            "!doc": "Damages the Game Object. This removes the given amount of health from the `health` property.\n\nIf health is taken below or is equal to zero then the `kill` method is called.",
            "!type": "fn(amount: +Number) -> +Phaser.Sprite"
          },
          "heal": {
            "!doc": "Heal the Game Object. This adds the given amount of health to the `health` property.",
            "!type": "fn(amount: +Number) -> +Phaser.Sprite"
          },
          "health": {
            "!doc": "The Game Objects health value. This is a handy property for setting and manipulating health on a Game Object.\n\nIt can be used in combination with the `damage` method or modified directly.",
            "!type": "+Number"
          },
          "maxHealth": {
            "!doc": "The Game Objects maximum health value. This works in combination with the `heal` method to ensure\nthe health value never exceeds the maximum.",
            "!type": "+Number"
          },
          "setHealth": {
            "!doc": "Sets the health property of the Game Object to the given amount.\nWill never exceed the `maxHealth` value.",
            "!type": "fn(amount: +Number) -> +Phaser.Sprite"
          }
        }
      },
      "Bounds": {
        "!doc": "The Bounds component contains properties related to the bounds of the Game Object.",
        "!type": "fn()",
        "prototype": {
          "offsetX": {
            "!doc": "The amount the Game Object is visually offset from its x coordinate.\nThis is the same as `width * anchor.x`.\nIt will only be > 0 if anchor.x is not equal to zero.",
            "!type": "+Number"
          },
          "offsetY": {
            "!doc": "The amount the Game Object is visually offset from its y coordinate.\nThis is the same as `height * anchor.y`.\nIt will only be > 0 if anchor.y is not equal to zero.",
            "!type": "+Number"
          },
          "top": {
            "!doc": "The y coordinate of the Game Object.\nThis is the same as `y - offsetY`.",
            "!type": "+Number"
          },
          "left": {
            "!doc": "The left coordinate of the Game Object.\nThis is the same as `x - offsetX`.",
            "!type": "+Number"
          },
          "bottom": {
            "!doc": "The sum of the y and height properties.\nThis is the same as `y + height - offsetY`.",
            "!type": "+Number"
          },
          "right": {
            "!doc": "The right coordinate of the Game Object.\nThis is the same as `x + width - offsetX`.",
            "!type": "+Number"
          }
        }
      },
      "Smoothed": {
        "!doc": "The Smoothed component allows a Game Object to control anti-aliasing of an image based texture.",
        "!type": "fn()",
        "prototype": {"smoothed": {
          "!doc": "Enable or disable texture smoothing for this Game Object.\n\nIt only takes effect if the Game Object is using an image based texture.\n\nSmoothing is enabled by default.",
          "!type": "+Boolean"
        }}
      },
      "LifeSpan": {
        "!doc": "LifeSpan Component Features.",
        "!type": "fn()",
        "prototype": {
          "alive": {
            "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
            "!type": "+Boolean"
          },
          "lifespan": {
            "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
            "!type": "+Number"
          },
          "revive": {
            "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
            "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
          },
          "kill": {
            "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
            "!type": "fn() -> +PIXI.DisplayObject"
          }
        },
        "preUpdate": {
          "!doc": "The LifeSpan component preUpdate handler.\nCalled automatically by the Game Object.",
          "!type": "fn()"
        }
      },
      "InCamera": {
        "!doc": "The InCamera component checks if the Game Object intersects with the Game Camera.",
        "!type": "fn()",
        "prototype": {"inCamera": {
          "!doc": "Checks if this Game Objects bounds intersects with the Game Cameras bounds.\n\nIt will be `true` if they intersect, or `false` if the Game Object is fully outside of the Cameras bounds.\n\nAn object outside the bounds can be considered for camera culling if it has the AutoCull component.",
          "!type": "+Boolean"
        }}
      },
      "Overlap": {
        "!doc": "The Overlap component allows a Game Object to check if it overlaps with the bounds of another Game Object.",
        "!type": "fn()",
        "prototype": {"overlap": {
          "!doc": "Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object, \nwhich can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.\n\nThis check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.\n\nTherefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.\nIt should be fine for low-volume testing where physics isn't required.",
          "!type": "fn(displayObject: +Phaser.Sprite) -> +Boolean"
        }}
      },
      "Crop": {
        "!doc": "The Crop component provides the ability to crop a texture based Game Object to a defined rectangle, \nwhich can be updated in real-time.",
        "!type": "fn()",
        "prototype": {
          "cropRect": {
            "!doc": "The Rectangle used to crop the texture this Game Object uses.\nSet this property via `crop`. \nIf you modify this property directly you must call `updateCrop` in order to have the change take effect.",
            "!type": "+Phaser.Rectangle"
          },
          "updateCrop": {
            "!doc": "If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,\nor the rectangle it references, then you need to update the crop frame by calling this method.",
            "!type": "fn()"
          },
          "crop": {
            "!doc": "Crop allows you to crop the texture being used to display this Game Object.\nSetting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.\n\nCropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,\nor by modifying `cropRect` property directly and then calling `updateCrop`.\n\nThe rectangle object given to this method can be either a `Phaser.Rectangle` or any other object \nso long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.\n\nA reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`, \nin which case the values are duplicated to a local object.",
            "!type": "fn(rect: +Phaser.Rectangle, copy: +Boolean)"
          }
        }
      },
      "InputEnabled": {
        "!doc": "The InputEnabled component allows a Game Object to have its own InputHandler and process input related events.",
        "!type": "fn()",
        "prototype": {
          "input": {
            "!doc": "The Input Handler for this Game Object.\n\nBy default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.\n\nAfter you have done this, this property will be a reference to the Phaser InputHandler.",
            "!type": "+Phaser.InputHandler"
          },
          "inputEnabled": {
            "!doc": "By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created\nfor this Game Object and it will then start to process click / touch events and more.\n\nYou can then access the Input Handler via `this.input`.\n\nNote that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.\n\nIf you set this property to false it will stop the Input Handler from processing any more input events.",
            "!type": "+Boolean"
          }
        }
      },
      "ScaleMinMax": {
        "!doc": "The ScaleMinMax component allows a Game Object to limit how far it can be scaled by its parent.",
        "!type": "fn()",
        "prototype": {
          "transformCallbackContext": {
            "!doc": "The context under which `transformCallback` is called.",
            "!type": "+Object"
          },
          "transformCallback": {
            "!doc": "The callback that will apply any scale limiting to the worldTransform.",
            "!type": "+Function"
          },
          "setScaleMinMax": {
            "!doc": "Sets the scaleMin and scaleMax values. These values are used to limit how far this Game Object will scale based on its parent.\n\nFor example if this Game Object has a `minScale` value of 1 and its parent has a `scale` value of 0.5, the 0.5 will be ignored \nand the scale value of 1 will be used, as the parents scale is lower than the minimum scale this Game Object should adhere to.\n\nBy setting these values you can carefully control how Game Objects deal with responsive scaling.\n\nIf only one parameter is given then that value will be used for both scaleMin and scaleMax:\n`setScaleMinMax(1)` = scaleMin.x, scaleMin.y, scaleMax.x and scaleMax.y all = 1\n\nIf only two parameters are given the first is set as scaleMin.x and y and the second as scaleMax.x and y:\n`setScaleMinMax(0.5, 2)` = scaleMin.x and y = 0.5 and scaleMax.x and y = 2\n\nIf you wish to set `scaleMin` with different values for x and y then either modify Game Object.scaleMin directly, \nor pass `null` for the `maxX` and `maxY` parameters.\n\nCall `setScaleMinMax(null)` to clear all previously set values.",
            "!type": "fn(minX: +Number, minY: +Number, maxX: +Number, maxY: +Number)"
          },
          "scaleMax": {
            "!doc": "The maximum scale this Game Object will scale up to. \n\nIt allows you to prevent a parent from scaling this Game Object higher than the given value.\n\nSet it to `null` to remove the limit.",
            "!type": "+Phaser.Point"
          },
          "scaleMin": {
            "!doc": "The minimum scale this Game Object will scale down to.\n\nIt allows you to prevent a parent from scaling this Game Object lower than the given value.\n\nSet it to `null` to remove the limit.",
            "!type": "+Phaser.Point"
          }
        }
      },
      "Angle": {
        "!doc": "The Angle Component provides access to an `angle` property; the rotation of a Game Object in degrees.",
        "!type": "fn()",
        "prototype": {"angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        }}
      },
      "AutoCull": {
        "!doc": "The AutoCull Component is responsible for providing methods that check if a Game Object is within the bounds of the World Camera.\nIt is used by the InWorld component.",
        "!type": "fn()",
        "prototype": {
          "autoCull": {
            "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
            "!type": "+Boolean"
          },
          "inCamera": {
            "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
            "!type": "+Boolean"
          }
        }
      },
      "Delta": {
        "!doc": "The Delta component provides access to delta values between the Game Objects current and previous position.",
        "!type": "fn()",
        "prototype": {
          "deltaZ": {
            "!doc": "The delta value.",
            "!type": "+Number"
          },
          "deltaX": {
            "!doc": "Returns the delta x value. The difference between world.x now and in the previous frame.\n\nThe value will be positive if the Game Object has moved to the right or negative if to the left.",
            "!type": "+Number"
          },
          "deltaY": {
            "!doc": "Returns the delta y value. The difference between world.y now and in the previous frame.\n\nThe value will be positive if the Game Object has moved down or negative if up.",
            "!type": "+Number"
          }
        }
      },
      "PhysicsBody": {
        "postUpdate": {
          "!doc": "The PhysicsBody component postUpdate handler.\nCalled automatically by the Game Object.",
          "!type": "fn()"
        },
        "!doc": "The PhysicsBody component manages the Game Objects physics body and physics enabling.\nIt also overrides the x and y properties, ensuring that any manual adjustment of them is reflected in the physics body itself.",
        "!type": "fn()",
        "prototype": {
          "x": {
            "!doc": "The position of the Game Object on the x axis relative to the local coordinates of the parent.",
            "!type": "+Number"
          },
          "y": {
            "!doc": "The position of the Game Object on the y axis relative to the local coordinates of the parent.",
            "!type": "+Number"
          },
          "body": {
            "!doc": "`body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated \nproperties and methods via it.\n\nBy default Game Objects won't add themselves to any physics system and their `body` property will be `null`.\n\nTo enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object\nand `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.\n\nYou can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.\n\nImportant: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5, \nso the physics body is centered on the Game Object.\n\nIf you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.",
            "!type": "+Phaser.Physics.Arcade.Body"
          }
        },
        "preUpdate": {
          "!doc": "The PhysicsBody component preUpdate handler.\nCalled automatically by the Game Object.",
          "!type": "fn()"
        }
      },
      "Destroy": {
        "!doc": "The Destroy component is responsible for destroying a Game Object.",
        "!type": "fn()",
        "prototype": {
          "destroy": {
            "!doc": "Destroys the Game Object. This removes it from its parent group, destroys the input, event and animation handlers if present\nand nulls its reference to `game`, freeing it up for garbage collection.\n\nIf this Game Object has the Events component it will also dispatch the `onDestroy` event.\n\nYou can optionally also destroy the BaseTexture this Game Object is using. Be careful if you've\nmore than one Game Object sharing the same BaseTexture.",
            "!type": "fn(destroyChildren: +Boolean, destroyTexture: +Boolean)"
          },
          "destroyPhase": {
            "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
            "!type": "+Boolean"
          }
        }
      },
      "InWorld": {
        "!doc": "The InWorld component checks if a Game Object is within the Game World Bounds.\nAn object is considered as being \"in bounds\" so long as its own bounds intersects at any point with the World bounds.\nIf the AutoCull component is enabled on the Game Object then it will check the Game Object against the Camera bounds as well.",
        "!type": "fn()",
        "prototype": {
          "outOfBoundsKill": {
            "!doc": "If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.",
            "!type": "+Boolean"
          },
          "outOfCameraBoundsKill": {
            "!doc": "If this and the `autoCull` property are both set to `true`, then the `kill` method\nis called as soon as the Game Object leaves the camera bounds.",
            "!type": "+Boolean"
          },
          "checkWorldBounds": {
            "!doc": "If this is set to `true` the Game Object checks if it is within the World bounds each frame. \n\nWhen it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.\n\nIf it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.\n\nIt also optionally kills the Game Object if `outOfBoundsKill` is `true`.\n\nWhen `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
            "!type": "+Boolean"
          },
          "inWorld": {
            "!doc": "Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.",
            "!type": "+Boolean"
          }
        },
        "preUpdate": {
          "!doc": "The InWorld component preUpdate handler.\nCalled automatically by the Game Object.",
          "!type": "fn()"
        }
      },
      "Animation": {
        "!doc": "The Animation Component provides a `play` method, which is a proxy to the `AnimationManager.play` method.",
        "!type": "fn()",
        "prototype": {"play": {
          "!doc": "Plays an Animation.\n\nThe animation should have previously been created via `animations.add`.\n\nIf the animation is already playing calling this again won't do anything.\nIf you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.",
          "!type": "fn(name: +String, frameRate: +Number, loop: +Boolean, killOnComplete: +Boolean) -> +Phaser.Animation"
        }}
      },
      "FixedToCamera": {
        "postUpdate": {
          "!doc": "The FixedToCamera component postUpdate handler.\nCalled automatically by the Game Object.",
          "!type": "fn()"
        },
        "!doc": "The FixedToCamera component enables a Game Object to be rendered relative to the game camera coordinates, regardless \nof where in the world the camera is. This is used for things like sticking game UI to the camera that scrolls as it moves around the world.",
        "!type": "fn()",
        "prototype": {
          "cameraOffset": {
            "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
            "!type": "+Phaser.Point"
          },
          "fixedToCamera": {
            "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
            "!type": "+Boolean"
          }
        }
      },
      "Reset": {
        "!doc": "The Reset component allows a Game Object to be reset and repositioned to a new location.",
        "!type": "fn()",
        "prototype": {"reset": {
          "!doc": "Resets the Game Object.\n\nThis moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`, \n`visible` and `renderable` to true.\n\nIf this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.\n\nIf this Game Object has a Physics Body it will reset the Body.",
          "!type": "fn(x: +Number, y: +Number, health: +Number) -> +PIXI.DisplayObject"
        }}
      },
      "Core": {
        "init": {
          "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
          "!type": "fn()"
        },
        "install": {
          "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
          "!type": "fn()"
        },
        "!doc": "Core Component Features.",
        "!type": "fn()",
        "prototype": {
          "previousRotation": {
            "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
            "!type": "+Number"
          },
          "game": {
            "!doc": "A reference to the currently running Game.",
            "!type": "+Phaser.Game"
          },
          "components": {
            "!doc": "The components this Game Object has installed.",
            "!type": "+Object"
          },
          "debug": {
            "!doc": "A debug flag designed for use with `Game.enableStep`.",
            "!type": "+Boolean"
          },
          "postUpdate": {
            "!doc": "Internal method called by the World postUpdate cycle.",
            "!type": "fn()"
          },
          "update": {
            "!doc": "Override this method in your own custom objects to handle any update requirements.\nIt is called immediately after `preUpdate` and before `postUpdate`.\nRemember if this Game Object has any children you should call update on those too.",
            "!type": "fn()"
          },
          "previousPosition": {
            "!doc": "The position the Game Object was located in the previous frame.",
            "!type": "+Phaser.Point"
          },
          "pendingDestroy": {
            "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
            "!type": "+Boolean"
          },
          "world": {
            "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
            "!type": "+Phaser.Point"
          },
          "animations": {
            "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
            "!type": "+Phaser.AnimationManager"
          },
          "name": {
            "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
            "!type": "+String"
          },
          "exists": {
            "!doc": "Controls if this Game Object is processed by the core game loop.\nIf this Game Object has a physics body it also controls if its physics body is updated or not.\nWhen `exists` is set to `false` it will remove its physics body from the physics world if it has one.\nIt also toggles the `visible` property to false as well.\n\nSetting `exists` to true will add its physics body back in to the physics world, if it has one.\nIt will also set the `visible` property to `true`.",
            "!type": "+Boolean"
          },
          "z": {
            "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
            "!type": "+Number"
          },
          "renderOrderID": {
            "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
            "!type": "+Number"
          },
          "fresh": {
            "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
            "!type": "+Boolean"
          },
          "events": {
            "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
            "!type": "+Phaser.Events"
          },
          "key": {
            "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
            "!type": "+String"
          }
        }
      }
    },
    "MATRIX": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "TILEMAPLAYER": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Sprite": {
      "init": {
        "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
        "!type": "fn()"
      },
      "install": {
        "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
        "!type": "fn()"
      },
      "!doc": "Sprites are the lifeblood of your game, used for nearly everything visual.\n\nAt its most basic a Sprite consists of a set of coordinates and a texture that is rendered to the canvas.\nThey also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),\nevents (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.",
      "!type": "fn(game: +Phaser.Game, x: +Number, y: +Number, key: +String, frame: +String)",
      "prototype": {
        "play": {
          "!doc": "Plays an Animation.\n\nThe animation should have previously been created via `animations.add`.\n\nIf the animation is already playing calling this again won't do anything.\nIf you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.",
          "!type": "fn(name: +String, frameRate: +Number, loop: +Boolean, killOnComplete: +Boolean) -> +Phaser.Animation"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "lifespan": {
          "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
          "!type": "+Number"
        },
        "outOfBoundsKill": {
          "!doc": "If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.",
          "!type": "+Boolean"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "resizeFrame": {
          "!doc": "Resizes the Frame dimensions that the Game Object uses for rendering.\n\nYou shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData\nit can be useful to adjust the dimensions directly in this way.",
          "!type": "fn(parent: +Object, width: +Number, height: +Number)"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "maxHealth": {
          "!doc": "The Game Objects maximum health value. This works in combination with the `heal` method to ensure\nthe health value never exceeds the maximum.",
          "!type": "+Number"
        },
        "revive": {
          "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
          "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
        },
        "bringToTop": {
          "!doc": "Brings this Game Object to the top of its parents display list.\nVisually this means it will render over the top of any old child in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "events": {
          "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
          "!type": "+Phaser.Events"
        },
        "moveUp": {
          "!doc": "Moves this Game Object up one place in its parents display list.\nThis call has no effect if the Game Object is already at the top of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "postUpdate": {
          "!doc": "Internal method called by the World postUpdate cycle.",
          "!type": "fn()"
        },
        "smoothed": {
          "!doc": "Enable or disable texture smoothing for this Game Object.\n\nIt only takes effect if the Game Object is using an image based texture.\n\nSmoothing is enabled by default.",
          "!type": "+Boolean"
        },
        "destroy": {
          "!doc": "Destroys the Game Object. This removes it from its parent group, destroys the input, event and animation handlers if present\nand nulls its reference to `game`, freeing it up for garbage collection.\n\nIf this Game Object has the Events component it will also dispatch the `onDestroy` event.\n\nYou can optionally also destroy the BaseTexture this Game Object is using. Be careful if you've\nmore than one Game Object sharing the same BaseTexture.",
          "!type": "fn(destroyChildren: +Boolean, destroyTexture: +Boolean)"
        },
        "input": {
          "!doc": "The Input Handler for this Game Object.\n\nBy default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.\n\nAfter you have done this, this property will be a reference to the Phaser InputHandler.",
          "!type": "+Phaser.InputHandler"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "left": {
          "!doc": "The left coordinate of the Game Object.\nThis is the same as `x - offsetX`.",
          "!type": "+Number"
        },
        "reset": {
          "!doc": "Resets the Game Object.\n\nThis moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`, \n`visible` and `renderable` to true.\n\nIf this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.\n\nIf this Game Object has a Physics Body it will reset the Body.",
          "!type": "fn(x: +Number, y: +Number, health: +Number) -> +PIXI.DisplayObject"
        },
        "preUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn() -> +Boolean"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "damage": {
          "!doc": "Damages the Game Object. This removes the given amount of health from the `health` property.\n\nIf health is taken below or is equal to zero then the `kill` method is called.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "components": {
          "!doc": "The components this Game Object has installed.",
          "!type": "+Object"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
          "!type": "+Boolean"
        },
        "transformCallback": {
          "!doc": "The callback that will apply any scale limiting to the worldTransform.",
          "!type": "+Function"
        },
        "inWorld": {
          "!doc": "Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.",
          "!type": "+Boolean"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "world": {
          "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
          "!type": "+Phaser.Point"
        },
        "top": {
          "!doc": "The y coordinate of the Game Object.\nThis is the same as `y - offsetY`.",
          "!type": "+Number"
        },
        "angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        },
        "setScaleMinMax": {
          "!doc": "Sets the scaleMin and scaleMax values. These values are used to limit how far this Game Object will scale based on its parent.\n\nFor example if this Game Object has a `minScale` value of 1 and its parent has a `scale` value of 0.5, the 0.5 will be ignored \nand the scale value of 1 will be used, as the parents scale is lower than the minimum scale this Game Object should adhere to.\n\nBy setting these values you can carefully control how Game Objects deal with responsive scaling.\n\nIf only one parameter is given then that value will be used for both scaleMin and scaleMax:\n`setScaleMinMax(1)` = scaleMin.x, scaleMin.y, scaleMax.x and scaleMax.y all = 1\n\nIf only two parameters are given the first is set as scaleMin.x and y and the second as scaleMax.x and y:\n`setScaleMinMax(0.5, 2)` = scaleMin.x and y = 0.5 and scaleMax.x and y = 2\n\nIf you wish to set `scaleMin` with different values for x and y then either modify Game Object.scaleMin directly, \nor pass `null` for the `maxX` and `maxY` parameters.\n\nCall `setScaleMinMax(null)` to clear all previously set values.",
          "!type": "fn(minX: +Number, minY: +Number, maxX: +Number, maxY: +Number)"
        },
        "checkWorldBounds": {
          "!doc": "If this is set to `true` the Game Object checks if it is within the World bounds each frame. \n\nWhen it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.\n\nIf it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.\n\nIt also optionally kills the Game Object if `outOfBoundsKill` is `true`.\n\nWhen `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "key": {
          "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
          "!type": "+String"
        },
        "texture": {
          "!doc": "The texture that the sprite is using",
          "!type": "+Texture"
        },
        "health": {
          "!doc": "The Game Objects health value. This is a handy property for setting and manipulating health on a Game Object.\n\nIt can be used in combination with the `damage` method or modified directly.",
          "!type": "+Number"
        },
        "outOfCameraBoundsKill": {
          "!doc": "If this and the `autoCull` property are both set to `true`, then the `kill` method\nis called as soon as the Game Object leaves the camera bounds.",
          "!type": "+Boolean"
        },
        "destroyPhase": {
          "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
          "!type": "+Boolean"
        },
        "right": {
          "!doc": "The right coordinate of the Game Object.\nThis is the same as `x + width - offsetX`.",
          "!type": "+Number"
        },
        "kill": {
          "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousPosition": {
          "!doc": "The position the Game Object was located in the previous frame.",
          "!type": "+Phaser.Point"
        },
        "scaleMax": {
          "!doc": "The maximum scale this Game Object will scale up to. \n\nIt allows you to prevent a parent from scaling this Game Object higher than the given value.\n\nSet it to `null` to remove the limit.",
          "!type": "+Phaser.Point"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "anchor": {
          "!doc": "The anchor sets the origin point of the texture.\nThe default is 0,0 this means the texture's origin is the top left\nSetting than anchor to 0.5,0.5 means the textures origin is centered\nSetting the anchor to 1,1 would mean the textures origin points will be the bottom right corner",
          "!type": "+Phaser.Point"
        },
        "autoCull": {
          "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The position of the Game Object on the x axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "Controls if this Game Object is processed by the core game loop.\nIf this Game Object has a physics body it also controls if its physics body is updated or not.\nWhen `exists` is set to `false` it will remove its physics body from the physics world if it has one.\nIt also toggles the `visible` property to false as well.\n\nSetting `exists` to true will add its physics body back in to the physics world, if it has one.\nIt will also set the `visible` property to `true`.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The position of the Game Object on the y axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
          "!type": "+Number"
        },
        "scaleMin": {
          "!doc": "The minimum scale this Game Object will scale down to.\n\nIt allows you to prevent a parent from scaling this Game Object lower than the given value.\n\nSet it to `null` to remove the limit.",
          "!type": "+Phaser.Point"
        },
        "body": {
          "!doc": "`body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated \nproperties and methods via it.\n\nBy default Game Objects won't add themselves to any physics system and their `body` property will be `null`.\n\nTo enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object\nand `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.\n\nYou can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.\n\nImportant: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5, \nso the physics body is centered on the Game Object.\n\nIf you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.",
          "!type": "+Phaser.Physics.Arcade.Body"
        },
        "inCamera": {
          "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
          "!type": "+Boolean"
        },
        "offsetX": {
          "!doc": "The amount the Game Object is visually offset from its x coordinate.\nThis is the same as `width * anchor.x`.\nIt will only be > 0 if anchor.x is not equal to zero.",
          "!type": "+Number"
        },
        "tintedTexture": {
          "!doc": "A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)",
          "!type": "+Phaser.Canvas"
        },
        "offsetY": {
          "!doc": "The amount the Game Object is visually offset from its y coordinate.\nThis is the same as `height * anchor.y`.\nIt will only be > 0 if anchor.y is not equal to zero.",
          "!type": "+Number"
        },
        "fixedToCamera": {
          "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
          "!type": "+Boolean"
        },
        "renderOrderID": {
          "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
          "!type": "+Number"
        },
        "previousRotation": {
          "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
          "!type": "+Number"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.\nThis is the same as `y + height - offsetY`.",
          "!type": "+Number"
        },
        "cameraOffset": {
          "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
          "!type": "+Phaser.Point"
        },
        "moveDown": {
          "!doc": "Moves this Game Object down one place in its parents display list.\nThis call has no effect if the Game Object is already at the bottom of the display list.\n\nIf this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "updateCrop": {
          "!doc": "If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,\nor the rectangle it references, then you need to update the crop frame by calling this method.",
          "!type": "fn()"
        },
        "overlap": {
          "!doc": "Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object, \nwhich can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.\n\nThis check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.\n\nTherefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.\nIt should be fine for low-volume testing where physics isn't required.",
          "!type": "fn(displayObject: +Phaser.Sprite) -> +Boolean"
        },
        "loadTexture": {
          "!doc": "Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.\n\nIf your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.\n\nYou should only use `loadTexture` if you want to replace the base texture entirely.\n\nCalling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.\n\nYou can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite. \nDoing this then sets the key to be the `frame` argument (the frame is set to zero). \n\nThis allows you to create sprites using `load.image` during development, and then change them \nto use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS' \nand swapping it to be the key of the atlas data.\n\nNote: You cannot use a RenderTexture as a texture for a TileSprite.",
          "!type": "fn(key: +String, frame: +String, stopAnimation: +Boolean)"
        },
        "name": {
          "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
          "!type": "+String"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "crop": {
          "!doc": "Crop allows you to crop the texture being used to display this Game Object.\nSetting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.\n\nCropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,\nor by modifying `cropRect` property directly and then calling `updateCrop`.\n\nThe rectangle object given to this method can be either a `Phaser.Rectangle` or any other object \nso long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.\n\nA reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`, \nin which case the values are duplicated to a local object.",
          "!type": "fn(rect: +Phaser.Rectangle, copy: +Boolean)"
        },
        "frame": {
          "!doc": "Gets or sets the current frame index of the texture being used to render this Game Object.\n\nTo change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,\nfor example: `player.frame = 4`.\n\nIf the frame index given doesn't exist it will revert to the first frame found in the texture.\n\nIf you are using a texture atlas then you should use the `frameName` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+Number"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "shader": {
          "!doc": "The shader that will be used to render the texture to the stage. Set to null to remove a current shader.",
          "!type": "+PIXI.AbstractFilter"
        },
        "cropRect": {
          "!doc": "The Rectangle used to crop the texture this Game Object uses.\nSet this property via `crop`. \nIf you modify this property directly you must call `updateCrop` in order to have the change take effect.",
          "!type": "+Phaser.Rectangle"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "deltaZ": {
          "!doc": "The delta value.",
          "!type": "+Number"
        },
        "transformCallbackContext": {
          "!doc": "The context under which `transformCallback` is called.",
          "!type": "+Object"
        },
        "deltaX": {
          "!doc": "Returns the delta x value. The difference between world.x now and in the previous frame.\n\nThe value will be positive if the Game Object has moved to the right or negative if to the left.",
          "!type": "+Number"
        },
        "deltaY": {
          "!doc": "Returns the delta y value. The difference between world.y now and in the previous frame.\n\nThe value will be positive if the Game Object has moved down or negative if up.",
          "!type": "+Number"
        },
        "update": {
          "!doc": "Override this method in your own custom objects to handle any update requirements.\nIt is called immediately after `preUpdate` and before `postUpdate`.\nRemember if this Game Object has any children you should call update on those too.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "tint": {
          "!doc": "The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.",
          "!type": "+Number"
        },
        "inputEnabled": {
          "!doc": "By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created\nfor this Game Object and it will then start to process click / touch events and more.\n\nYou can then access the Input Handler via `this.input`.\n\nNote that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.\n\nIf you set this property to false it will stop the Input Handler from processing any more input events.",
          "!type": "+Boolean"
        },
        "setFrame": {
          "!doc": "Sets the texture frame the Game Object uses for rendering.\n\nThis is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.",
          "!type": "fn(frame: +Phaser.Frame)"
        },
        "animations": {
          "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
          "!type": "+Phaser.AnimationManager"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "heal": {
          "!doc": "Heal the Game Object. This adds the given amount of health to the `health` property.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "setHealth": {
          "!doc": "Sets the health property of the Game Object to the given amount.\nWill never exceed the `maxHealth` value.",
          "!type": "fn(amount: +Number) -> +Phaser.Sprite"
        },
        "debug": {
          "!doc": "A debug flag designed for use with `Game.enableStep`.",
          "!type": "+Boolean"
        },
        "frameName": {
          "!doc": "Gets or sets the current frame name of the texture being used to render this Game Object.\n\nTo change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use, \nfor example: `player.frameName = \"idle\"`.\n\nIf the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.\n\nIf you are using a sprite sheet then you should use the `frame` property instead.\n\nIf you wish to fully replace the texture being used see `loadTexture`.",
          "!type": "+String"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "sendToBack": {
          "!doc": "Sends this Game Object to the bottom of its parents display list.\nVisually this means it will render below all other children in the same Group.\n\nIf this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World, \nbecause the World is the root Group from which all Game Objects descend.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "resetFrame": {
          "!doc": "Resets the texture frame dimensions that the Game Object uses for rendering.",
          "!type": "fn()"
        },
        "pendingDestroy": {
          "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
          "!type": "+Boolean"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.\n\nWarning: You cannot have a blend mode and a filter active on the same Sprite. Doing so will render the sprite invisible.",
          "!type": "+Number"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "fresh": {
          "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
          "!type": "+Boolean"
        }
      }
    },
    "Keyboard": {
      "!doc": "The Keyboard class monitors keyboard input and dispatches keyboard events.\n\n_Note_: many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\nSee http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.\n\nAlso please be aware that certain browser extensions can disable or override Phaser keyboard handling.\nFor example the Chrome extension vimium is known to disable Phaser from using the D key. And there are others.\nSo please check your extensions before opening Phaser issues.",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "game": {
          "!doc": "Local reference to game.",
          "!type": "+Phaser.Game"
        },
        "onPressCallback": {
          "!doc": "This callback is invoked every time a DOM onkeypress event is raised, which is only for printable keys.",
          "!type": "+Function"
        },
        "createCursorKeys": {
          "!doc": "Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right.",
          "!type": "fn() -> +Object"
        },
        "pressEvent": {
          "!doc": "The most recent DOM event from keypress.",
          "!type": "+Object"
        },
        "update": {
          "!doc": "Updates all currently defined keys.",
          "!type": "fn()"
        },
        "onUpCallback": {
          "!doc": "This callback is invoked every time a key is released.",
          "!type": "+Function"
        },
        "addKey": {
          "!doc": "If you need more fine-grained control over a Key you can create a new Phaser.Key object via this method.\nThe Key object can then be polled, have events attached to it, etc.",
          "!type": "fn(keycode: +Number) -> +Phaser.Key"
        },
        "isDown": {
          "!doc": "Returns true of the key is currently pressed down. Note that it can only detect key presses on the web browser.",
          "!type": "fn(keycode: +Number) -> +Boolean"
        },
        "enabled": {
          "!doc": "Keyboard input will only be processed if enabled.",
          "!type": "+Boolean"
        },
        "upDuration": {
          "!doc": "Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,\nor was pressed down longer ago than then given duration.",
          "!type": "fn(keycode: +Phaser.KeyCode, duration: +Number) -> +Boolean"
        },
        "addKeyCapture": {
          "!doc": "By default when a key is pressed Phaser will not stop the event from propagating up to the browser.\nThere are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.\n\nThe `addKeyCapture` method enables consuming keyboard event for specific keys so it doesn't bubble up to the the browser\nand cause the default browser behavior.\n\nPass in either a single keycode or an array/hash of keycodes.",
          "!type": "fn(keycode: +Number)"
        },
        "clearCaptures": {
          "!doc": "Clear all set key captures.",
          "!type": "fn()"
        },
        "removeKey": {
          "!doc": "Removes a Key object from the Keyboard manager.",
          "!type": "fn(keycode: +Number)"
        },
        "lastKey": {
          "!doc": "The most recently pressed Key.",
          "!type": "+Phaser.Key"
        },
        "processKeyUp": {
          "!doc": "Process the keyup event.",
          "!type": "fn(event: +KeyboardEvent)"
        },
        "event": {
          "!doc": "The most recent DOM event from keydown or keyup. This is updated every time a new key is pressed or released.",
          "!type": "+Object"
        },
        "addCallbacks": {
          "!doc": "Add callbacks to the Keyboard handler so that each time a key is pressed down or released the callbacks are activated.",
          "!type": "fn(context: +Object, onDown: +Function, onUp: +Function, onPress: +Function)"
        },
        "start": {
          "!doc": "Starts the Keyboard event listeners running (keydown and keyup). They are attached to the window.\nThis is called automatically by Phaser.Input and should not normally be invoked directly.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Stops the Keyboard event listeners from running (keydown and keyup). They are removed from the window.\nAlso clears all key captures and currently created Key objects.",
          "!type": "fn()"
        },
        "callbackContext": {
          "!doc": "The context under which the callbacks are run.",
          "!type": "+Object"
        },
        "processKeyPress": {
          "!doc": "Process the keypress event.",
          "!type": "fn(event: +KeyboardEvent)"
        },
        "downDuration": {
          "!doc": "Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,\nor was pressed down longer ago than then given duration.",
          "!type": "fn(keycode: +Number, duration: +Number) -> +Boolean"
        },
        "addKeys": {
          "!doc": "A practical way to create an object containing user selected hotkeys.\n\nFor example,\n\n    addKeys( { 'up': Phaser.KeyCode.W, 'down': Phaser.KeyCode.S, 'left': Phaser.KeyCode.A, 'right': Phaser.KeyCode.D } );\n\nwould return an object containing properties (`up`, `down`, `left` and `right`) referring to {@link Phaser.Key} object.",
          "!type": "fn(keys: +Object) -> +Object"
        },
        "removeKeyCapture": {
          "!doc": "Removes an existing key capture.",
          "!type": "fn(keycode: +Number)"
        },
        "stop": {
          "!doc": "Stops the Keyboard event listeners from running (keydown, keyup and keypress). They are removed from the window.",
          "!type": "fn()"
        },
        "onDownCallback": {
          "!doc": "This callback is invoked every time a key is pressed down, including key repeats when a key is held down.",
          "!type": "+Function"
        },
        "lastChar": {
          "!doc": "The string value of the most recently pressed key.",
          "!type": "+String"
        },
        "reset": {
          "!doc": "Resets all Keys.",
          "!type": "fn(hard: +Boolean)"
        },
        "processKeyDown": {
          "!doc": "Process the keydown event.",
          "!type": "fn(event: +KeyboardEvent)"
        }
      }
    },
    "TweenData": {
      "COMPLETE": "+Number",
      "RUNNING": "+Number",
      "!doc": "A Phaser.Tween contains at least one TweenData object. It contains all of the tween data values, such as the\nstarting and ending values, the ease function, interpolation and duration. The Tween acts as a timeline manager for\nTweenData objects and can contain multiple TweenData objects.",
      "PENDING": "+Number",
      "!type": "fn(parent: +Phaser.Tween)",
      "LOOPED": "+Number",
      "prototype": {
        "parent": {
          "!doc": "The Tween which owns this TweenData.",
          "!type": "+Phaser.Tween"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "update": {
          "!doc": "Updates this Tween. This is called automatically by Phaser.Tween.",
          "!type": "fn(time: +Number) -> +Number"
        },
        "percent": {
          "!doc": "A value between 0 and 1 that represents how far through the duration this tween is.",
          "!type": "+Number"
        },
        "duration": {
          "!doc": "The duration of the tween in ms.",
          "!type": "+Number"
        },
        "dt": {
          "!doc": "Current time value.",
          "!type": "+Number"
        },
        "interpolationFunction": {
          "!doc": "The interpolation function used for the Tween.",
          "!type": "+Function"
        },
        "yoyoDelay": {
          "!doc": "The amount of time in ms between yoyos of this tween.",
          "!type": "+Number"
        },
        "yoyo": {
          "!doc": "True if the Tween is set to yoyo, otherwise false.",
          "!type": "+Boolean"
        },
        "isRunning": {
          "!doc": "If the tween is running this is set to `true`. Unless Phaser.Tween a TweenData that is waiting for a delay to expire is *not* considered as running.",
          "!type": "+Boolean"
        },
        "isFrom": {
          "!doc": "Is this a from tween or a to tween?",
          "!type": "+Boolean"
        },
        "generateData": {
          "!doc": "This will generate an array populated with the tweened object values from start to end.\nIt works by running the tween simulation at the given frame rate based on the values set-up in Tween.to and Tween.from.\nJust one play through of the tween data is returned, including yoyo if set.",
          "!type": "fn(frameRate: +Number) -> +Array"
        },
        "from": {
          "!doc": "Sets this tween to be a `from` tween on the properties given. A `from` tween sets the target to the destination value and tweens to its current value.\nFor example a Sprite with an `x` coordinate of 100 tweened from `x` 500 would be set to `x` 500 and then tweened to `x` 100 by giving a properties object of `{ x: 500 }`.",
          "!type": "fn(properties: +Object, duration: +Number, ease: +Function, delay: +Number, repeat: +Number, yoyo: +Boolean) -> +Phaser.TweenData"
        },
        "startTime": {
          "!doc": "The time the Tween started or null if it hasn't yet started.",
          "!type": "+Number"
        },
        "repeatCounter": {
          "!doc": "If the Tween is set to repeat this contains the current repeat count.",
          "!type": "+Number"
        },
        "repeatDelay": {
          "!doc": "The amount of time in ms between repeats of this tween.",
          "!type": "+Number"
        },
        "value": {
          "!doc": "The current calculated value.",
          "!type": "+Number"
        },
        "easingFunction": {
          "!doc": "The easing function used for the Tween.",
          "!type": "+Function"
        },
        "inReverse": {
          "!doc": "When a Tween is yoyoing this value holds if it's currently playing forwards (false) or in reverse (true).",
          "!type": "+Boolean"
        },
        "start": {
          "!doc": "Starts the Tween running.",
          "!type": "fn() -> +Phaser.TweenData"
        },
        "interpolate": {
          "!doc": "True if the Tween will use interpolation (i.e. is an Array to Array tween)",
          "!type": "+Boolean"
        },
        "interpolationContext": {
          "!doc": "The interpolation function context used for the Tween.",
          "!type": "+Object"
        },
        "repeatTotal": {
          "!doc": "The total number of times this Tween will repeat.",
          "!type": "+Number"
        },
        "delay": {
          "!doc": "The amount to delay by until the Tween starts (in ms). Only applies to the start, use repeatDelay to handle repeats.",
          "!type": "+Number"
        },
        "to": {
          "!doc": "Sets this tween to be a `to` tween on the properties given. A `to` tween starts at the current value and tweens to the destination value given.\nFor example a Sprite with an `x` coordinate of 100 could be tweened to `x` 200 by giving a properties object of `{ x: 200 }`.",
          "!type": "fn(properties: +Object, duration: +Number, ease: +Function, delay: +Number, repeat: +Number, yoyo: +Boolean) -> +Phaser.TweenData"
        }
      }
    },
    "Tile": {
      "!doc": "A Tile is a representation of a single tile within the Tilemap.",
      "!type": "fn(layer: +Object, index: +Number, x: +Number, y: +Number, width: +Number, height: +Number)",
      "prototype": {
        "flipped": {
          "!doc": "Whether this tile is flipped (mirrored) or not.",
          "!type": "+Boolean"
        },
        "intersects": {
          "!doc": "Check for intersection with this tile.",
          "!type": "fn(x: +Number, y: +Number, right: +Number, bottom: +Number)"
        },
        "collideUp": {
          "!doc": "Indicating collide with any object on the top.",
          "!type": "+Boolean"
        },
        "collideLeft": {
          "!doc": "Indicating collide with any object on the left.",
          "!type": "+Boolean"
        },
        "layer": {
          "!doc": "The layer in the Tilemap data that this tile belongs to.",
          "!type": "+Object"
        },
        "faceRight": {
          "!doc": "Is the right of this tile an interesting edge?",
          "!type": "+Boolean"
        },
        "faceLeft": {
          "!doc": "Is the left of this tile an interesting edge?",
          "!type": "+Boolean"
        },
        "top": {
          "!doc": "The y value.",
          "!type": "+Number"
        },
        "scanned": {
          "!doc": "Has this tile been walked / turned into a poly?",
          "!type": "+Boolean"
        },
        "alpha": {
          "!doc": "The alpha value at which this tile is drawn to the canvas.",
          "!type": "+Number"
        },
        "collisionCallback": {
          "!doc": "Tile collision callback.",
          "!type": "+Function"
        },
        "resetCollision": {
          "!doc": "Reset collision status flags.",
          "!type": "fn()"
        },
        "copy": {
          "!doc": "Copies the tile data and properties from the given tile to this tile.",
          "!type": "fn(tile: +Phaser.Tile)"
        },
        "faceTop": {
          "!doc": "Is the top of this tile an interesting edge?",
          "!type": "+Boolean"
        },
        "setCollisionCallback": {
          "!doc": "Set a callback to be called when this tile is hit by an object.\nThe callback must true true for collision processing to take place.",
          "!type": "fn(callback: +Function, context: +Object)"
        },
        "height": {
          "!doc": "The height of the tile in pixels.",
          "!type": "+Number"
        },
        "collides": {
          "!doc": "True if this tile can collide on any of its faces.",
          "!type": "+Boolean"
        },
        "faceBottom": {
          "!doc": "Is the bottom of this tile an interesting edge?",
          "!type": "+Boolean"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.",
          "!type": "+Number"
        },
        "rotation": {
          "!doc": "The rotation angle of this tile.",
          "!type": "+Number"
        },
        "canCollide": {
          "!doc": "True if this tile can collide on any of its faces or has a collision callback set.",
          "!type": "+Boolean"
        },
        "destroy": {
          "!doc": "Clean up memory.",
          "!type": "fn()"
        },
        "index": {
          "!doc": "The index of this tile within the map data corresponding to the tileset, or -1 if this represents a blank/null tile.",
          "!type": "+Number"
        },
        "collideDown": {
          "!doc": "Indicating collide with any object on the bottom.",
          "!type": "+Boolean"
        },
        "right": {
          "!doc": "The sum of the x and width properties.",
          "!type": "+Number"
        },
        "collisionCallbackContext": {
          "!doc": "The context in which the collision callback will be called.",
          "!type": "+Object"
        },
        "collideRight": {
          "!doc": "Indicating collide with any object on the right.",
          "!type": "+Boolean"
        },
        "setCollision": {
          "!doc": "Sets the collision flags for each side of this tile and updates the interesting faces list.",
          "!type": "fn(left: +Boolean, right: +Boolean, up: +Boolean, down: +Boolean)"
        },
        "left": {
          "!doc": "The x value in pixels.",
          "!type": "+Number"
        },
        "x": {
          "!doc": "The x map coordinate of this tile.",
          "!type": "+Number"
        },
        "width": {
          "!doc": "The width of the tile in pixels.",
          "!type": "+Number"
        },
        "y": {
          "!doc": "The y map coordinate of this tile.",
          "!type": "+Number"
        },
        "isInteresting": {
          "!doc": "Is this tile interesting?",
          "!type": "fn(collides: +Boolean, faces: +Boolean) -> +Boolean"
        },
        "containsPoint": {
          "!doc": "Check if the given x and y world coordinates are within this Tile.",
          "!type": "fn(x: +Number, y: +Number) -> +Boolean"
        },
        "properties": {
          "!doc": "Tile specific properties.",
          "!type": "+Object"
        }
      }
    },
    "SPRITE": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Point": {
      "negative": {
        "!doc": "Creates a negative Point.",
        "!type": "fn(a: +Phaser.Point, out: +Phaser.Point) -> +Phaser.Point"
      },
      "multiplyAdd": {
        "!doc": "Adds two 2D Points together and multiplies the result by the given scalar.",
        "!type": "fn(a: +Phaser.Point, b: +Phaser.Point, s: +Number, out: +Phaser.Point) -> +Phaser.Point"
      },
      "projectUnit": {
        "!doc": "Project two Points onto a Point of unit length.",
        "!type": "fn(a: +Phaser.Point, b: +Phaser.Point, out: +Phaser.Point) -> +Phaser.Point"
      },
      "centroid": {
        "!doc": "Calculates centroid (or midpoint) from an array of points. If only one point is provided, that point is returned.",
        "!type": "fn(points: +Array._Phaser.Point_, out: +Phaser.Point) -> +Phaser.Point"
      },
      "!doc": "A Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.\nThe following code creates a point at (0,0):\n`var myPoint = new Phaser.Point();`\nYou can also use them as 2D Vectors and you'll find different vector related methods in this class.",
      "project": {
        "!doc": "Project two Points onto another Point.",
        "!type": "fn(a: +Phaser.Point, b: +Phaser.Point, out: +Phaser.Point) -> +Phaser.Point"
      },
      "interpolate": {
        "!doc": "Interpolates the two given Points, based on the `f` value (between 0 and 1) and returns a new Point.",
        "!type": "fn(a: +Phaser.Point, b: +Phaser.Point, f: +Number, out: +Phaser.Point) -> +Phaser.Point"
      },
      "parse": {
        "!doc": "Parses an object for x and/or y properties and returns a new Phaser.Point with matching values.\nIf the object doesn't contain those properties a Point with x/y of zero will be returned.",
        "!type": "fn(obj: +Object, xProp: +String, yProp: +String) -> +Phaser.Point"
      },
      "!type": "fn(x: +Number, y: +Number)",
      "prototype": {
        "rotate": {
          "!doc": "Rotates this Point around the x/y coordinates given to the desired angle.",
          "!type": "fn(x: +Number, y: +Number, angle: +Number, asDegrees: +Boolean, distance: +Number) -> +Phaser.Point"
        },
        "distance": {
          "!doc": "Returns the distance of this Point object to the given object (can be a Circle, Point or anything with x/y properties)",
          "!type": "fn(dest: +Object, round: +Boolean) -> +Number"
        },
        "setMagnitude": {
          "!doc": "Alters the length of the Point without changing the direction.",
          "!type": "fn(magnitude: +Number) -> +Phaser.Point"
        },
        "perp": {
          "!doc": "Make this Point perpendicular (90 degrees rotation)",
          "!type": "fn() -> +Phaser.Point"
        },
        "dot": {
          "!doc": "The dot product of this and another Point object.",
          "!type": "fn(a: +Phaser.Point) -> +Number"
        },
        "getMagnitudeSq": {
          "!doc": "Calculates the length squared of the Point object.",
          "!type": "fn() -> +Number"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "copyTo": {
          "!doc": "Copies the x and y properties from this Point to any given object.",
          "!type": "fn(dest: +Object) -> +Object"
        },
        "normalize": {
          "!doc": "Alters the Point object so that its length is 1, but it retains the same direction.",
          "!type": "fn() -> +Phaser.Point"
        },
        "angle": {
          "!doc": "Returns the angle between this Point object and another object with public x and y properties.",
          "!type": "fn(a: +Phaser.Point, asDegrees: +Boolean) -> +Number"
        },
        "isZero": {
          "!doc": "Determine if this point is at 0,0.",
          "!type": "fn() -> +Boolean"
        },
        "divide": {
          "!doc": "Divides Point.x and Point.y by the given x and y values.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Point"
        },
        "multiply": {
          "!doc": "Multiplies Point.x and Point.y by the given x and y values. Sometimes known as `Scale`.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Point"
        },
        "floor": {
          "!doc": "Math.floor() both the x and y properties of this Point.",
          "!type": "fn() -> +Phaser.Point"
        },
        "clamp": {
          "!doc": "Clamps this Point object values to be between the given min and max.",
          "!type": "fn(min: +Number, max: +Number) -> +Phaser.Point"
        },
        "rperp": {
          "!doc": "Make this Point perpendicular (-90 degrees rotation)",
          "!type": "fn() -> +Phaser.Point"
        },
        "add": {
          "!doc": "Adds the given x and y values to this Point.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Point"
        },
        "set": {
          "!doc": "Sets the `x` and `y` values of this Point object to the given values.\nIf you omit the `y` value then the `x` value will be applied to both, for example:\n`Point.set(2)` is the same as `Point.set(2, 2)`",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Point"
        },
        "invert": {
          "!doc": "Inverts the x and y values of this Point",
          "!type": "fn() -> +Phaser.Point"
        },
        "subtract": {
          "!doc": "Subtracts the given x and y values from this Point.",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Point"
        },
        "cross": {
          "!doc": "The cross product of this and another Point object.",
          "!type": "fn(a: +Phaser.Point) -> +Number"
        },
        "ceil": {
          "!doc": "Math.ceil() both the x and y properties of this Point.",
          "!type": "fn() -> +Phaser.Point"
        },
        "getMagnitude": {
          "!doc": "Calculates the length of the Point object.",
          "!type": "fn() -> +Number"
        },
        "copyFrom": {
          "!doc": "Copies the x and y properties from any given object to this Point.",
          "!type": "fn(source: +Object) -> +Phaser.Point"
        },
        "clampY": {
          "!doc": "Clamps the y value of this Point to be between the given min and max",
          "!type": "fn(min: +Number, max: +Number) -> +Phaser.Point"
        },
        "clampX": {
          "!doc": "Clamps the x value of this Point to be between the given min and max.",
          "!type": "fn(min: +Number, max: +Number) -> +Phaser.Point"
        },
        "normalRightHand": {
          "!doc": "Right-hand normalize (make unit length) this Point.",
          "!type": "fn() -> +Phaser.Point"
        },
        "equals": {
          "!doc": "Determines whether the given objects x/y values are equal to this Point object.",
          "!type": "fn(a: +Phaser.Point) -> +Boolean"
        },
        "clone": {
          "!doc": "Creates a copy of the given Point.",
          "!type": "fn(output: +Phaser.Point) -> +Phaser.Point"
        },
        "x": {
          "!doc": "The x value of the point.",
          "!type": "+Number"
        },
        "setTo": {
          "!doc": "Sets the `x` and `y` values of this Point object to the given values.\nIf you omit the `y` value then the `x` value will be applied to both, for example:\n`Point.setTo(2)` is the same as `Point.setTo(2, 2)`",
          "!type": "fn(x: +Number, y: +Number) -> +Phaser.Point"
        },
        "y": {
          "!doc": "The y value of the point.",
          "!type": "+Number"
        },
        "toString": {
          "!doc": "Returns a string representation of this object.",
          "!type": "fn() -> +String"
        }
      }
    },
    "WEBGL": {
      "!doc": "WebGL Renderer.",
      "!type": "+Number"
    },
    "Mouse": {
      "LEFT_BUTTON": "+Number",
      "MIDDLE_BUTTON": "+Number",
      "RIGHT_BUTTON": "+Number",
      "FORWARD_BUTTON": "+Number",
      "!doc": "The Mouse class is responsible for handling all aspects of mouse interaction with the browser.\n\nIt captures and processes mouse events that happen on the game canvas object.\nIt also adds a single `mouseup` listener to `window` which is used to capture the mouse being released\nwhen not over the game.\n\nYou should not normally access this class directly, but instead use a Phaser.Pointer object\nwhich normalises all game input for you, including accurate button handling.",
      "WHEEL_DOWN": "+Number",
      "BACK_BUTTON": "+Number",
      "WHEEL_UP": "+Number",
      "NO_BUTTON": "+Number",
      "!type": "fn(game: +Phaser.Game)",
      "prototype": {
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "requestPointerLock": {
          "!doc": "If the browser supports it you can request that the pointer be locked to the browser window.\nThis is classically known as 'FPS controls', where the pointer can't leave the browser until the user presses an exit key.\nIf the browser successfully enters a locked state the event Phaser.Mouse.pointerLock will be dispatched and the first parameter will be 'true'.",
          "!type": "fn()"
        },
        "mouseOutCallback": {
          "!doc": "A callback that can be fired when the mouse is no longer over the game canvas.",
          "!type": "+Function"
        },
        "mouseWheelCallback": {
          "!doc": "A callback that can be fired when the mousewheel is used.",
          "!type": "+Function"
        },
        "wheelDelta": {
          "!doc": "The direction of the _last_ mousewheel usage 1 for up -1 for down.",
          "!type": "+Number"
        },
        "releasePointerLock": {
          "!doc": "Internal release pointer lock handler.",
          "!type": "fn()"
        },
        "onMouseWheel": {
          "!doc": "The internal method that handles the mouse wheel event from the browser.",
          "!type": "fn(event: +MouseEvent)"
        },
        "mouseOverCallback": {
          "!doc": "A callback that can be fired when the mouse enters the game canvas (usually after a mouseout).",
          "!type": "+Function"
        },
        "enabled": {
          "!doc": "Mouse input will only be processed if enabled.",
          "!type": "+Boolean"
        },
        "onMouseOut": {
          "!doc": "The internal method that handles the mouse out event from the browser.",
          "!type": "fn(event: +MouseEvent)"
        },
        "button": {
          "!doc": "This property was removed in Phaser 2.4 and should no longer be used.\nInstead please see the Pointer button properties such as `Pointer.leftButton`, `Pointer.rightButton` and so on.\nOr Pointer.button holds the DOM event button value if you require that.",
          "!type": "+Number"
        },
        "pointerLock": {
          "!doc": "This event is dispatched when the browser enters or leaves pointer lock state.",
          "!type": "+Phaser.Signal"
        },
        "locked": {
          "!doc": "If the mouse has been Pointer Locked successfully this will be set to true.",
          "!type": "+Boolean"
        },
        "event": {
          "!doc": "The browser mouse DOM event. Will be null if no mouse event has ever been received.\nAccess this property only inside a Mouse event handler and do not keep references to it.",
          "!type": "+MouseEvent"
        },
        "onMouseDown": {
          "!doc": "The internal method that handles the mouse down event from the browser.",
          "!type": "fn(event: +MouseEvent)"
        },
        "onMouseOver": {
          "!doc": "The internal method that handles the mouse over event from the browser.",
          "!type": "fn(event: +MouseEvent)"
        },
        "mouseDownCallback": {
          "!doc": "A callback that can be fired when the mouse is pressed down.",
          "!type": "+Function"
        },
        "start": {
          "!doc": "Starts the event listeners running.",
          "!type": "fn()"
        },
        "capture": {
          "!doc": "If true the DOM mouse events will have event.preventDefault applied to them, if false they will propagate fully.",
          "!type": "+Boolean"
        },
        "onMouseUpGlobal": {
          "!doc": "The internal method that handles the mouse up event from the window.",
          "!type": "fn(event: +MouseEvent)"
        },
        "callbackContext": {
          "!doc": "The context under which callbacks are called.",
          "!type": "+Object"
        },
        "onMouseMove": {
          "!doc": "The internal method that handles the mouse move event from the browser.",
          "!type": "fn(event: +MouseEvent)"
        },
        "stopOnGameOut": {
          "!doc": "If true Pointer.stop will be called if the mouse leaves the game canvas.",
          "!type": "+Boolean"
        },
        "mouseUpCallback": {
          "!doc": "A callback that can be fired when the mouse is released from a pressed down state.",
          "!type": "+Function"
        },
        "onMouseOutGlobal": {
          "!doc": "The internal method that handles the mouse out event from the window.",
          "!type": "fn(event: +MouseEvent)"
        },
        "input": {
          "!doc": "A reference to the Phaser Input Manager.",
          "!type": "+Phaser.Input"
        },
        "stop": {
          "!doc": "Stop the event listeners.",
          "!type": "fn()"
        },
        "pointerLockChange": {
          "!doc": "Internal pointerLockChange handler.",
          "!type": "fn(event: +Event)"
        },
        "onMouseUp": {
          "!doc": "The internal method that handles the mouse up event from the browser.",
          "!type": "fn(event: +MouseEvent)"
        }
      }
    },
    "BitmapText": {
      "init": {
        "!doc": "Initializes the mixin components.\n\nThe `this` context should be an instance of the component mixin target.",
        "!type": "fn()"
      },
      "install": {
        "!doc": "Installs / registers mixin components.\n\nThe `this` context should be that of the applicable object instance or prototype.",
        "!type": "fn()"
      },
      "!doc": "BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\nIt then generates a new Sprite object for each letter of the text, proportionally spaced out and aligned to \nmatch the font structure.\n\nBitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability \nto use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\nprocessing the font texture in an image editor, applying fills and any other effects required.\n\nTo create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\n\nIf you are having performance issues due to the volume of sprites being rendered, and do not require the text to be constantly\nupdating, you can use BitmapText.generateTexture to create a static texture from this BitmapText.\n\nTo create a BitmapText data files you can use:\n\nBMFont (Windows, free): http://www.angelcode.com/products/bmfont/\nGlyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner\nLittera (Web-based, free): http://kvazars.com/littera/\n\nFor most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\nconverting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson\n\nIf you were using an older version of Phaser (< 2.4) and using the DOMish parser hack, please remove this. It isn't required any longer.",
      "!type": "fn(game: +Phaser.Game, x: +Number, y: +Number, font: +String, text: +String, size: +Number, align: +String)",
      "prototype": {
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "lifespan": {
          "!doc": "The lifespan allows you to give a Game Object a lifespan in milliseconds.\n\nOnce the Game Object is 'born' you can set this to a positive value.\n\nIt is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.\nWhen it reaches zero it will call the `kill` method.\n\nVery handy for particles, bullets, collectibles, or any other short-lived entity.",
          "!type": "+Number"
        },
        "outOfBoundsKill": {
          "!doc": "If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.",
          "!type": "+Boolean"
        },
        "purgeGlyphs": {
          "!doc": "If a BitmapText changes from having a large number of characters to having very few characters it will cause lots of\nSprites to be retained in the BitmapText._glyphs array. Although they are not attached to the display list they\nstill take up memory while sat in the glyphs pool waiting to be re-used in the future.\n\nIf you know that the BitmapText will not grow any larger then you can purge out the excess glyphs from the pool \nby calling this method.\n\nCalling this doesn't prevent you from increasing the length of the text again in the future.",
          "!type": "fn() -> +Number"
        },
        "type": {
          "!doc": "The const type of this object.",
          "!type": "+Number"
        },
        "align": {
          "!doc": "Alignment for multi-line text ('left', 'center' or 'right'), does not affect single lines of text.",
          "!type": "+String"
        },
        "body": {
          "!doc": "`body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated \nproperties and methods via it.\n\nBy default Game Objects won't add themselves to any physics system and their `body` property will be `null`.\n\nTo enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object\nand `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.\n\nYou can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.\n\nImportant: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5, \nso the physics body is centered on the Game Object.\n\nIf you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.",
          "!type": "+Phaser.Physics.Arcade.Body"
        },
        "inCamera": {
          "!doc": "Checks if the Game Objects bounds intersect with the Game Camera bounds.\nReturns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.",
          "!type": "+Boolean"
        },
        "offsetX": {
          "!doc": "The amount the Game Object is visually offset from its x coordinate.\nThis is the same as `width * anchor.x`.\nIt will only be > 0 if anchor.x is not equal to zero.",
          "!type": "+Number"
        },
        "cleanText": {
          "!doc": "Given a text string this will scan each character in the string to ensure it exists\nin the BitmapText font data. If it doesn't the character is removed, or replaced with the `replace` argument.\n\nIf no font data has been loaded at all this returns an empty string, as nothing can be rendered.",
          "!type": "fn(text: +String, replace: +String) -> +String"
        },
        "offsetY": {
          "!doc": "The amount the Game Object is visually offset from its y coordinate.\nThis is the same as `height * anchor.y`.\nIt will only be > 0 if anchor.y is not equal to zero.",
          "!type": "+Number"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "revive": {
          "!doc": "Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.\n\nA resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.\n\nIt will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.",
          "!type": "fn(health: +Number) -> +PIXI.DisplayObject"
        },
        "text": {
          "!doc": "The text to be displayed by this BitmapText object.",
          "!type": "+String"
        },
        "fixedToCamera": {
          "!doc": "A Game Object that is \"fixed\" to the camera uses its x/y coordinates as offsets from the top left of the camera during rendering.\n\nThe values are adjusted at the rendering stage, overriding the Game Objects actual world position.\n\nThe end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world\nthe camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times \nregardless where in the world the camera is.\n\nThe offsets are stored in the `cameraOffset` property.\n\nNote that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.\n\nBe careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.",
          "!type": "+Boolean"
        },
        "renderOrderID": {
          "!doc": "The render order ID is used internally by the renderer and Input Manager and should not be modified.\nThis property is mostly used internally by the renderers, but is exposed for the use of plugins.",
          "!type": "+Number"
        },
        "events": {
          "!doc": "All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this\nGame Object, or any of its components.",
          "!type": "+Phaser.Events"
        },
        "physicsType": {
          "!doc": "The const physics body type of this object.",
          "!type": "+Number"
        },
        "maxWidth": {
          "!doc": "The maximum width of this BitmapText in pixels.",
          "!type": "+Number"
        },
        "previousRotation": {
          "!doc": "The rotation the Game Object was in set to in the previous frame. Value is in radians.",
          "!type": "+Number"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "postUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn()"
        },
        "bottom": {
          "!doc": "The sum of the y and height properties.\nThis is the same as `y + height - offsetY`.",
          "!type": "+Number"
        },
        "cameraOffset": {
          "!doc": "The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.\n\nThe values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.",
          "!type": "+Phaser.Point"
        },
        "smoothed": {
          "!doc": "Enable or disable texture smoothing for this BitmapText.\n\nThe smoothing is applied to the BaseTexture of this font, which all letters of the text reference.\n\nSmoothing is enabled by default.",
          "!type": "+Boolean"
        },
        "destroy": {
          "!doc": "Destroys the Game Object. This removes it from its parent group, destroys the input, event and animation handlers if present\nand nulls its reference to `game`, freeing it up for garbage collection.\n\nIf this Game Object has the Events component it will also dispatch the `onDestroy` event.\n\nYou can optionally also destroy the BaseTexture this Game Object is using. Be careful if you've\nmore than one Game Object sharing the same BaseTexture.",
          "!type": "fn(destroyChildren: +Boolean, destroyTexture: +Boolean)"
        },
        "textWidth": {
          "!doc": "The width in pixels of the overall text area, taking into consideration multi-line text.",
          "!type": "+Number"
        },
        "input": {
          "!doc": "The Input Handler for this Game Object.\n\nBy default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.\n\nAfter you have done this, this property will be a reference to the Phaser InputHandler.",
          "!type": "+Phaser.InputHandler"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "left": {
          "!doc": "The left coordinate of the Game Object.\nThis is the same as `x - offsetX`.",
          "!type": "+Number"
        },
        "name": {
          "!doc": "A user defined name given to this Game Object.\nThis value isn't ever used internally by Phaser, it is meant as a game level property.",
          "!type": "+String"
        },
        "reset": {
          "!doc": "Resets the Game Object.\n\nThis moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`, \n`visible` and `renderable` to true.\n\nIf this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.\n\nIf this Game Object has a Physics Body it will reset the Body.",
          "!type": "fn(x: +Number, y: +Number, health: +Number) -> +PIXI.DisplayObject"
        },
        "fontSize": {
          "!doc": "The size of the font in pixels.",
          "!type": "+Number"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "preUpdate": {
          "!doc": "Automatically called by World.preUpdate.",
          "!type": "fn() -> +Boolean"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "game": {
          "!doc": "A reference to the currently running Game.",
          "!type": "+Phaser.Game"
        },
        "components": {
          "!doc": "The components this Game Object has installed.",
          "!type": "+Object"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "alive": {
          "!doc": "A useful flag to control if the Game Object is alive or dead.\n\nThis is set automatically by the Health components `damage` method should the object run out of health.\nOr you can toggle it via your game code.\n\nThis property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.\nHowever you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.",
          "!type": "+Boolean"
        },
        "update": {
          "!doc": "Override this method in your own custom objects to handle any update requirements.\nIt is called immediately after `preUpdate` and before `postUpdate`.\nRemember if this Game Object has any children you should call update on those too.",
          "!type": "fn()"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "inWorld": {
          "!doc": "Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.",
          "!type": "+Boolean"
        },
        "tint": {
          "!doc": "The tint applied to the BitmapText. This is a hex value. Set to white to disable (0xFFFFFF)",
          "!type": "+Number"
        },
        "inputEnabled": {
          "!doc": "By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created\nfor this Game Object and it will then start to process click / touch events and more.\n\nYou can then access the Input Handler via `this.input`.\n\nNote that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.\n\nIf you set this property to false it will stop the Input Handler from processing any more input events.",
          "!type": "+Boolean"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "world": {
          "!doc": "The world coordinates of this Game Object in pixels.\nDepending on where in the display list this Game Object is placed this value can differ from `position`, \nwhich contains the x/y coordinates relative to the Game Objects parent.",
          "!type": "+Phaser.Point"
        },
        "top": {
          "!doc": "The y coordinate of the Game Object.\nThis is the same as `y - offsetY`.",
          "!type": "+Number"
        },
        "animations": {
          "!doc": "If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.\nThrough it you can create, play, pause and stop animations.",
          "!type": "+Phaser.AnimationManager"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "angle": {
          "!doc": "The angle property is the rotation of the Game Object in *degrees* from its original orientation.\n\nValues from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n\nValues outside this range are added to or subtracted from 360 to obtain a value within the range. \nFor example, the statement player.angle = 450 is the same as player.angle = 90.\n\nIf you wish to work in radians instead of degrees you can use the property `rotation` instead. \nWorking in radians is slightly faster as it doesn't have to perform any calculations.",
          "!type": "+Number"
        },
        "checkWorldBounds": {
          "!doc": "If this is set to `true` the Game Object checks if it is within the World bounds each frame. \n\nWhen it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.\n\nIf it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.\n\nIt also optionally kills the Game Object if `outOfBoundsKill` is `true`.\n\nWhen `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "key": {
          "!doc": "The key of the image or texture used by this Game Object during rendering.\nIf it is a string it's the string used to retrieve the texture from the Phaser Image Cache.\nIt can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.\nIf a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.\nIf a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.",
          "!type": "+String"
        },
        "dirty": {
          "!doc": "The dirty state of this object.",
          "!type": "+Boolean"
        },
        "debug": {
          "!doc": "A debug flag designed for use with `Game.enableStep`.",
          "!type": "+Boolean"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "outOfCameraBoundsKill": {
          "!doc": "If this and the `autoCull` property are both set to `true`, then the `kill` method\nis called as soon as the Game Object leaves the camera bounds.",
          "!type": "+Boolean"
        },
        "destroyPhase": {
          "!doc": "As a Game Object runs through its destroy method this flag is set to true, \nand can be checked in any sub-systems or plugins it is being destroyed from.",
          "!type": "+Boolean"
        },
        "right": {
          "!doc": "The right coordinate of the Game Object.\nThis is the same as `x + width - offsetX`.",
          "!type": "+Number"
        },
        "kill": {
          "!doc": "Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.\n\nIt will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.\n\nNote that killing a Game Object is a way for you to quickly recycle it in an object pool,\nit doesn't destroy the object or free it up from memory.\n\nIf you don't need this Game Object any more you should call `destroy` instead.",
          "!type": "fn() -> +PIXI.DisplayObject"
        },
        "previousPosition": {
          "!doc": "The position the Game Object was located in the previous frame.",
          "!type": "+Phaser.Point"
        },
        "textHeight": {
          "!doc": "The height in pixels of the overall text area, taking into consideration multi-line text.",
          "!type": "+Number"
        },
        "pendingDestroy": {
          "!doc": "A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.\nYou can set it directly to allow you to flag an object to be destroyed on its next update.\n\nThis is extremely useful if you wish to destroy an object from within one of its own callbacks \nsuch as with Buttons or other Input events.",
          "!type": "+Boolean"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "anchor": {
          "!doc": "The anchor value of this BitmapText.",
          "!type": "+Phaser.Point"
        },
        "autoCull": {
          "!doc": "A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.\nIf it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.\nThis keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.\n\nThis is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,\nor you have tested performance and find it acceptable.",
          "!type": "+Boolean"
        },
        "x": {
          "!doc": "The position of the Game Object on the x axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "exists": {
          "!doc": "Controls if this Game Object is processed by the core game loop.\nIf this Game Object has a physics body it also controls if its physics body is updated or not.\nWhen `exists` is set to `false` it will remove its physics body from the physics world if it has one.\nIt also toggles the `visible` property to false as well.\n\nSetting `exists` to true will add its physics body back in to the physics world, if it has one.\nIt will also set the `visible` property to `true`.",
          "!type": "+Boolean"
        },
        "y": {
          "!doc": "The position of the Game Object on the y axis relative to the local coordinates of the parent.",
          "!type": "+Number"
        },
        "z": {
          "!doc": "The z depth of this Game Object within its parent Group.\nNo two objects in a Group can have the same z value.\nThis value is adjusted automatically whenever the Group hierarchy changes.\nIf you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.",
          "!type": "+Number"
        },
        "fresh": {
          "!doc": "A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.\nThis property is mostly used internally by the physics systems, but is exposed for the use of plugins.",
          "!type": "+Boolean"
        },
        "setText": {
          "!doc": "The text to be displayed by this BitmapText object.\n\nIt's faster to use `BitmapText.text = string`, but this is kept for backwards compatibility.",
          "!type": "fn(text: +String)"
        },
        "font": {
          "!doc": "The font the text will be rendered in, i.e. 'Arial'. Must be loaded in the browser before use.",
          "!type": "+String"
        }
      }
    },
    "Timer": {
      "HALF": "+Number",
      "QUARTER": "+Number",
      "!doc": "A Timer is a way to create and manage {@link Phaser.TimerEvent timer events} that wait for a specific duration and then run a callback.\nMany different timer events, with individual delays, can be added to the same Timer.\n\nAll Timer delays are in milliseconds (there are 1000 ms in 1 second); so a delay value of 250 represents a quarter of a second.\n\nTimers are based on real life time, adjusted for game pause durations.\nThat is, *timer events are based on elapsed {@link Phaser.Time game time}* and do *not* take physics time or slow motion into account.",
      "MINUTE": "+Number",
      "SECOND": "+Number",
      "!type": "fn(game: +Phaser.Game, autoDestroy: +Boolean)",
      "prototype": {
        "next": {
          "!doc": "The time at which the next event will occur.",
          "!type": "+Number"
        },
        "game": {
          "!doc": "Local reference to game.",
          "!type": "+Phaser.Game"
        },
        "paused": {
          "!doc": "The paused state of the Timer. You can pause the timer by calling Timer.pause() and Timer.resume() or by the game pausing.",
          "!type": "+Boolean"
        },
        "update": {
          "!doc": "The main Timer update event, called automatically by Phaser.Time.update.",
          "!type": "fn(time: +Number) -> +Boolean"
        },
        "remove": {
          "!doc": "Removes a pending TimerEvent from the queue.",
          "!type": "fn(event: +Phaser.TimerEvent)"
        },
        "running": {
          "!doc": "True if the Timer is actively running.\n\nDo not modify this boolean - use {@link Phaser.Timer#pause pause} (and {@link Phaser.Timer#resume resume}) to pause the timer.",
          "!type": "+Boolean"
        },
        "elapsed": {
          "!doc": "Elapsed time since the last frame (in ms).",
          "!type": "+Number"
        },
        "duration": {
          "!doc": "The duration in ms remaining until the next event will occur.",
          "!type": "+Number"
        },
        "removeAll": {
          "!doc": "Removes all Events from this Timer and all callbacks linked to onComplete, but leaves the Timer running.    \nThe onComplete callbacks won't be called.",
          "!type": "fn()"
        },
        "seconds": {
          "!doc": "The duration in seconds that this Timer has been running for.",
          "!type": "+Number"
        },
        "expired": {
          "!doc": "An expired Timer is one in which all of its events have been dispatched and none are pending.",
          "!type": "+Boolean"
        },
        "loop": {
          "!doc": "Adds a new looped Event to this Timer that will repeat forever or until the Timer is stopped.\n\nThe event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.\nThe delay is in relation to when the Timer starts, not the time it was added. If the Timer is already running the delay will be calculated based on the timers current time.\n\nMake sure to call {@link Phaser.Timer#start start} after adding all of the Events you require for this Timer.",
          "!type": "fn(delay: +Number, callback: +Function, callbackContext: +Object, arguments: +any) -> +Phaser.TimerEvent"
        },
        "nextTick": {
          "!doc": "The time the next tick will occur.",
          "!type": "+Number"
        },
        "repeat": {
          "!doc": "Adds a new TimerEvent that will always play through once and then repeat for the given number of iterations.\n\nThe event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.\nThe delay is in relation to when the Timer starts, not the time it was added.\nIf the Timer is already running the delay will be calculated based on the timers current time.\n\nMake sure to call {@link Phaser.Timer#start start} after adding all of the Events you require for this Timer.",
          "!type": "fn(delay: +Number, repeatCount: +Number, callback: +Function, callbackContext: +Object, arguments: +any) -> +Phaser.TimerEvent"
        },
        "events": {
          "!doc": "An array holding all of this timers Phaser.TimerEvent objects. Use the methods add, repeat and loop to populate it.",
          "!type": "+Array._Phaser.TimerEvent_"
        },
        "order": {
          "!doc": "Orders the events on this Timer so they are in tick order.\nThis is called automatically when new events are created.",
          "!type": "fn()"
        },
        "add": {
          "!doc": "Adds a new Event to this Timer.\n\nThe event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.\nThe delay is in relation to when the Timer starts, not the time it was added. If the Timer is already running the delay will be calculated based on the timers current time.\n\nMake sure to call {@link Phaser.Timer#start start} after adding all of the Events you require for this Timer.",
          "!type": "fn(delay: +Number, callback: +Function, callbackContext: +Object, arguments: +any) -> +Phaser.TimerEvent"
        },
        "resume": {
          "!doc": "Resumes the Timer and updates all pending events.",
          "!type": "fn()"
        },
        "autoDestroy": {
          "!doc": "If true, the timer will automatically destroy itself after all the events have been dispatched (assuming no looping events).",
          "!type": "+Boolean"
        },
        "clearPendingEvents": {
          "!doc": "Clears any events from the Timer which have pendingDelete set to true and then resets the private _len and _i values.",
          "!type": "fn()"
        },
        "ms": {
          "!doc": "The duration in milliseconds that this Timer has been running for.",
          "!type": "+Number"
        },
        "onComplete": {
          "!doc": "This signal will be dispatched when this Timer has completed which means that there are no more events in the queue.\n\nThe signal is supplied with one argument, `timer`, which is this Timer object.",
          "!type": "+Phaser.Signal"
        },
        "start": {
          "!doc": "Starts this Timer running.",
          "!type": "fn(delay: +Number)"
        },
        "length": {
          "!doc": "The number of pending events in the queue.",
          "!type": "+Number"
        },
        "destroy": {
          "!doc": "Destroys this Timer. Any pending Events are not dispatched.\nThe onComplete callbacks won't be called.",
          "!type": "fn()"
        },
        "timeCap": {
          "!doc": "If the difference in time between two frame updates exceeds this value, the event times are reset to avoid catch-up situations.",
          "!type": "+Number"
        },
        "pause": {
          "!doc": "Pauses the Timer and all events in the queue.",
          "!type": "fn()"
        },
        "adjustEvents": {
          "!doc": "Adjusts the time of all pending events and the nextTick by the given baseTime.",
          "!type": "fn()"
        },
        "stop": {
          "!doc": "Stops this Timer from running. Does not cause it to be destroyed if autoDestroy is set to true.",
          "!type": "fn(clearEvents: +Boolean)"
        }
      }
    },
    "Filter": {
      "!doc": "This is a base Filter class to use for any Phaser filter development.\n\nThe vast majority of filters (including all of those that ship with Phaser) use fragment shaders, and\ntherefore only work in WebGL and are not supported by Canvas at all.",
      "!type": "fn(game: +Phaser.Game, uniforms: +Object, fragmentSrc: +Array)",
      "prototype": {
        "dirty": {
          "!doc": "Internal PIXI var.",
          "!type": "+Boolean"
        },
        "init": {
          "!doc": "Should be over-ridden.",
          "!type": "fn()"
        },
        "padding": {
          "!doc": "Internal PIXI var.",
          "!type": "+Number"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "setResolution": {
          "!doc": "Set the resolution uniforms on the filter.",
          "!type": "fn(width: +Number, height: +Number)"
        },
        "update": {
          "!doc": "Updates the filter.",
          "!type": "fn(pointer: +Phaser.Pointer)"
        },
        "destroy": {
          "!doc": "Clear down this Filter and null out references",
          "!type": "fn()"
        },
        "uniforms": {
          "!doc": "Default uniform mappings. Compatible with ShaderToy and GLSLSandbox.",
          "!type": "+Object"
        },
        "fragmentSrc": {
          "!doc": "The fragment shader code.",
          "!type": "+Array"
        },
        "type": {
          "!doc": "The const type of this object, either Phaser.WEBGL_FILTER or Phaser.CANVAS_FILTER.",
          "!type": "+Number"
        },
        "addToWorld": {
          "!doc": "Creates a new Phaser.Image object using a blank texture and assigns \nthis Filter to it. The image is then added to the world.\n\nIf you don't provide width and height values then Filter.width and Filter.height are used.\n\nIf you do provide width and height values then this filter will be resized to match those\nvalues.",
          "!type": "fn(x: +Number, y: +Number, width: +Number, height: +Number, anchorX: +Number, anchorY: +Number) -> +Phaser.Image"
        },
        "width": {
          "!doc": "The width (resolution uniform)",
          "!type": "+Number"
        },
        "prevPoint": {
          "!doc": "The previous position of the pointer (we don't update the uniform if the same)",
          "!type": "+Phaser.Point"
        },
        "height": {
          "!doc": "The height (resolution uniform)",
          "!type": "+Number"
        }
      }
    },
    "POINTER": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "ArrayUtils": {
      "rotate": {
        "!doc": "Moves the element from the start of the array to the end, shifting all items in the process.\nThe \"rotation\" happens to the left.",
        "!type": "fn(array: +Array._any_) -> +Object"
      },
      "rotateMatrix": {
        "!doc": "Rotates the given matrix (array of arrays).\n\nBased on the routine from {@link http://jsfiddle.net/MrPolywhirl/NH42z/}.",
        "!type": "fn(matrix: +Array._Array._any__, direction: +Number) -> +Array._Array._any__"
      },
      "!doc": "Utility functions for dealing with Arrays.",
      "removeRandomItem": {
        "!doc": "Removes a random object from the given array and returns it.\n\nWill return null if there are no array items that fall within the specified range\nor if there is no item for the randomly chosen index.",
        "!type": "fn(objects: +Array._any_, startIndex: +Number, length: +Number) -> +Object"
      },
      "transposeMatrix": {
        "!doc": "Transposes the elements of the given matrix (array of arrays).",
        "!type": "fn(array: +Array._Array._any__) -> +Array._Array._any__"
      },
      "findClosest": {
        "!doc": "Snaps a value to the nearest value in an array.\nThe result will always be in the range `[first_value, last_value]`.",
        "!type": "fn(value: +Number, arr: +Array._number_) -> +Number"
      },
      "!type": "fn()",
      "getRandomItem": {
        "!doc": "Fetch a random entry from the given array.\n\nWill return null if there are no array items that fall within the specified range\nor if there is no item for the randomly chosen index.",
        "!type": "fn(objects: +Array._any_, startIndex: +Number, length: +Number) -> +Object"
      },
      "shuffle": {
        "!doc": "A standard Fisher-Yates Array shuffle implementation which modifies the array in place.",
        "!type": "fn(array: +Array._any_) -> +Array._any_"
      },
      "prototype": {
        "numberArray": {
          "!doc": "Create an array representing the inclusive range of numbers (usually integers) in `[start, end]`.\nThis is equivalent to `numberArrayStep(start, end, 1)`.",
          "!type": "fn(start: +Number, end: +Number) -> +Array._number_"
        },
        "numberArrayStep": {
          "!doc": "Create an array of numbers (positive and/or negative) progressing from `start`\nup to but not including `end` by advancing by `step`.\n\nIf `start` is less than `end` a zero-length range is created unless a negative `step` is specified.\n\nCertain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;\nfor forward compatibility make sure to pass in actual numbers.",
          "!type": "fn(start: +Number, end: +Number, step: +Number) -> +Array"
        }
      }
    },
    "POINT": {
      "!doc": "Game Object type.",
      "!type": "+Number"
    },
    "Plugin": {
      "!doc": "This is a base Plugin template to use for any Phaser plugin development.",
      "!type": "fn(game: +Phaser.Game, parent: +Object)",
      "prototype": {
        "hasPostRender": {
          "!doc": "A flag to indicate if this plugin has a postRender method.",
          "!type": "+Boolean"
        },
        "postRender": {
          "!doc": "Post-render is called after the Game Renderer and State.render have run.\nIt is only called if visible is set to true.",
          "!type": "fn()"
        },
        "parent": {
          "!doc": "The parent of this plugin. If added to the PluginManager the parent will be set to that, otherwise it will be null.",
          "!type": "+Object"
        },
        "hasPreUpdate": {
          "!doc": "A flag to indicate if this plugin has a preUpdate method.",
          "!type": "+Boolean"
        },
        "game": {
          "!doc": "A reference to the currently running game.",
          "!type": "+Phaser.Game"
        },
        "visible": {
          "!doc": "A Plugin with visible=true has its render and postRender methods called by the parent, otherwise they are skipped.",
          "!type": "+Boolean"
        },
        "hasPostUpdate": {
          "!doc": "A flag to indicate if this plugin has a postUpdate method.",
          "!type": "+Boolean"
        },
        "update": {
          "!doc": "Update is called after all the core subsystems (Input, Tweens, Sound, etc) and the State have updated, but before the render.\nIt is only called if active is set to true.",
          "!type": "fn()"
        },
        "destroy": {
          "!doc": "Clear down this Plugin and null out references",
          "!type": "fn()"
        },
        "active": {
          "!doc": "A Plugin with active=true has its preUpdate and update methods called by the parent, otherwise they are skipped.",
          "!type": "+Boolean"
        },
        "hasRender": {
          "!doc": "A flag to indicate if this plugin has a render method.",
          "!type": "+Boolean"
        },
        "hasUpdate": {
          "!doc": "A flag to indicate if this plugin has an update method.",
          "!type": "+Boolean"
        },
        "preUpdate": {
          "!doc": "Pre-update is called at the very start of the update cycle, before any other subsystems have been updated (including Physics).\nIt is only called if active is set to true.",
          "!type": "fn()"
        },
        "render": {
          "!doc": "Render is called right after the Game Renderer completes, but before the State.render.\nIt is only called if visible is set to true.",
          "!type": "fn()"
        }
      }
    }
  },
  "CanvasGraphics": {
    "!doc": "A set of functions used by the canvas renderer to draw the primitive graphics data.",
    "!type": "fn()",
    "prototype": {}
  },
  "PIXI": {
    "Strip": {
      "!doc": "",
      "!type": "fn(texture: +Texture, width: +Number, height: +Number)",
      "prototype": {
        "dirty": {
          "!doc": "Whether the strip is dirty or not",
          "!type": "+Boolean"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "canvasPadding": {
          "!doc": "Triangles in canvas mode are automatically antialiased, use this value to force triangles to overlap a bit with each other.",
          "!type": "+Number"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "texture": {
          "!doc": "The texture of the strip",
          "!type": "+Texture"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.",
          "!type": "+Number"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "DrawModes": {
          "!doc": "Different drawing buffer modes supported",
          "!type": "+Object"
        }
      },
      "DrawModes": {
        "!doc": "Different drawing buffer modes supported",
        "!type": "+Object"
      }
    },
    "DisplayObject": {
      "!doc": "The base class for all objects that are rendered on the screen.\nThis is an abstract class and should not be used on its own rather it should be extended.",
      "!type": "fn()",
      "prototype": {
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        }
      }
    },
    "Rope": {
      "!doc": "",
      "!type": "fn(texture: +Texture, points: +Array)",
      "prototype": {
        "dirty": {
          "!doc": "Whether the strip is dirty or not",
          "!type": "+Boolean"
        },
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "canvasPadding": {
          "!doc": "Triangles in canvas mode are automatically antialiased, use this value to force triangles to overlap a bit with each other.",
          "!type": "+Number"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "texture": {
          "!doc": "The texture of the strip",
          "!type": "+Texture"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.",
          "!type": "+Number"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "DrawModes": {
          "!doc": "Different drawing buffer modes supported",
          "!type": "+Object"
        }
      },
      "DrawModes": {
        "!doc": "Different drawing buffer modes supported",
        "!type": "+Object"
      }
    },
    "Sprite": {
      "!doc": "The Sprite object is the base for all textured objects that are rendered to the screen",
      "!type": "fn(texture: +Texture)",
      "prototype": {
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "shader": {
          "!doc": "The shader that will be used to render the texture to the stage. Set to null to remove a current shader.",
          "!type": "+PIXI.AbstractFilter"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "texture": {
          "!doc": "The texture that the sprite is using",
          "!type": "+Texture"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "tint": {
          "!doc": "The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.",
          "!type": "+Number"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "tintedTexture": {
          "!doc": "A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)",
          "!type": "+Phaser.Canvas"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.\n\nWarning: You cannot have a blend mode and a filter active on the same Sprite. Doing so will render the sprite invisible.",
          "!type": "+Number"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "anchor": {
          "!doc": "The anchor sets the origin point of the texture.\nThe default is 0,0 this means the texture's origin is the top left\nSetting than anchor to 0.5,0.5 means the textures origin is centered\nSetting the anchor to 1,1 would mean the textures origin points will be the bottom right corner",
          "!type": "+Phaser.Point"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        }
      }
    },
    "AbstractFilter": {
      "!doc": "This is the base class for creating a PIXI filter. Currently only webGL supports filters.\nIf you want to make a custom filter this should be your base class.",
      "!type": "fn(fragmentSrc: +Array, uniforms: +Object)",
      "prototype": {
        "dirty": {
          "!doc": "",
          "!type": "+Boolean"
        },
        "padding": {
          "!doc": "",
          "!type": "+Number"
        }
      }
    },
    "TilingSprite": {
      "!doc": "A tiling sprite is a fast way of rendering a tiling image",
      "!type": "fn(texture: +Texture, width: +Number, height: +Number)",
      "prototype": {
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "shader": {
          "!doc": "The shader that will be used to render the texture to the stage. Set to null to remove a current shader.",
          "!type": "+PIXI.AbstractFilter"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "renderable": {
          "!doc": "Whether this sprite is renderable or not",
          "!type": "+Boolean"
        },
        "tileScaleOffset": {
          "!doc": "A point that represents the scale of the texture object",
          "!type": "+Phaser.Point"
        },
        "tilePosition": {
          "!doc": "The offset position of the image that is being tiled",
          "!type": "+Phaser.Point"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "tilePattern": {
          "!doc": "The Context fill pattern that is used to draw the TilingSprite in Canvas mode only (will be null in WebGL).",
          "!type": "+PIXI.Texture"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "canvasBuffer": {
          "!doc": "The CanvasBuffer object that the tiled texture is drawn to.",
          "!type": "+PIXI.CanvasBuffer"
        },
        "tint": {
          "!doc": "The tint applied to the sprite. This is a hex value",
          "!type": "+Number"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "tintedTexture": {
          "!doc": "A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)",
          "!type": "+Phaser.Canvas"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "height": {
          "!doc": "The height of the tiling sprite",
          "!type": "+Number"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "tileScale": {
          "!doc": "The scaling of the image that is being tiled",
          "!type": "+Phaser.Point"
        },
        "texture": {
          "!doc": "The texture that the sprite is using",
          "!type": "+Texture"
        },
        "textureDebug": {
          "!doc": "If enabled a green rectangle will be drawn behind the generated tiling texture, allowing you to visually\ndebug the texture being used.",
          "!type": "+Boolean"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "blendMode": {
          "!doc": "The blend mode to be applied to the sprite",
          "!type": "+Number"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "anchor": {
          "!doc": "The anchor sets the origin point of the texture.\nThe default is 0,0 this means the texture's origin is the top left\nSetting than anchor to 0.5,0.5 means the textures origin is centered\nSetting the anchor to 1,1 would mean the textures origin points will be the bottom right corner",
          "!type": "+Phaser.Point"
        },
        "width": {
          "!doc": "The width of the tiling sprite",
          "!type": "+Number"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        },
        "refreshTexture": {
          "!doc": "If true the TilingSprite will run generateTexture on its **next** render pass.\nThis is set by the likes of Phaser.LoadTexture.setFrame.",
          "!type": "+Boolean"
        },
        "tilingTexture": {
          "!doc": "An internal Texture object that holds the tiling texture that was generated from TilingSprite.texture.",
          "!type": "+PIXI.Texture"
        }
      }
    },
    "DisplayObjectContainer": {
      "!doc": "A DisplayObjectContainer represents a collection of display objects.\nIt is the base class of all display objects that act as a container for other objects.",
      "!type": "fn()",
      "prototype": {
        "worldRotation": {
          "!doc": "The rotation of the Display Object, in radians, based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Number"
        },
        "filterArea": {
          "!doc": "The area the filter is applied to like the hitArea this is used as more of an optimisation\nrather than figuring out the dimensions of the displayObject each frame you can set this rectangle",
          "!type": "+Phaser.Rectangle"
        },
        "parent": {
          "!doc": "[read-only] The display object container that contains this display object.",
          "!type": "+PIXI.DisplayObjectContainer"
        },
        "renderable": {
          "!doc": "Can this object be rendered",
          "!type": "+Boolean"
        },
        "visible": {
          "!doc": "The visibility of the object.",
          "!type": "+Boolean"
        },
        "worldScale": {
          "!doc": "The scale of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "rotation": {
          "!doc": "The rotation of the object in radians.",
          "!type": "+Number"
        },
        "scale": {
          "!doc": "The scale factor of the object.",
          "!type": "+Phaser.Point"
        },
        "worldAlpha": {
          "!doc": "[read-only] The multiplied alpha of the displayObject",
          "!type": "+Number"
        },
        "worldPosition": {
          "!doc": "The position of the Display Object based on the world transform.\nThis value is updated at the end of updateTransform and takes all parent transforms into account.",
          "!type": "+Phaser.Point"
        },
        "stage": {
          "!doc": "[read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.",
          "!type": "+Phaser.Stage"
        },
        "children": {
          "!doc": "[read-only] The array of children of this container.",
          "!type": "+Array_DisplayObject_"
        },
        "hitArea": {
          "!doc": "This is the defined area that will pick up mouse / touch events. It is null by default.\nSetting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)",
          "!type": "+Phaser.Rectangle"
        },
        "alpha": {
          "!doc": "The opacity of the object.",
          "!type": "+Number"
        },
        "pivot": {
          "!doc": "The pivot point of the displayObject that it rotates around",
          "!type": "+Phaser.Point"
        },
        "position": {
          "!doc": "The coordinate of the object relative to the local coordinates of the parent.",
          "!type": "+Phaser.Point"
        }
      }
    },
    "GraphicsData": {
      "!doc": "A GraphicsData object.",
      "!type": "fn(lineWidth: +Number, lineColor: +Number, lineAlpha: +Number, fillColor: +Number, fillAlpha: +Number, fill: +Boolean, shape: +Circle)",
      "prototype": {}
    },
    "SpriteBatch": {
      "!doc": "The SpriteBatch class is a really fast version of the DisplayObjectContainer \nbuilt solely for speed, so use when you need a lot of sprites or particles.\nAnd it's extremely easy to use : \n\n    var container = new PIXI.SpriteBatch();\n \n    stage.addChild(container);\n \n    for(var i  = 0; i < 100; i++)\n    {\n        var sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n        container.addChild(sprite);\n    }\nAnd here you have a hundred sprites that will be renderer at the speed of light",
      "!type": "fn(texture: +Texture)",
      "prototype": {}
    }
  }
};
    
})

